// External interface for robot <-> app and robot <-> sdk communication

syntax = "proto3";

package Anki.Vector.external_interface;

import "extensions.proto";
import "onboardingSteps.proto";

// A null message used by streams to verify that the client is
// still connected.
message KeepAlivePing {}

message ResponseStatus {
  enum StatusCode {
    UNKNOWN = 0;
    RESPONSE_RECEIVED = 1; // The message has completed as expected
    REQUEST_PROCESSING = 2; // The message has been sent to the robot
    OK = 3;
    FORBIDDEN = 100; // The user was not authorizied
    NOT_FOUND = 101; // The requested attribute was not found
    ERROR_UPDATE_IN_PROGRESS = 102; // The current rpc is currently updating values from another call
  }
  StatusCode code = 1;
}

message Animation {
  string name = 1;
}

message DriveWheelsRequest {
  float left_wheel_mmps   = 1;
  float right_wheel_mmps  = 2;
  float left_wheel_mmps2  = 3;
  float right_wheel_mmps2 = 4;
}

message DriveWheelsResponse {
  ResponseStatus status = 1;
}

message MoveHeadRequest {
  float speed_rad_per_sec = 1;
}

message MoveHeadResponse {
  ResponseStatus status = 1;
}

message MoveLiftRequest {
  float speed_rad_per_sec = 1;
}

message MoveLiftResponse {
  ResponseStatus status = 1;
}

message DriveArcRequest {
  float speed = 1;
  float accel = 2;
  int32 curvature_radius_mm = 3;
}

message DriveArcResponse {
  ResponseStatus status = 1;
}

// TODO: hook up ignore tracks and test that they work in the new world
message PlayAnimationRequest {
  Animation animation = 1;
  uint32 loops = 2;
  bool ignore_body_track = 3;
  bool ignore_head_track = 4;
  bool ignore_lift_track = 5;
}

message PlayAnimationResponse {
  ResponseStatus status = 1;
  BehaviorResults result = 2;
}

message ListAnimationsRequest {}

message ListAnimationsResponse {
  ResponseStatus status = 1;
  repeated Animation animation_names = 2;
}

message FeatureStatus {
  string feature_name = 1;
  string source      = 2; // Voice, App, AI, Unknown
}

message DisplayFaceImageRGBRequest {
  bytes face_data = 1;
  uint32 duration_ms = 2;
  bool interrupt_running = 3;
}

message DisplayFaceImageRGBResponse {
  ResponseStatus status = 1;
}

message MeetVictorFaceScanStarted
{
}

message MeetVictorFaceScanComplete
{
}

message Status {
  oneof status_type {
    FeatureStatus                   feature_status                   = 1;
    MeetVictorFaceScanStarted       meet_victor_face_scan_started    = 2;
    MeetVictorFaceScanComplete      meet_victor_face_scan_complete   = 3;
    FaceEnrollmentCompleted         face_enrollment_completed        = 4;
  }
}

message Onboarding {
  oneof onboarding_type {
    OnboardingState                    onboarding_state              = 1;
    OnboardingOnCharger                onboarding_on_charger         = 2;
    OnboardingLowBattery               onboarding_battery            = 3;
    OnboardingPhysicalInterruption     onboarding_physical           = 4;
    OnboardingSeesCube                 onboarding_sees_cube          = 5;
    OnboardingCantFindCube             onboarding_cant_find_cube     = 6;
    OnboardingRobotExpectingStep       onboarding_expecting_step     = 7;
    OnboardingHabitatDetected          onboarding_habitat_detected   = 8;
  }
}

message WakeWord {
  oneof wake_word_type {
    WakeWordBegin     wake_word_begin    = 1;
    WakeWordEnd       wake_word_end      = 2;
  }
}

message TimeStampedStatus {
  Status status = 1;
  uint32 timestamp_utc = 2;
}

message RobotHistoryRequest {
}

message RobotHistoryResponse {
  repeated TimeStampedStatus messages = 1;
}

message PoseStruct {
  // Translation
  float x = 1;
  float y = 2;
  float z = 3;
  
  // Rotation quaternion
  float q0 = 4;
  float q1 = 5;
  float q2 = 6;
  float q3 = 7;

  uint32 origin_id = 8; // Which coordinate frame this pose is in (0 for none or unknown)
}

message AccelData {
  float x = 1;  // mm/s^2
  float y = 2;
  float z = 3;
}

message GyroData {
  float x = 1;  // rad/s
  float y = 2;
  float z = 3;
}

message ProxData {
  uint32 distance_mm             = 1;
  float  signal_quality          = 2;
  bool   is_in_valid_range       = 3; // Distance is within valid range
  bool   is_valid_signal_quality = 4; // Signal quality is sufficiently strong to trust that something was detected
  bool   is_lift_in_fov          = 5; // Lift (or object on lift) is occluding the sensor
  bool   is_too_pitched          = 6; // Robot is too far pitched up or down
}

message RobotState {
  PoseStruct pose = 1;
  float pose_angle_rad = 2;
  float pose_pitch_rad = 3;
  float left_wheel_speed_mmps = 4;
  float right_wheel_speed_mmps = 5;
  float head_angle_rad = 6;
  float lift_height_mm = 7;
  AccelData accel = 8;
  GyroData gyro = 9;
  int32 carrying_object_id = 10;
  int32 carrying_object_on_top_id = 11;
  int32 head_tracking_object_id = 12;
  int32 localized_to_object_id = 13;
  uint32 last_image_time_stamp = 14;
  uint32 status = 15;
  ProxData prox_data = 16;
}

message CladPoint
{
  float x = 1;
  float y = 2;
}

message CladRect
{
  float x_top_left = 1;
  float y_top_left = 2;
  float width = 3;
  float height = 4;
}

// This is an int8 on the clad side.
// Proto field names are prefixed with "EXPRESSION_"
enum FacialExpression
{
  option allow_alias = true;
  EXPRESSION_UNKNOWN = 0;    // e.g. expression estimation disabled.

  EXPRESSION_NEUTRAL = 1;
  EXPRESSION_HAPPINESS = 2;
  EXPRESSION_SURPRISE = 3;
  EXPRESSION_ANGER = 4;
  EXPRESSION_SADNESS = 5;

  // Clad does not account for "Unknown" in the count.
  EXPRESSION_COUNT = 5;
}

message RobotObservedFace {
  int32 face_id = 1;         // negative: tracked but not recognized; positive: recognized face
  uint32 timestamp = 2;
  PoseStruct pose = 3;
  CladRect img_rect = 4;       // position in image coords
  string name = 5;           // Empty if none assigned yet

  FacialExpression expression = 6;

  // Individual expression values histogram, sums to 100 (Exception: all zero if expression=Unknown)
  repeated uint32 expression_values = 7; // This is a uint32 on the clad side

  // Face landmarks
  repeated CladPoint left_eye = 8;
  repeated CladPoint right_eye = 9;
  repeated CladPoint nose = 10;
  repeated CladPoint mouth = 11;
}

// RobotChangedObservedFaceID
//  This generally happens when a tracked face (negative ID) is recognized and
//  receives a positive ID or when face records get merged
message RobotChangedObservedFaceID {
  int32   old_id = 1;
  int32   new_id = 2;
}

// Meet Victor
message AppIntentRequest {
  string intent = 1;
  string param = 2;
}

enum FaceEnrollmentResult
{
  SUCCESS = 0;

  // Failures:
  SAW_WRONG_FACE = 1;
  SAW_MULTIPLE_FACES = 2;
  TIMED_OUT = 3;
  SAVE_FAILED = 4;
  INCOMPLETE = 5;
  CANCELLED = 6;
  NAME_IN_USE = 7;
  NAMED_STORAGE_FULL = 8;
  UNKNOWN_FAILURE = 9;
}

message AppIntentResponse {
  ResponseStatus status = 1;
}

message FaceEnrollmentCompleted {
  FaceEnrollmentResult result = 1;
  int32                face_id = 2;
  string               name = 3;
}

message CancelFaceEnrollmentRequest {
}

message CancelFaceEnrollmentResponse {
  ResponseStatus status = 1;
}

message RequestEnrolledNamesRequest {
}

message LoadedKnownFace {
  int64  seconds_since_first_enrolled = 1;
  int64  seconds_since_last_updated = 2;
  int64  seconds_since_last_seen = 3;
  int64  last_seen_seconds_since_epoch = 4;
  int32  face_id = 5;
  string name = 6;
}

message RobotRenamedEnrolledFace {
    int32   face_id = 1;
    string   name = 2;
}

message RequestEnrolledNamesResponse {
  ResponseStatus status = 1;
  repeated LoadedKnownFace faces = 2;
}

message UpdateEnrolledFaceByIDRequest {
  int32 face_id = 1;
  string old_name = 2;
  string new_name = 3;
}

message UpdateEnrolledFaceByIDResponse {
  ResponseStatus status = 1;
}

message EraseEnrolledFaceByIDRequest {
  int32 face_id = 1;
}

message EraseEnrolledFaceByIDResponse {
  ResponseStatus status = 1;
}

message EraseAllEnrolledFacesRequest {
}

message EraseAllEnrolledFacesResponse {
  ResponseStatus status = 1;
}

message SetFaceToEnrollRequest {
  string  name = 1;

  int32   observed_id = 2;  // The ID of a specific observed face to enroll (0 for next one we see)
  int32   save_id = 3;      // The ID of an existing face to merge final enrollment into (0 for none,
                        // i.e. use observedID)

  bool    save_to_robot = 4;   // Save to robot's NVStorage when done (NOTE: will (re)save everyone enrolled!)
  bool    say_name = 5;       // Play say-name/celebration animations on success before completing
  bool    use_music = 6;       // Starts special music during say-name animations (will leave music playing!)
}
message SetFaceToEnrollResponse {
  ResponseStatus status = 1;
}

enum BehaviorResults
{
  BEHAVIOR_INVALID_STATE = 0;
  BEHAVIOR_COMPLETE_STATE = 1;
  BEHAVIOR_WONT_ACTIVATE_STATE = 2;
}

message DriveOffChargerRequest {
}

message DriveOffChargerResponse {
  ResponseStatus status = 1;
  BehaviorResults result = 2;
}

message DriveOnChargerRequest {
}

message DriveOnChargerResponse {
  ResponseStatus status = 1;
  BehaviorResults result = 2;
}

// TODO: Remove these when pings are part of the event stream, and
// app team is converted over
message Ping {
  uint64 ping = 1;
}

// TODO: Remove these when pings are part of the event stream, and
// app team is converted over
message Pong {
  uint64 pong = 1;
}

enum OnboardingStages
{
  NotStarted = 0;
  FinishedComeHere = 1;
  FinishedMeetVictor = 2;
  Complete = 3;
  DevDoNothing = 4;
}

message OnboardingState {
  OnboardingStages stage = 1;
}

message OnboardingOnCharger {
  bool on_charger = 1;
  bool needs_to_charge = 2;
  float required_charge_time_s = 3;
}

message OnboardingLowBattery {
  bool low_battery = 1;
}

// these are sent in case the copy needs to change
enum OnboardingPhysicalInterruptions {
  ONBOARDING_INTERRUPTION_NONE         = 0;
  ONBOARDING_INTERRUPTION_PICKED_UP    = 1;
  ONBOARDING_INTERRUPTION_PHYSICAL     = 2;
  ONBOARDING_INTERRUPTION_POWER_BUTTON = 3;
}
message OnboardingPhysicalInterruption {
  OnboardingPhysicalInterruptions type = 1;
}

message OnboardingSeesCube {
  bool sees_cube = 1;
}

message OnboardingCantFindCube {
}

message OnboardingStateRequest {
}

message OnboardingStateResponse {
  ResponseStatus status = 1;
  OnboardingState onboarding_state = 2;
}

message OnboardingContinue {
  OnboardingSteps step_number = 1;
}

message OnboardingContinueResponse {
  bool accepted = 1;
  OnboardingSteps robot_step_number = 2;
  OnboardingSteps request_step_number = 3;
}

message OnboardingSkip {
}

message OnboardingRetryCharging {
}

message OnboardingSkipOnboarding {
}

message OnboardingRestart {
}

message OnboardingGetStep {
}

message OnboardingStepResponse {
  OnboardingSteps step_number = 1;
}

message OnboardingInputRequest {
  oneof oneof_message_type {
    OnboardingContinue onboarding_continue = 1;
    OnboardingSkip onboarding_skip = 2;
    OnboardingRetryCharging onboarding_retry_charging = 3;
    OnboardingGetStep onboarding_get_step = 4;
    OnboardingSkipOnboarding onboarding_skip_onboarding = 5;
    OnboardingRestart onboarding_restart = 6;
  }
}

message OnboardingInputResponse {
  ResponseStatus status = 1;
  oneof oneof_message_type {
    OnboardingContinueResponse   onboarding_continue_response    = 2;
    OnboardingStepResponse       onboarding_step_response        = 3;
  }
}

message OnboardingRobotExpectingStep {
  OnboardingSteps step_number = 1;
}

message OnboardingHabitatDetected {
}

message WakeWordBegin {
}

message WakeWordEnd {
  bool intent_heard = 1;
  string intent_json = 2; // todo: we send json as a string for now since the engine handling of intents is tightly coupled with clad
}

// Photos

message PhotoInfo {
  uint32 photo_id = 1;
  uint32 timestamp_utc = 2;
  bool photo_copied_to_app = 3;
  bool thumb_copied_to_app = 4;
}

message PhotosInfoRequest {
}

message PhotosInfoResponse {
  ResponseStatus status = 1;
  repeated PhotoInfo photo_infos = 2;
}

message PhotoRequest {
  uint32 photo_id = 1;
}

message PhotoPathMessage {
  bool success = 1;
  string full_path = 2;
}

message PhotoResponse {
  ResponseStatus status = 1;
  bool success = 2;
  bytes image = 3;
}

message ThumbnailRequest {
  uint32 photo_id = 1;
}

message ThumbnailPathMessage {
  bool success = 1;
  string full_path = 2;
}

message ThumbnailResponse {
  ResponseStatus status = 1;
  bool success = 2;
  bytes image = 3;
}

message DeletePhotoRequest {
  uint32 photo_id = 1;
}

message DeletePhotoResponse {
  ResponseStatus status = 1;
  bool success = 2;
}

message PhotoTaken {
  uint32 photo_id = 1;
}

// NOTE: must match attentionTransferTypes.clad
enum AttentionTransferReason {
  Invalid = 0;

  NoCloudConnection = 1;
  NoWifi = 2;
  UnmatchedIntent = 3;
}

message AttentionTransfer {
  AttentionTransferReason reason = 1;
  float seconds_ago = 2;
}

message LatestAttentionTransferRequest {
}

message LatestAttentionTransfer {
  oneof oneof_message_type {
    AttentionTransfer attention_transfer = 1;
  }
}

message LatestAttentionTransferResponse {
  ResponseStatus status = 1;
  LatestAttentionTransfer latest_attention_transfer = 2;
}

// Proto field names are prefixed with "VISION_MODE_"
enum VisionMode {
  VISION_MODE_IDLE = 0;
  VISION_MODE_DETECTING_MARKERS = 1;
  VISION_MODE_DETECTING_FACES = 2;
  VISION_MODE_DETECTING_MOTION = 3;
  VISION_MODE_DETECTING_OVERHEAD_EDGES = 4;
  VISION_MODE_COMPUTING_CALIBRATION = 5;
  VISION_MODE_AUTO_EXPOSURE = 6;
  VISION_MODE_WHITE_BALANCE = 7;
  VISION_MODE_COMPUTING_STATISTICS = 8;
  VISION_MODE_DETECTING_PETS = 9;
  VISION_MODE_ESTIMATING_FACIAL_EXPRESSION = 10;  // No effect if DetectingFaces not enabled
  VISION_MODE_DETECTING_SMILE_AMOUNT = 11;        //  "
  VISION_MODE_DETECTING_GAZE = 12;               //  "
  VISION_MODE_DETECTING_BLINK_AMOUNT = 13;        //  "
  VISION_MODE_LIMITED_EXPOSURE = 14;
  VISION_MODE_DETECTING_LASER_POINTS = 15;
  VISION_MODE_BUILDING_OVERHEAD_MAP = 16;
  VISION_MODE_DETECTING_VISUAL_OBSTACLES = 17;
  VISION_MODE_BENCHMARKING = 18;
  VISION_MODE_SAVING_IMAGES = 19;
  VISION_MODE_RUNNING_NEURAL_NET = 20; 
  VISION_MODE_DETECTING_ILLUMINATION = 21;
  VISION_MODE_COUNT = 22;
}

message EnableVisionModeRequest {
  VisionMode mode = 1;
  bool       enable = 2;
}

message EnableVisionModeResponse {
  ResponseStatus status = 1;
}

// Struct containing all the information relevant to how a 
// path should be modified or traversed.
// TODO: Include path wonkification parameters
message PathMotionProfile {
  float speed_mmps = 1;
  float accel_mmps2 = 2;
  float decel_mmps2 = 3;
  float point_turn_speed_rad_per_sec = 4;
  float point_turn_accel_rad_per_sec2 = 5;
  float point_turn_decel_rad_per_sec2 = 6;
  float dock_speed_mmps = 7;
  float dock_accel_mmps2 = 8;
  float dock_decel_mmps2 = 9;
  float reverse_speed_mmps = 10;
  bool  is_custom = 11;
}

enum ActionResult {
  ACTION_RESULT_SUCCESS                 = 0;
  ACTION_RESULT_RUNNING                 = 16777216;
  ACTION_RESULT_CANCELLED_WHILE_RUNNING = 33554432;
}

// GotoPose
message GoToPoseRequest {
  float x_mm                    = 1;
  float y_mm                    = 2;
  float rad                     = 3;
  PathMotionProfile motion_prof = 4;
}

message GoToPoseResponse {
  ResponseStatus status      = 1;
  ActionResult action_result = 2;
}

// This is a uint8 in CLAD
enum AlignmentType {
  ALIGNMENT_TYPE_UNKNOWN     = 0;
  ALIGNMENT_TYPE_LIFT_FINGER = 1; // Fingers aligned with object
  ALIGNMENT_TYPE_LIFT_PLATE  = 2; // Lift plate aligned with object
  ALIGNMENT_TYPE_BODY        = 3; // Front of body aligned with object
  ALIGNMENT_TYPE_CUSTOM      = 4;
}

message DockWithCubeRequest {
  int32             object_id               = 1;
  float             distance_from_marker_mm = 2;
  float             approach_angle_rad      = 3;
  AlignmentType     alignment_type          = 4;
  bool              use_approach_angle      = 5;
  bool              use_pre_dock_pose       = 6;
  PathMotionProfile motion_prof             = 7;
}

message DockWithCubeResponse {
  ResponseStatus status = 1;
  ActionResult action_result = 2;
}

// @TODO: add num_retries (VIC-5735)
message DriveStraightRequest {
   float speed_mmps = 1;  // Speed should be positive
   float dist_mm = 2;     // Use +ve for forward, -ve for backward
   bool should_play_animation = 3;
}

message DriveStraightResponse {
  ResponseStatus status = 1;
  BehaviorResults result = 2;
}

// TurnInPlace
// If isAbsolute == 0, turns the specified number of radians, *relative to the robot's current heading*
// If isAbsolute != 0, turns to the specified absolute orientation.
message TurnInPlaceRequest {
    float angle_rad = 1; // relative mode: postive turns left negative turns right
    float speed_rad_per_sec = 2;
    float accel_rad_per_sec2 = 3;
    float tol_rad = 4; // This should be no smaller than POINT_TURN_ANGLE_TOL from cozmoEngineConfig.h.
                            // Smaller values are ignored except 0 which is interpreted to mean
                            // default tolerance of POINT_TURN_ANGLE_TOL.
    uint32 is_absolute = 5; // 0: angle_rad is relative to current orientation, 1: angle_rad is absolute angle to turn to
}

message TurnInPlaceResponse {
  ResponseStatus status = 1;
  BehaviorResults result = 2;
}

// SetHeadAngle
message SetHeadAngleRequest {
    float angle_rad = 1;
    float max_speed_rad_per_sec = 2;
    float accel_rad_per_sec2 = 3;
    float duration_sec = 4;
}

message SetHeadAngleResponse {
  ResponseStatus status = 1;
  BehaviorResults result = 2;
}

// SetLiftHeight
message SetLiftHeightRequest {
    float height_mm = 1;
    float max_speed_rad_per_sec = 2;
    float accel_rad_per_sec2 = 3;
    float duration_sec = 4;
}

message SetLiftHeightResponse {
  ResponseStatus status = 1;
  BehaviorResults result = 2;
}

// SetBackpackLights
message SetBackpackLightsRequest {
  repeated uint32  on_color = 1;
  repeated uint32  off_color = 2;
  repeated uint32  on_period_ms = 3;
  repeated uint32  off_period_ms = 4;
  repeated uint32  transition_on_period_ms = 5;
  repeated uint32  transition_off_period_ms = 6;
}

message SetBackpackLightsResponse {
  ResponseStatus status = 1;
}

enum BatteryLevel {
  BATTERY_LEVEL_UNKNOWN = 0;
  BATTERY_LEVEL_LOW     = 1;
  BATTERY_LEVEL_NOMINAL = 2;
  BATTERY_LEVEL_FULL    = 3;
}

message NetworkStats {
  int32 g_net_stat1_num_connections   = 1;
  float g_net_stat2_latency_avg       = 2;
  float g_net_stat3_latency_sd        = 3;
  float g_net_stat4_latency_min       = 4;
  float g_net_stat5_latency_max       = 5;
  float g_net_stat6_ping_arrived_pc   = 6;
  float g_net_stat7_ext_queued_avg_ms = 7;
  float g_net_stat8_ext_queued_min_ms = 8;
  float g_net_stat9_ext_queued_max_ms = 9;
  float g_net_stata_queued_avg_ms     = 10;
  float g_net_statb_queued_min_ms     = 11;
  float g_net_statc_queued_max_ms     = 12;
}

message BatteryStateRequest {}

message BatteryStateResponse {
  ResponseStatus status = 1;
  BatteryLevel battery_level = 2;
  float battery_volts = 3;
  bool is_charging = 4;
  bool is_on_charger_platform = 5;
  float suggested_charger_sec = 6;
  CubeBattery cube_battery = 7;
}

message CubeBattery {
  enum CubeBatteryLevel {
    Low    = 0;
    Normal = 1;
  }
  CubeBatteryLevel level = 1;
  string           factory_id = 2;
  float            battery_volts = 3;
  float            time_since_last_reading_sec = 4;
}

message VersionStateRequest {}

message VersionStateResponse {
  ResponseStatus status = 1;
  string os_version = 2;
  string engine_build_id = 3;
}

message NetworkStateRequest {}

message NetworkStateResponse {
  ResponseStatus status = 1;
  NetworkStats network_stats = 2;
}

message SayTextRequest {
  string text = 1;
  bool use_vector_voice = 2;
  float duration_scalar = 3;
}

message SayTextResponse {
  enum UtteranceState
  {
    INVALID = 0;
    GENERATING = 1;
    READY = 2;
    PLAYING = 3;
    FINISHED = 4;
  }
  ResponseStatus status = 1;
  UtteranceState state = 2;
}

message StimulationInfo {
  repeated string emotion_events  = 1; // may be empty
  float  value                    = 2;
  float  velocity                 = 3; // value per second
  float  accel                    = 4; // value per sec per sec
  float  value_before_event       = 5; // matches value if there were no emotion events
  float  min_value                = 6;
  float  max_value                = 7;
}


// ImageRequest
message ImageRequest {
  enum ImageSendMode {
    OFF                          = 0;
    STREAM                       = 1;
    SINGLE_SHOT                  = 2;
    SINGLE_SHOT_WITH_SENSOR_DATA = 3;
  }
  ImageSendMode mode = 1;
}

message ImageChunk {
  enum ImageEncoding
  {
    NONE_IMAGE_ENCODING = 0;
    RAW_GRAY = 1; // no compression
    RAW_RGB = 2;  // no compression, just [RGBRGBRG...]
    YUYV = 3;
    YUV420SP = 4;
    BAYER = 5;
    JPEG_GRAY = 6;
    JPEG_COLOR = 7;
    JPEG_COLOR_HALF_WIDTH = 8;
    JPEG_MINIMIZED_GRAY = 9; // Minimized grayscale JPEG - no header, no footer, no byte stuffing
    JPEG_MINIMIZED_COLOR = 10; // Minimized grayscale JPEG - no header, no footer, no byte stuffing, with added color data
  }
  uint32        frame_time_stamp = 1;
  uint32        image_id = 2;
  uint32        width = 3;
  uint32        height = 4;
  ImageEncoding image_encoding = 5;
  uint32        display_index = 6;
  uint32        image_chunk_count = 7;
  uint32        chunk_id = 8;
  bytes         data = 9;
}

message CameraFeedRequest {}

message CameraFeedResponse {
  option (streamed) = true;
  ImageChunk image_chunk = 1;
}

// Check to see if an update is available for the robot
message CheckUpdateStatusRequest{}

message CheckUpdateStatusResponse{
  ResponseStatus status = 1;
  enum UpdateStatus {
    NO_UPDATE = 0;
    READY_TO_INSTALL = 1;
  }
  UpdateStatus update_status = 2;
}

// Apply updates to the robot (if available)
message UpdateAndRestartRequest{}

message UpdateAndRestartResponse{
  ResponseStatus status = 1;
}

// Upload debug logs for customer care
message UploadDebugLogsRequest{}

message UploadDebugLogsResponse{
  ResponseStatus status = 1;
  string url = 2;
}

// Verify Vector's connection to the Anki Cloud
message CheckCloudRequest{}

message CheckCloudResponse{
  ResponseStatus status = 1;
  enum ConnectionCode {
    UNKNOWN = 0;
    AVAILABLE = 1;
    BAD_CONNECTIVITY = 2;
    FAILED_TLS = 3;
    FAILED_AUTH = 4;
    INSUFFICIENT_BANDWIDTH = 5;
  }
  ConnectionCode code = 2;
  string status_message = 3;
  int32 num_packets = 4;
  int32 expected_packets = 5;
}
