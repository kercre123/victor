// Autogenerated C++ message buffer code.
// Source: clad/externalInterface/messageExternalComms.clad
// Full command line: victor-clad/tools/message-buffers/emitters/CPP_emitter.py --output-union-helper-constructors -C sdk -I victor-clad/clad/sdk -o generated/clad clad/externalInterface/messageExternalComms.clad

#ifndef __CLAD_EXTERNAL_INTERFACE_MESSAGE_EXTERNAL_COMMS_H__
#define __CLAD_EXTERNAL_INTERFACE_MESSAGE_EXTERNAL_COMMS_H__

#include <CLAD/SafeMessageBuffer.h>
#include <array>
#include <cassert>
#include <cstdint>
#include <string>
#include <vector>

#include "messageExternalCommsTag.h"

namespace Anki {

namespace Victor {

namespace ExternalComms {

// ENUM RtsMode
enum class RtsMode : uint8_t {
  RAW            = 0,
  CLAD           = 1,
  CLAD_ENCRYPTED = 2,
};

const char* EnumToString(const RtsMode m);
inline const char* RtsModeToString(const RtsMode m) { return EnumToString(m); }


extern const char* RtsModeVersionHashStr;
extern const uint8_t RtsModeVersionHash[16];

constexpr uint8_t RtsModeNumEntries = 3;

// ENUM RtsConnType
enum class RtsConnType : uint8_t {
  FirstTimePair = 0,
  Reconnection  = 1,
};

const char* EnumToString(const RtsConnType m);
inline const char* RtsConnTypeToString(const RtsConnType m) { return EnumToString(m); }


extern const char* RtsConnTypeVersionHashStr;
extern const uint8_t RtsConnTypeVersionHash[16];

constexpr uint8_t RtsConnTypeNumEntries = 2;

// MESSAGE RtsWifiScanResult
struct RtsWifiScanResult
{
  uint8_t authType;
  uint8_t signalStrength;
  std::string wifiSsidHex;
  
  /**** Constructors ****/
  RtsWifiScanResult() = default;
  RtsWifiScanResult(const RtsWifiScanResult& other) = default;
  RtsWifiScanResult(RtsWifiScanResult& other) = default;
  RtsWifiScanResult(RtsWifiScanResult&& other) noexcept = default;
  RtsWifiScanResult& operator=(const RtsWifiScanResult& other) = default;
  RtsWifiScanResult& operator=(RtsWifiScanResult&& other) = default;
  
  explicit RtsWifiScanResult(uint8_t authType,
    uint8_t signalStrength,
    const std::string& wifiSsidHex)
  : authType(authType)
  , signalStrength(signalStrength)
  , wifiSsidHex(wifiSsidHex)
  {}
  
  explicit RtsWifiScanResult(const uint8_t* buff, size_t len);
  explicit RtsWifiScanResult(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsWifiScanResult& other) const;
  bool operator!=(const RtsWifiScanResult& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(authType, signalStrength, wifiSsidHex);
  }
};

extern const char* RtsWifiScanResultVersionHashStr;
extern const uint8_t RtsWifiScanResultVersionHash[16];

// MESSAGE RtsConnRequest
struct RtsConnRequest
{
  std::array<uint8_t, 32> publicKey;
  
  /**** Constructors ****/
  RtsConnRequest() = default;
  RtsConnRequest(const RtsConnRequest& other) = default;
  RtsConnRequest(RtsConnRequest& other) = default;
  RtsConnRequest(RtsConnRequest&& other) noexcept = default;
  RtsConnRequest& operator=(const RtsConnRequest& other) = default;
  RtsConnRequest& operator=(RtsConnRequest&& other) = default;
  
  explicit RtsConnRequest(const std::array<uint8_t, 32>& publicKey)
  : publicKey(publicKey)
  {}
  
  explicit RtsConnRequest(const uint8_t* buff, size_t len);
  explicit RtsConnRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsConnRequest& other) const;
  bool operator!=(const RtsConnRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(publicKey);
  }
};

extern const char* RtsConnRequestVersionHashStr;
extern const uint8_t RtsConnRequestVersionHash[16];

// MESSAGE RtsConnResponse
struct RtsConnResponse
{
  Anki::Victor::ExternalComms::RtsConnType connectionType;
  std::array<uint8_t, 32> publicKey;
  
  /**** Constructors ****/
  RtsConnResponse() = default;
  RtsConnResponse(const RtsConnResponse& other) = default;
  RtsConnResponse(RtsConnResponse& other) = default;
  RtsConnResponse(RtsConnResponse&& other) noexcept = default;
  RtsConnResponse& operator=(const RtsConnResponse& other) = default;
  RtsConnResponse& operator=(RtsConnResponse&& other) = default;
  
  explicit RtsConnResponse(Anki::Victor::ExternalComms::RtsConnType connectionType,
    const std::array<uint8_t, 32>& publicKey)
  : connectionType(connectionType)
  , publicKey(publicKey)
  {}
  
  explicit RtsConnResponse(const uint8_t* buff, size_t len);
  explicit RtsConnResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsConnResponse& other) const;
  bool operator!=(const RtsConnResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(connectionType, publicKey);
  }
};

extern const char* RtsConnResponseVersionHashStr;
extern const uint8_t RtsConnResponseVersionHash[16];

// MESSAGE RtsNonceMessage
struct RtsNonceMessage
{
  std::array<uint8_t, 24> toRobotNonce;
  std::array<uint8_t, 24> toDeviceNonce;
  
  /**** Constructors ****/
  RtsNonceMessage() = default;
  RtsNonceMessage(const RtsNonceMessage& other) = default;
  RtsNonceMessage(RtsNonceMessage& other) = default;
  RtsNonceMessage(RtsNonceMessage&& other) noexcept = default;
  RtsNonceMessage& operator=(const RtsNonceMessage& other) = default;
  RtsNonceMessage& operator=(RtsNonceMessage&& other) = default;
  
  explicit RtsNonceMessage(const std::array<uint8_t, 24>& toRobotNonce,
    const std::array<uint8_t, 24>& toDeviceNonce)
  : toRobotNonce(toRobotNonce)
  , toDeviceNonce(toDeviceNonce)
  {}
  
  explicit RtsNonceMessage(const uint8_t* buff, size_t len);
  explicit RtsNonceMessage(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsNonceMessage& other) const;
  bool operator!=(const RtsNonceMessage& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(toRobotNonce, toDeviceNonce);
  }
};

extern const char* RtsNonceMessageVersionHashStr;
extern const uint8_t RtsNonceMessageVersionHash[16];

// MESSAGE RtsAck
struct RtsAck
{
  uint8_t rtsConnectionTag;
  
  /**** Constructors ****/
  RtsAck() = default;
  RtsAck(const RtsAck& other) = default;
  RtsAck(RtsAck& other) = default;
  RtsAck(RtsAck&& other) noexcept = default;
  RtsAck& operator=(const RtsAck& other) = default;
  RtsAck& operator=(RtsAck&& other) = default;
  
  explicit RtsAck(uint8_t rtsConnectionTag)
  : rtsConnectionTag(rtsConnectionTag)
  {}
  
  explicit RtsAck(const uint8_t* buff, size_t len);
  explicit RtsAck(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsAck& other) const;
  bool operator!=(const RtsAck& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(rtsConnectionTag);
  }
};

extern const char* RtsAckVersionHashStr;
extern const uint8_t RtsAckVersionHash[16];

// MESSAGE RtsChallengeMessage
struct RtsChallengeMessage
{
  uint32_t number;
  
  /**** Constructors ****/
  RtsChallengeMessage() = default;
  RtsChallengeMessage(const RtsChallengeMessage& other) = default;
  RtsChallengeMessage(RtsChallengeMessage& other) = default;
  RtsChallengeMessage(RtsChallengeMessage&& other) noexcept = default;
  RtsChallengeMessage& operator=(const RtsChallengeMessage& other) = default;
  RtsChallengeMessage& operator=(RtsChallengeMessage&& other) = default;
  
  explicit RtsChallengeMessage(uint32_t number)
  : number(number)
  {}
  
  explicit RtsChallengeMessage(const uint8_t* buff, size_t len);
  explicit RtsChallengeMessage(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsChallengeMessage& other) const;
  bool operator!=(const RtsChallengeMessage& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(number);
  }
};

extern const char* RtsChallengeMessageVersionHashStr;
extern const uint8_t RtsChallengeMessageVersionHash[16];

// MESSAGE RtsChallengeSuccessMessage
struct RtsChallengeSuccessMessage
{
  
  /**** Constructors ****/
  RtsChallengeSuccessMessage() = default;
  RtsChallengeSuccessMessage(const RtsChallengeSuccessMessage& other) = default;
  RtsChallengeSuccessMessage(RtsChallengeSuccessMessage& other) = default;
  RtsChallengeSuccessMessage(RtsChallengeSuccessMessage&& other) noexcept = default;
  RtsChallengeSuccessMessage& operator=(const RtsChallengeSuccessMessage& other) = default;
  RtsChallengeSuccessMessage& operator=(RtsChallengeSuccessMessage&& other) = default;
  
  explicit RtsChallengeSuccessMessage(const uint8_t* buff, size_t len);
  explicit RtsChallengeSuccessMessage(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsChallengeSuccessMessage& other) const;
  bool operator!=(const RtsChallengeSuccessMessage& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* RtsChallengeSuccessMessageVersionHashStr;
extern const uint8_t RtsChallengeSuccessMessageVersionHash[16];

// MESSAGE RtsWifiConnectRequest
struct RtsWifiConnectRequest
{
  std::string wifiSsidHex;
  std::string password;
  uint8_t timeout;
  uint8_t authType;
  bool hidden;
  
  /**** Constructors ****/
  RtsWifiConnectRequest() = default;
  RtsWifiConnectRequest(const RtsWifiConnectRequest& other) = default;
  RtsWifiConnectRequest(RtsWifiConnectRequest& other) = default;
  RtsWifiConnectRequest(RtsWifiConnectRequest&& other) noexcept = default;
  RtsWifiConnectRequest& operator=(const RtsWifiConnectRequest& other) = default;
  RtsWifiConnectRequest& operator=(RtsWifiConnectRequest&& other) = default;
  
  explicit RtsWifiConnectRequest(const std::string& wifiSsidHex,
    const std::string& password,
    uint8_t timeout,
    uint8_t authType,
    bool hidden)
  : wifiSsidHex(wifiSsidHex)
  , password(password)
  , timeout(timeout)
  , authType(authType)
  , hidden(hidden)
  {}
  
  explicit RtsWifiConnectRequest(const uint8_t* buff, size_t len);
  explicit RtsWifiConnectRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsWifiConnectRequest& other) const;
  bool operator!=(const RtsWifiConnectRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(wifiSsidHex, password, timeout, authType, hidden);
  }
};

extern const char* RtsWifiConnectRequestVersionHashStr;
extern const uint8_t RtsWifiConnectRequestVersionHash[16];

// MESSAGE RtsWifiConnectResponse
struct RtsWifiConnectResponse
{
  std::string wifiSsidHex;
  uint8_t wifiState;
  
  /**** Constructors ****/
  RtsWifiConnectResponse() = default;
  RtsWifiConnectResponse(const RtsWifiConnectResponse& other) = default;
  RtsWifiConnectResponse(RtsWifiConnectResponse& other) = default;
  RtsWifiConnectResponse(RtsWifiConnectResponse&& other) noexcept = default;
  RtsWifiConnectResponse& operator=(const RtsWifiConnectResponse& other) = default;
  RtsWifiConnectResponse& operator=(RtsWifiConnectResponse&& other) = default;
  
  explicit RtsWifiConnectResponse(const std::string& wifiSsidHex,
    uint8_t wifiState)
  : wifiSsidHex(wifiSsidHex)
  , wifiState(wifiState)
  {}
  
  explicit RtsWifiConnectResponse(const uint8_t* buff, size_t len);
  explicit RtsWifiConnectResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsWifiConnectResponse& other) const;
  bool operator!=(const RtsWifiConnectResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(wifiSsidHex, wifiState);
  }
};

extern const char* RtsWifiConnectResponseVersionHashStr;
extern const uint8_t RtsWifiConnectResponseVersionHash[16];

// MESSAGE RtsWifiIpRequest
struct RtsWifiIpRequest
{
  
  /**** Constructors ****/
  RtsWifiIpRequest() = default;
  RtsWifiIpRequest(const RtsWifiIpRequest& other) = default;
  RtsWifiIpRequest(RtsWifiIpRequest& other) = default;
  RtsWifiIpRequest(RtsWifiIpRequest&& other) noexcept = default;
  RtsWifiIpRequest& operator=(const RtsWifiIpRequest& other) = default;
  RtsWifiIpRequest& operator=(RtsWifiIpRequest&& other) = default;
  
  explicit RtsWifiIpRequest(const uint8_t* buff, size_t len);
  explicit RtsWifiIpRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsWifiIpRequest& other) const;
  bool operator!=(const RtsWifiIpRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* RtsWifiIpRequestVersionHashStr;
extern const uint8_t RtsWifiIpRequestVersionHash[16];

// MESSAGE RtsWifiIpResponse
struct RtsWifiIpResponse
{
  uint8_t hasIpV4;
  uint8_t hasIpV6;
  std::array<uint8_t, 4> ipV4;
  std::array<uint8_t, 16> ipV6;
  
  /**** Constructors ****/
  RtsWifiIpResponse() = default;
  RtsWifiIpResponse(const RtsWifiIpResponse& other) = default;
  RtsWifiIpResponse(RtsWifiIpResponse& other) = default;
  RtsWifiIpResponse(RtsWifiIpResponse&& other) noexcept = default;
  RtsWifiIpResponse& operator=(const RtsWifiIpResponse& other) = default;
  RtsWifiIpResponse& operator=(RtsWifiIpResponse&& other) = default;
  
  explicit RtsWifiIpResponse(uint8_t hasIpV4,
    uint8_t hasIpV6,
    const std::array<uint8_t, 4>& ipV4,
    const std::array<uint8_t, 16>& ipV6)
  : hasIpV4(hasIpV4)
  , hasIpV6(hasIpV6)
  , ipV4(ipV4)
  , ipV6(ipV6)
  {}
  
  explicit RtsWifiIpResponse(const uint8_t* buff, size_t len);
  explicit RtsWifiIpResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsWifiIpResponse& other) const;
  bool operator!=(const RtsWifiIpResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(hasIpV4, hasIpV6, ipV4, ipV6);
  }
};

extern const char* RtsWifiIpResponseVersionHashStr;
extern const uint8_t RtsWifiIpResponseVersionHash[16];

// MESSAGE RtsStatusRequest
struct RtsStatusRequest
{
  
  /**** Constructors ****/
  RtsStatusRequest() = default;
  RtsStatusRequest(const RtsStatusRequest& other) = default;
  RtsStatusRequest(RtsStatusRequest& other) = default;
  RtsStatusRequest(RtsStatusRequest&& other) noexcept = default;
  RtsStatusRequest& operator=(const RtsStatusRequest& other) = default;
  RtsStatusRequest& operator=(RtsStatusRequest&& other) = default;
  
  explicit RtsStatusRequest(const uint8_t* buff, size_t len);
  explicit RtsStatusRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsStatusRequest& other) const;
  bool operator!=(const RtsStatusRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* RtsStatusRequestVersionHashStr;
extern const uint8_t RtsStatusRequestVersionHash[16];

// MESSAGE RtsStatusResponse
struct RtsStatusResponse
{
  std::string wifiSsidHex;
  uint8_t wifiState;
  bool accessPoint;
  uint8_t bleState;
  uint8_t batteryState;
  
  /**** Constructors ****/
  RtsStatusResponse() = default;
  RtsStatusResponse(const RtsStatusResponse& other) = default;
  RtsStatusResponse(RtsStatusResponse& other) = default;
  RtsStatusResponse(RtsStatusResponse&& other) noexcept = default;
  RtsStatusResponse& operator=(const RtsStatusResponse& other) = default;
  RtsStatusResponse& operator=(RtsStatusResponse&& other) = default;
  
  explicit RtsStatusResponse(const std::string& wifiSsidHex,
    uint8_t wifiState,
    bool accessPoint,
    uint8_t bleState,
    uint8_t batteryState)
  : wifiSsidHex(wifiSsidHex)
  , wifiState(wifiState)
  , accessPoint(accessPoint)
  , bleState(bleState)
  , batteryState(batteryState)
  {}
  
  explicit RtsStatusResponse(const uint8_t* buff, size_t len);
  explicit RtsStatusResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsStatusResponse& other) const;
  bool operator!=(const RtsStatusResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(wifiSsidHex, wifiState, accessPoint, bleState, batteryState);
  }
};

extern const char* RtsStatusResponseVersionHashStr;
extern const uint8_t RtsStatusResponseVersionHash[16];

// MESSAGE RtsWifiScanRequest
struct RtsWifiScanRequest
{
  
  /**** Constructors ****/
  RtsWifiScanRequest() = default;
  RtsWifiScanRequest(const RtsWifiScanRequest& other) = default;
  RtsWifiScanRequest(RtsWifiScanRequest& other) = default;
  RtsWifiScanRequest(RtsWifiScanRequest&& other) noexcept = default;
  RtsWifiScanRequest& operator=(const RtsWifiScanRequest& other) = default;
  RtsWifiScanRequest& operator=(RtsWifiScanRequest&& other) = default;
  
  explicit RtsWifiScanRequest(const uint8_t* buff, size_t len);
  explicit RtsWifiScanRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsWifiScanRequest& other) const;
  bool operator!=(const RtsWifiScanRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* RtsWifiScanRequestVersionHashStr;
extern const uint8_t RtsWifiScanRequestVersionHash[16];

// MESSAGE RtsWifiScanResponse
struct RtsWifiScanResponse
{
  uint8_t statusCode;
  std::vector<Anki::Victor::ExternalComms::RtsWifiScanResult> scanResult;
  
  /**** Constructors ****/
  RtsWifiScanResponse() = default;
  RtsWifiScanResponse(const RtsWifiScanResponse& other) = default;
  RtsWifiScanResponse(RtsWifiScanResponse& other) = default;
  RtsWifiScanResponse(RtsWifiScanResponse&& other) noexcept = default;
  RtsWifiScanResponse& operator=(const RtsWifiScanResponse& other) = default;
  RtsWifiScanResponse& operator=(RtsWifiScanResponse&& other) = default;
  
  explicit RtsWifiScanResponse(uint8_t statusCode,
    const std::vector<Anki::Victor::ExternalComms::RtsWifiScanResult>& scanResult)
  : statusCode(statusCode)
  , scanResult(scanResult)
  {}
  
  explicit RtsWifiScanResponse(const uint8_t* buff, size_t len);
  explicit RtsWifiScanResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsWifiScanResponse& other) const;
  bool operator!=(const RtsWifiScanResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(statusCode, scanResult);
  }
};

extern const char* RtsWifiScanResponseVersionHashStr;
extern const uint8_t RtsWifiScanResponseVersionHash[16];

// MESSAGE RtsOtaUpdateRequest
struct RtsOtaUpdateRequest
{
  std::string url;
  
  /**** Constructors ****/
  RtsOtaUpdateRequest() = default;
  RtsOtaUpdateRequest(const RtsOtaUpdateRequest& other) = default;
  RtsOtaUpdateRequest(RtsOtaUpdateRequest& other) = default;
  RtsOtaUpdateRequest(RtsOtaUpdateRequest&& other) noexcept = default;
  RtsOtaUpdateRequest& operator=(const RtsOtaUpdateRequest& other) = default;
  RtsOtaUpdateRequest& operator=(RtsOtaUpdateRequest&& other) = default;
  
  explicit RtsOtaUpdateRequest(const std::string& url)
  : url(url)
  {}
  
  explicit RtsOtaUpdateRequest(const uint8_t* buff, size_t len);
  explicit RtsOtaUpdateRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsOtaUpdateRequest& other) const;
  bool operator!=(const RtsOtaUpdateRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(url);
  }
};

extern const char* RtsOtaUpdateRequestVersionHashStr;
extern const uint8_t RtsOtaUpdateRequestVersionHash[16];

// MESSAGE RtsOtaUpdateResponse
struct RtsOtaUpdateResponse
{
  uint8_t status;
  uint64_t current;
  uint64_t expected;
  
  /**** Constructors ****/
  RtsOtaUpdateResponse() = default;
  RtsOtaUpdateResponse(const RtsOtaUpdateResponse& other) = default;
  RtsOtaUpdateResponse(RtsOtaUpdateResponse& other) = default;
  RtsOtaUpdateResponse(RtsOtaUpdateResponse&& other) noexcept = default;
  RtsOtaUpdateResponse& operator=(const RtsOtaUpdateResponse& other) = default;
  RtsOtaUpdateResponse& operator=(RtsOtaUpdateResponse&& other) = default;
  
  explicit RtsOtaUpdateResponse(uint8_t status,
    uint64_t current,
    uint64_t expected)
  : status(status)
  , current(current)
  , expected(expected)
  {}
  
  explicit RtsOtaUpdateResponse(const uint8_t* buff, size_t len);
  explicit RtsOtaUpdateResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsOtaUpdateResponse& other) const;
  bool operator!=(const RtsOtaUpdateResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(status, current, expected);
  }
};

extern const char* RtsOtaUpdateResponseVersionHashStr;
extern const uint8_t RtsOtaUpdateResponseVersionHash[16];

// MESSAGE RtsWifiAccessPointRequest
struct RtsWifiAccessPointRequest
{
  bool enable;
  
  /**** Constructors ****/
  RtsWifiAccessPointRequest() = default;
  RtsWifiAccessPointRequest(const RtsWifiAccessPointRequest& other) = default;
  RtsWifiAccessPointRequest(RtsWifiAccessPointRequest& other) = default;
  RtsWifiAccessPointRequest(RtsWifiAccessPointRequest&& other) noexcept = default;
  RtsWifiAccessPointRequest& operator=(const RtsWifiAccessPointRequest& other) = default;
  RtsWifiAccessPointRequest& operator=(RtsWifiAccessPointRequest&& other) = default;
  
  explicit RtsWifiAccessPointRequest(bool enable)
  : enable(enable)
  {}
  
  explicit RtsWifiAccessPointRequest(const uint8_t* buff, size_t len);
  explicit RtsWifiAccessPointRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsWifiAccessPointRequest& other) const;
  bool operator!=(const RtsWifiAccessPointRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(enable);
  }
};

extern const char* RtsWifiAccessPointRequestVersionHashStr;
extern const uint8_t RtsWifiAccessPointRequestVersionHash[16];

// MESSAGE RtsWifiAccessPointResponse
struct RtsWifiAccessPointResponse
{
  bool enabled;
  std::string ssid;
  std::string password;
  
  /**** Constructors ****/
  RtsWifiAccessPointResponse() = default;
  RtsWifiAccessPointResponse(const RtsWifiAccessPointResponse& other) = default;
  RtsWifiAccessPointResponse(RtsWifiAccessPointResponse& other) = default;
  RtsWifiAccessPointResponse(RtsWifiAccessPointResponse&& other) noexcept = default;
  RtsWifiAccessPointResponse& operator=(const RtsWifiAccessPointResponse& other) = default;
  RtsWifiAccessPointResponse& operator=(RtsWifiAccessPointResponse&& other) = default;
  
  explicit RtsWifiAccessPointResponse(bool enabled,
    const std::string& ssid,
    const std::string& password)
  : enabled(enabled)
  , ssid(ssid)
  , password(password)
  {}
  
  explicit RtsWifiAccessPointResponse(const uint8_t* buff, size_t len);
  explicit RtsWifiAccessPointResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsWifiAccessPointResponse& other) const;
  bool operator!=(const RtsWifiAccessPointResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(enabled, ssid, password);
  }
};

extern const char* RtsWifiAccessPointResponseVersionHashStr;
extern const uint8_t RtsWifiAccessPointResponseVersionHash[16];

// MESSAGE RtsCancelPairing
struct RtsCancelPairing
{
  
  /**** Constructors ****/
  RtsCancelPairing() = default;
  RtsCancelPairing(const RtsCancelPairing& other) = default;
  RtsCancelPairing(RtsCancelPairing& other) = default;
  RtsCancelPairing(RtsCancelPairing&& other) noexcept = default;
  RtsCancelPairing& operator=(const RtsCancelPairing& other) = default;
  RtsCancelPairing& operator=(RtsCancelPairing&& other) = default;
  
  explicit RtsCancelPairing(const uint8_t* buff, size_t len);
  explicit RtsCancelPairing(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsCancelPairing& other) const;
  bool operator!=(const RtsCancelPairing& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* RtsCancelPairingVersionHashStr;
extern const uint8_t RtsCancelPairingVersionHash[16];

// MESSAGE RtsForceDisconnect
struct RtsForceDisconnect
{
  
  /**** Constructors ****/
  RtsForceDisconnect() = default;
  RtsForceDisconnect(const RtsForceDisconnect& other) = default;
  RtsForceDisconnect(RtsForceDisconnect& other) = default;
  RtsForceDisconnect(RtsForceDisconnect&& other) noexcept = default;
  RtsForceDisconnect& operator=(const RtsForceDisconnect& other) = default;
  RtsForceDisconnect& operator=(RtsForceDisconnect&& other) = default;
  
  explicit RtsForceDisconnect(const uint8_t* buff, size_t len);
  explicit RtsForceDisconnect(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsForceDisconnect& other) const;
  bool operator!=(const RtsForceDisconnect& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* RtsForceDisconnectVersionHashStr;
extern const uint8_t RtsForceDisconnectVersionHash[16];

// MESSAGE RtsSshRequest
struct RtsSshRequest
{
  std::vector<std::string> sshAuthorizedKeyBytes;
  
  /**** Constructors ****/
  RtsSshRequest() = default;
  RtsSshRequest(const RtsSshRequest& other) = default;
  RtsSshRequest(RtsSshRequest& other) = default;
  RtsSshRequest(RtsSshRequest&& other) noexcept = default;
  RtsSshRequest& operator=(const RtsSshRequest& other) = default;
  RtsSshRequest& operator=(RtsSshRequest&& other) = default;
  
  explicit RtsSshRequest(const std::vector<std::string>& sshAuthorizedKeyBytes)
  : sshAuthorizedKeyBytes(sshAuthorizedKeyBytes)
  {}
  
  explicit RtsSshRequest(const uint8_t* buff, size_t len);
  explicit RtsSshRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsSshRequest& other) const;
  bool operator!=(const RtsSshRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(sshAuthorizedKeyBytes);
  }
};

extern const char* RtsSshRequestVersionHashStr;
extern const uint8_t RtsSshRequestVersionHash[16];

// MESSAGE RtsSshResponse
struct RtsSshResponse
{
  
  /**** Constructors ****/
  RtsSshResponse() = default;
  RtsSshResponse(const RtsSshResponse& other) = default;
  RtsSshResponse(RtsSshResponse& other) = default;
  RtsSshResponse(RtsSshResponse&& other) noexcept = default;
  RtsSshResponse& operator=(const RtsSshResponse& other) = default;
  RtsSshResponse& operator=(RtsSshResponse&& other) = default;
  
  explicit RtsSshResponse(const uint8_t* buff, size_t len);
  explicit RtsSshResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RtsSshResponse& other) const;
  bool operator!=(const RtsSshResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* RtsSshResponseVersionHashStr;
extern const uint8_t RtsSshResponseVersionHash[16];

// MESSAGE Error
struct Error
{
  
  /**** Constructors ****/
  Error() = default;
  Error(const Error& other) = default;
  Error(Error& other) = default;
  Error(Error&& other) noexcept = default;
  Error& operator=(const Error& other) = default;
  Error& operator=(Error&& other) = default;
  
  explicit Error(const uint8_t* buff, size_t len);
  explicit Error(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const Error& other) const;
  bool operator!=(const Error& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* ErrorVersionHashStr;
extern const uint8_t ErrorVersionHash[16];

// "Lookup Tables" for getting type by tag using template specializations
template<RtsConnectionTag tag>
struct RtsConnection_TagToType;

template<>
struct RtsConnection_TagToType<RtsConnectionTag::Error> {
  using type = Anki::Victor::ExternalComms::Error;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsConnRequest> {
  using type = Anki::Victor::ExternalComms::RtsConnRequest;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsConnResponse> {
  using type = Anki::Victor::ExternalComms::RtsConnResponse;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsNonceMessage> {
  using type = Anki::Victor::ExternalComms::RtsNonceMessage;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsChallengeMessage> {
  using type = Anki::Victor::ExternalComms::RtsChallengeMessage;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsChallengeSuccessMessage> {
  using type = Anki::Victor::ExternalComms::RtsChallengeSuccessMessage;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsWifiConnectRequest> {
  using type = Anki::Victor::ExternalComms::RtsWifiConnectRequest;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsWifiConnectResponse> {
  using type = Anki::Victor::ExternalComms::RtsWifiConnectResponse;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsWifiIpRequest> {
  using type = Anki::Victor::ExternalComms::RtsWifiIpRequest;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsWifiIpResponse> {
  using type = Anki::Victor::ExternalComms::RtsWifiIpResponse;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsStatusRequest> {
  using type = Anki::Victor::ExternalComms::RtsStatusRequest;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsStatusResponse> {
  using type = Anki::Victor::ExternalComms::RtsStatusResponse;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsWifiScanRequest> {
  using type = Anki::Victor::ExternalComms::RtsWifiScanRequest;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsWifiScanResponse> {
  using type = Anki::Victor::ExternalComms::RtsWifiScanResponse;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsOtaUpdateRequest> {
  using type = Anki::Victor::ExternalComms::RtsOtaUpdateRequest;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsOtaUpdateResponse> {
  using type = Anki::Victor::ExternalComms::RtsOtaUpdateResponse;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsCancelPairing> {
  using type = Anki::Victor::ExternalComms::RtsCancelPairing;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsForceDisconnect> {
  using type = Anki::Victor::ExternalComms::RtsForceDisconnect;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsAck> {
  using type = Anki::Victor::ExternalComms::RtsAck;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsWifiAccessPointRequest> {
  using type = Anki::Victor::ExternalComms::RtsWifiAccessPointRequest;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsWifiAccessPointResponse> {
  using type = Anki::Victor::ExternalComms::RtsWifiAccessPointResponse;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsSshRequest> {
  using type = Anki::Victor::ExternalComms::RtsSshRequest;
};
template<>
struct RtsConnection_TagToType<RtsConnectionTag::RtsSshResponse> {
  using type = Anki::Victor::ExternalComms::RtsSshResponse;
};

// UNION RtsConnection
class RtsConnection
{
public:
  using Tag = RtsConnectionTag;
  /**** Constructors ****/
  RtsConnection() :_tag(Tag::INVALID) { }
  explicit RtsConnection(const CLAD::SafeMessageBuffer& buff);
  explicit RtsConnection(const uint8_t* buffer, size_t length);
  RtsConnection(const RtsConnection& other);
  RtsConnection(RtsConnection&& other) noexcept;
  RtsConnection& operator=(const RtsConnection& other);
  RtsConnection& operator=(RtsConnection&& other) noexcept;
  
  ~RtsConnection() { ClearCurrent(); }
  Tag GetTag() const { return _tag; }
  
  // Templated getter for union members by type
  // NOTE: Always returns a reference, even for trivial types, unlike untemplated version
  template<Tag tag>
  const typename RtsConnection_TagToType<tag>::type & Get_() const;
  
  // Templated creator for making a union object out of one if its members
  template <Tag tag>
  static RtsConnection Create_(typename RtsConnection_TagToType<tag>::type member);
  
  /** Error **/
  static RtsConnection CreateError(Anki::Victor::ExternalComms::Error&& new_Error);
  explicit RtsConnection(Anki::Victor::ExternalComms::Error&& new_Error);
  const Anki::Victor::ExternalComms::Error& Get_Error() const;
  void Set_Error(const Anki::Victor::ExternalComms::Error& new_Error);
  void Set_Error(Anki::Victor::ExternalComms::Error&& new_Error);
  
  /** RtsConnRequest **/
  static RtsConnection CreateRtsConnRequest(Anki::Victor::ExternalComms::RtsConnRequest&& new_RtsConnRequest);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsConnRequest&& new_RtsConnRequest);
  const Anki::Victor::ExternalComms::RtsConnRequest& Get_RtsConnRequest() const;
  void Set_RtsConnRequest(const Anki::Victor::ExternalComms::RtsConnRequest& new_RtsConnRequest);
  void Set_RtsConnRequest(Anki::Victor::ExternalComms::RtsConnRequest&& new_RtsConnRequest);
  
  /** RtsConnResponse **/
  static RtsConnection CreateRtsConnResponse(Anki::Victor::ExternalComms::RtsConnResponse&& new_RtsConnResponse);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsConnResponse&& new_RtsConnResponse);
  const Anki::Victor::ExternalComms::RtsConnResponse& Get_RtsConnResponse() const;
  void Set_RtsConnResponse(const Anki::Victor::ExternalComms::RtsConnResponse& new_RtsConnResponse);
  void Set_RtsConnResponse(Anki::Victor::ExternalComms::RtsConnResponse&& new_RtsConnResponse);
  
  /** RtsNonceMessage **/
  static RtsConnection CreateRtsNonceMessage(Anki::Victor::ExternalComms::RtsNonceMessage&& new_RtsNonceMessage);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsNonceMessage&& new_RtsNonceMessage);
  const Anki::Victor::ExternalComms::RtsNonceMessage& Get_RtsNonceMessage() const;
  void Set_RtsNonceMessage(const Anki::Victor::ExternalComms::RtsNonceMessage& new_RtsNonceMessage);
  void Set_RtsNonceMessage(Anki::Victor::ExternalComms::RtsNonceMessage&& new_RtsNonceMessage);
  
  /** RtsChallengeMessage **/
  static RtsConnection CreateRtsChallengeMessage(Anki::Victor::ExternalComms::RtsChallengeMessage&& new_RtsChallengeMessage);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsChallengeMessage&& new_RtsChallengeMessage);
  const Anki::Victor::ExternalComms::RtsChallengeMessage& Get_RtsChallengeMessage() const;
  void Set_RtsChallengeMessage(const Anki::Victor::ExternalComms::RtsChallengeMessage& new_RtsChallengeMessage);
  void Set_RtsChallengeMessage(Anki::Victor::ExternalComms::RtsChallengeMessage&& new_RtsChallengeMessage);
  
  /** RtsChallengeSuccessMessage **/
  static RtsConnection CreateRtsChallengeSuccessMessage(Anki::Victor::ExternalComms::RtsChallengeSuccessMessage&& new_RtsChallengeSuccessMessage);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsChallengeSuccessMessage&& new_RtsChallengeSuccessMessage);
  const Anki::Victor::ExternalComms::RtsChallengeSuccessMessage& Get_RtsChallengeSuccessMessage() const;
  void Set_RtsChallengeSuccessMessage(const Anki::Victor::ExternalComms::RtsChallengeSuccessMessage& new_RtsChallengeSuccessMessage);
  void Set_RtsChallengeSuccessMessage(Anki::Victor::ExternalComms::RtsChallengeSuccessMessage&& new_RtsChallengeSuccessMessage);
  
  /** RtsWifiConnectRequest **/
  static RtsConnection CreateRtsWifiConnectRequest(Anki::Victor::ExternalComms::RtsWifiConnectRequest&& new_RtsWifiConnectRequest);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsWifiConnectRequest&& new_RtsWifiConnectRequest);
  const Anki::Victor::ExternalComms::RtsWifiConnectRequest& Get_RtsWifiConnectRequest() const;
  void Set_RtsWifiConnectRequest(const Anki::Victor::ExternalComms::RtsWifiConnectRequest& new_RtsWifiConnectRequest);
  void Set_RtsWifiConnectRequest(Anki::Victor::ExternalComms::RtsWifiConnectRequest&& new_RtsWifiConnectRequest);
  
  /** RtsWifiConnectResponse **/
  static RtsConnection CreateRtsWifiConnectResponse(Anki::Victor::ExternalComms::RtsWifiConnectResponse&& new_RtsWifiConnectResponse);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsWifiConnectResponse&& new_RtsWifiConnectResponse);
  const Anki::Victor::ExternalComms::RtsWifiConnectResponse& Get_RtsWifiConnectResponse() const;
  void Set_RtsWifiConnectResponse(const Anki::Victor::ExternalComms::RtsWifiConnectResponse& new_RtsWifiConnectResponse);
  void Set_RtsWifiConnectResponse(Anki::Victor::ExternalComms::RtsWifiConnectResponse&& new_RtsWifiConnectResponse);
  
  /** RtsWifiIpRequest **/
  static RtsConnection CreateRtsWifiIpRequest(Anki::Victor::ExternalComms::RtsWifiIpRequest&& new_RtsWifiIpRequest);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsWifiIpRequest&& new_RtsWifiIpRequest);
  const Anki::Victor::ExternalComms::RtsWifiIpRequest& Get_RtsWifiIpRequest() const;
  void Set_RtsWifiIpRequest(const Anki::Victor::ExternalComms::RtsWifiIpRequest& new_RtsWifiIpRequest);
  void Set_RtsWifiIpRequest(Anki::Victor::ExternalComms::RtsWifiIpRequest&& new_RtsWifiIpRequest);
  
  /** RtsWifiIpResponse **/
  static RtsConnection CreateRtsWifiIpResponse(Anki::Victor::ExternalComms::RtsWifiIpResponse&& new_RtsWifiIpResponse);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsWifiIpResponse&& new_RtsWifiIpResponse);
  const Anki::Victor::ExternalComms::RtsWifiIpResponse& Get_RtsWifiIpResponse() const;
  void Set_RtsWifiIpResponse(const Anki::Victor::ExternalComms::RtsWifiIpResponse& new_RtsWifiIpResponse);
  void Set_RtsWifiIpResponse(Anki::Victor::ExternalComms::RtsWifiIpResponse&& new_RtsWifiIpResponse);
  
  /** RtsStatusRequest **/
  static RtsConnection CreateRtsStatusRequest(Anki::Victor::ExternalComms::RtsStatusRequest&& new_RtsStatusRequest);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsStatusRequest&& new_RtsStatusRequest);
  const Anki::Victor::ExternalComms::RtsStatusRequest& Get_RtsStatusRequest() const;
  void Set_RtsStatusRequest(const Anki::Victor::ExternalComms::RtsStatusRequest& new_RtsStatusRequest);
  void Set_RtsStatusRequest(Anki::Victor::ExternalComms::RtsStatusRequest&& new_RtsStatusRequest);
  
  /** RtsStatusResponse **/
  static RtsConnection CreateRtsStatusResponse(Anki::Victor::ExternalComms::RtsStatusResponse&& new_RtsStatusResponse);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsStatusResponse&& new_RtsStatusResponse);
  const Anki::Victor::ExternalComms::RtsStatusResponse& Get_RtsStatusResponse() const;
  void Set_RtsStatusResponse(const Anki::Victor::ExternalComms::RtsStatusResponse& new_RtsStatusResponse);
  void Set_RtsStatusResponse(Anki::Victor::ExternalComms::RtsStatusResponse&& new_RtsStatusResponse);
  
  /** RtsWifiScanRequest **/
  static RtsConnection CreateRtsWifiScanRequest(Anki::Victor::ExternalComms::RtsWifiScanRequest&& new_RtsWifiScanRequest);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsWifiScanRequest&& new_RtsWifiScanRequest);
  const Anki::Victor::ExternalComms::RtsWifiScanRequest& Get_RtsWifiScanRequest() const;
  void Set_RtsWifiScanRequest(const Anki::Victor::ExternalComms::RtsWifiScanRequest& new_RtsWifiScanRequest);
  void Set_RtsWifiScanRequest(Anki::Victor::ExternalComms::RtsWifiScanRequest&& new_RtsWifiScanRequest);
  
  /** RtsWifiScanResponse **/
  static RtsConnection CreateRtsWifiScanResponse(Anki::Victor::ExternalComms::RtsWifiScanResponse&& new_RtsWifiScanResponse);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsWifiScanResponse&& new_RtsWifiScanResponse);
  const Anki::Victor::ExternalComms::RtsWifiScanResponse& Get_RtsWifiScanResponse() const;
  void Set_RtsWifiScanResponse(const Anki::Victor::ExternalComms::RtsWifiScanResponse& new_RtsWifiScanResponse);
  void Set_RtsWifiScanResponse(Anki::Victor::ExternalComms::RtsWifiScanResponse&& new_RtsWifiScanResponse);
  
  /** RtsOtaUpdateRequest **/
  static RtsConnection CreateRtsOtaUpdateRequest(Anki::Victor::ExternalComms::RtsOtaUpdateRequest&& new_RtsOtaUpdateRequest);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsOtaUpdateRequest&& new_RtsOtaUpdateRequest);
  const Anki::Victor::ExternalComms::RtsOtaUpdateRequest& Get_RtsOtaUpdateRequest() const;
  void Set_RtsOtaUpdateRequest(const Anki::Victor::ExternalComms::RtsOtaUpdateRequest& new_RtsOtaUpdateRequest);
  void Set_RtsOtaUpdateRequest(Anki::Victor::ExternalComms::RtsOtaUpdateRequest&& new_RtsOtaUpdateRequest);
  
  /** RtsOtaUpdateResponse **/
  static RtsConnection CreateRtsOtaUpdateResponse(Anki::Victor::ExternalComms::RtsOtaUpdateResponse&& new_RtsOtaUpdateResponse);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsOtaUpdateResponse&& new_RtsOtaUpdateResponse);
  const Anki::Victor::ExternalComms::RtsOtaUpdateResponse& Get_RtsOtaUpdateResponse() const;
  void Set_RtsOtaUpdateResponse(const Anki::Victor::ExternalComms::RtsOtaUpdateResponse& new_RtsOtaUpdateResponse);
  void Set_RtsOtaUpdateResponse(Anki::Victor::ExternalComms::RtsOtaUpdateResponse&& new_RtsOtaUpdateResponse);
  
  /** RtsCancelPairing **/
  static RtsConnection CreateRtsCancelPairing(Anki::Victor::ExternalComms::RtsCancelPairing&& new_RtsCancelPairing);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsCancelPairing&& new_RtsCancelPairing);
  const Anki::Victor::ExternalComms::RtsCancelPairing& Get_RtsCancelPairing() const;
  void Set_RtsCancelPairing(const Anki::Victor::ExternalComms::RtsCancelPairing& new_RtsCancelPairing);
  void Set_RtsCancelPairing(Anki::Victor::ExternalComms::RtsCancelPairing&& new_RtsCancelPairing);
  
  /** RtsForceDisconnect **/
  static RtsConnection CreateRtsForceDisconnect(Anki::Victor::ExternalComms::RtsForceDisconnect&& new_RtsForceDisconnect);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsForceDisconnect&& new_RtsForceDisconnect);
  const Anki::Victor::ExternalComms::RtsForceDisconnect& Get_RtsForceDisconnect() const;
  void Set_RtsForceDisconnect(const Anki::Victor::ExternalComms::RtsForceDisconnect& new_RtsForceDisconnect);
  void Set_RtsForceDisconnect(Anki::Victor::ExternalComms::RtsForceDisconnect&& new_RtsForceDisconnect);
  
  /** RtsAck **/
  static RtsConnection CreateRtsAck(Anki::Victor::ExternalComms::RtsAck&& new_RtsAck);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsAck&& new_RtsAck);
  const Anki::Victor::ExternalComms::RtsAck& Get_RtsAck() const;
  void Set_RtsAck(const Anki::Victor::ExternalComms::RtsAck& new_RtsAck);
  void Set_RtsAck(Anki::Victor::ExternalComms::RtsAck&& new_RtsAck);
  
  /** RtsWifiAccessPointRequest **/
  static RtsConnection CreateRtsWifiAccessPointRequest(Anki::Victor::ExternalComms::RtsWifiAccessPointRequest&& new_RtsWifiAccessPointRequest);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsWifiAccessPointRequest&& new_RtsWifiAccessPointRequest);
  const Anki::Victor::ExternalComms::RtsWifiAccessPointRequest& Get_RtsWifiAccessPointRequest() const;
  void Set_RtsWifiAccessPointRequest(const Anki::Victor::ExternalComms::RtsWifiAccessPointRequest& new_RtsWifiAccessPointRequest);
  void Set_RtsWifiAccessPointRequest(Anki::Victor::ExternalComms::RtsWifiAccessPointRequest&& new_RtsWifiAccessPointRequest);
  
  /** RtsWifiAccessPointResponse **/
  static RtsConnection CreateRtsWifiAccessPointResponse(Anki::Victor::ExternalComms::RtsWifiAccessPointResponse&& new_RtsWifiAccessPointResponse);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsWifiAccessPointResponse&& new_RtsWifiAccessPointResponse);
  const Anki::Victor::ExternalComms::RtsWifiAccessPointResponse& Get_RtsWifiAccessPointResponse() const;
  void Set_RtsWifiAccessPointResponse(const Anki::Victor::ExternalComms::RtsWifiAccessPointResponse& new_RtsWifiAccessPointResponse);
  void Set_RtsWifiAccessPointResponse(Anki::Victor::ExternalComms::RtsWifiAccessPointResponse&& new_RtsWifiAccessPointResponse);
  
  /** RtsSshRequest **/
  static RtsConnection CreateRtsSshRequest(Anki::Victor::ExternalComms::RtsSshRequest&& new_RtsSshRequest);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsSshRequest&& new_RtsSshRequest);
  const Anki::Victor::ExternalComms::RtsSshRequest& Get_RtsSshRequest() const;
  void Set_RtsSshRequest(const Anki::Victor::ExternalComms::RtsSshRequest& new_RtsSshRequest);
  void Set_RtsSshRequest(Anki::Victor::ExternalComms::RtsSshRequest&& new_RtsSshRequest);
  
  /** RtsSshResponse **/
  static RtsConnection CreateRtsSshResponse(Anki::Victor::ExternalComms::RtsSshResponse&& new_RtsSshResponse);
  explicit RtsConnection(Anki::Victor::ExternalComms::RtsSshResponse&& new_RtsSshResponse);
  const Anki::Victor::ExternalComms::RtsSshResponse& Get_RtsSshResponse() const;
  void Set_RtsSshResponse(const Anki::Victor::ExternalComms::RtsSshResponse& new_RtsSshResponse);
  void Set_RtsSshResponse(Anki::Victor::ExternalComms::RtsSshResponse&& new_RtsSshResponse);
  
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  size_t Size() const;
  
  bool operator==(const RtsConnection& other) const;
  bool operator!=(const RtsConnection& other) const;
private:
  void ClearCurrent();
  Tag _tag;
  
  union {
    Anki::Victor::ExternalComms::Error _Error;
    Anki::Victor::ExternalComms::RtsConnRequest _RtsConnRequest;
    Anki::Victor::ExternalComms::RtsConnResponse _RtsConnResponse;
    Anki::Victor::ExternalComms::RtsNonceMessage _RtsNonceMessage;
    Anki::Victor::ExternalComms::RtsChallengeMessage _RtsChallengeMessage;
    Anki::Victor::ExternalComms::RtsChallengeSuccessMessage _RtsChallengeSuccessMessage;
    Anki::Victor::ExternalComms::RtsWifiConnectRequest _RtsWifiConnectRequest;
    Anki::Victor::ExternalComms::RtsWifiConnectResponse _RtsWifiConnectResponse;
    Anki::Victor::ExternalComms::RtsWifiIpRequest _RtsWifiIpRequest;
    Anki::Victor::ExternalComms::RtsWifiIpResponse _RtsWifiIpResponse;
    Anki::Victor::ExternalComms::RtsStatusRequest _RtsStatusRequest;
    Anki::Victor::ExternalComms::RtsStatusResponse _RtsStatusResponse;
    Anki::Victor::ExternalComms::RtsWifiScanRequest _RtsWifiScanRequest;
    Anki::Victor::ExternalComms::RtsWifiScanResponse _RtsWifiScanResponse;
    Anki::Victor::ExternalComms::RtsOtaUpdateRequest _RtsOtaUpdateRequest;
    Anki::Victor::ExternalComms::RtsOtaUpdateResponse _RtsOtaUpdateResponse;
    Anki::Victor::ExternalComms::RtsCancelPairing _RtsCancelPairing;
    Anki::Victor::ExternalComms::RtsForceDisconnect _RtsForceDisconnect;
    Anki::Victor::ExternalComms::RtsAck _RtsAck;
    Anki::Victor::ExternalComms::RtsWifiAccessPointRequest _RtsWifiAccessPointRequest;
    Anki::Victor::ExternalComms::RtsWifiAccessPointResponse _RtsWifiAccessPointResponse;
    Anki::Victor::ExternalComms::RtsSshRequest _RtsSshRequest;
    Anki::Victor::ExternalComms::RtsSshResponse _RtsSshResponse;
  };
};
extern const char* RtsConnectionVersionHashStr;
extern const uint8_t RtsConnectionVersionHash[16];

// ENUM RobotStatus
enum class RobotStatus : uint16_t {
  Exploring = 0,
};

const char* EnumToString(const RobotStatus m);
inline const char* RobotStatusToString(const RobotStatus m) { return EnumToString(m); }


extern const char* RobotStatusVersionHashStr;
extern const uint8_t RobotStatusVersionHash[16];

constexpr uint16_t RobotStatusNumEntries = 1;

// MESSAGE RobotStatusRequest
struct RobotStatusRequest
{
  
  /**** Constructors ****/
  RobotStatusRequest() = default;
  RobotStatusRequest(const RobotStatusRequest& other) = default;
  RobotStatusRequest(RobotStatusRequest& other) = default;
  RobotStatusRequest(RobotStatusRequest&& other) noexcept = default;
  RobotStatusRequest& operator=(const RobotStatusRequest& other) = default;
  RobotStatusRequest& operator=(RobotStatusRequest&& other) = default;
  
  explicit RobotStatusRequest(const uint8_t* buff, size_t len);
  explicit RobotStatusRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RobotStatusRequest& other) const;
  bool operator!=(const RobotStatusRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* RobotStatusRequestVersionHashStr;
extern const uint8_t RobotStatusRequestVersionHash[16];

// MESSAGE RobotStatusResponse
struct RobotStatusResponse
{
  Anki::Victor::ExternalComms::RobotStatus response;
  
  /**** Constructors ****/
  RobotStatusResponse() = default;
  RobotStatusResponse(const RobotStatusResponse& other) = default;
  RobotStatusResponse(RobotStatusResponse& other) = default;
  RobotStatusResponse(RobotStatusResponse&& other) noexcept = default;
  RobotStatusResponse& operator=(const RobotStatusResponse& other) = default;
  RobotStatusResponse& operator=(RobotStatusResponse&& other) = default;
  
  explicit RobotStatusResponse(Anki::Victor::ExternalComms::RobotStatus response)
  : response(response)
  {}
  
  explicit RobotStatusResponse(const uint8_t* buff, size_t len);
  explicit RobotStatusResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const RobotStatusResponse& other) const;
  bool operator!=(const RobotStatusResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(response);
  }
};

extern const char* RobotStatusResponseVersionHashStr;
extern const uint8_t RobotStatusResponseVersionHash[16];

// "Lookup Tables" for getting type by tag using template specializations
template<AppGeneralTag tag>
struct AppGeneral_TagToType;

template<>
struct AppGeneral_TagToType<AppGeneralTag::Error> {
  using type = Anki::Victor::ExternalComms::Error;
};
template<>
struct AppGeneral_TagToType<AppGeneralTag::RobotStatusRequest> {
  using type = Anki::Victor::ExternalComms::RobotStatusRequest;
};
template<>
struct AppGeneral_TagToType<AppGeneralTag::RobotStatusResponse> {
  using type = Anki::Victor::ExternalComms::RobotStatusResponse;
};

// UNION AppGeneral
class AppGeneral
{
public:
  using Tag = AppGeneralTag;
  /**** Constructors ****/
  AppGeneral() :_tag(Tag::INVALID) { }
  explicit AppGeneral(const CLAD::SafeMessageBuffer& buff);
  explicit AppGeneral(const uint8_t* buffer, size_t length);
  AppGeneral(const AppGeneral& other);
  AppGeneral(AppGeneral&& other) noexcept;
  AppGeneral& operator=(const AppGeneral& other);
  AppGeneral& operator=(AppGeneral&& other) noexcept;
  
  ~AppGeneral() { ClearCurrent(); }
  Tag GetTag() const { return _tag; }
  
  // Templated getter for union members by type
  // NOTE: Always returns a reference, even for trivial types, unlike untemplated version
  template<Tag tag>
  const typename AppGeneral_TagToType<tag>::type & Get_() const;
  
  // Templated creator for making a union object out of one if its members
  template <Tag tag>
  static AppGeneral Create_(typename AppGeneral_TagToType<tag>::type member);
  
  /** Error **/
  static AppGeneral CreateError(Anki::Victor::ExternalComms::Error&& new_Error);
  explicit AppGeneral(Anki::Victor::ExternalComms::Error&& new_Error);
  const Anki::Victor::ExternalComms::Error& Get_Error() const;
  void Set_Error(const Anki::Victor::ExternalComms::Error& new_Error);
  void Set_Error(Anki::Victor::ExternalComms::Error&& new_Error);
  
  /** RobotStatusRequest **/
  static AppGeneral CreateRobotStatusRequest(Anki::Victor::ExternalComms::RobotStatusRequest&& new_RobotStatusRequest);
  explicit AppGeneral(Anki::Victor::ExternalComms::RobotStatusRequest&& new_RobotStatusRequest);
  const Anki::Victor::ExternalComms::RobotStatusRequest& Get_RobotStatusRequest() const;
  void Set_RobotStatusRequest(const Anki::Victor::ExternalComms::RobotStatusRequest& new_RobotStatusRequest);
  void Set_RobotStatusRequest(Anki::Victor::ExternalComms::RobotStatusRequest&& new_RobotStatusRequest);
  
  /** RobotStatusResponse **/
  static AppGeneral CreateRobotStatusResponse(Anki::Victor::ExternalComms::RobotStatusResponse&& new_RobotStatusResponse);
  explicit AppGeneral(Anki::Victor::ExternalComms::RobotStatusResponse&& new_RobotStatusResponse);
  const Anki::Victor::ExternalComms::RobotStatusResponse& Get_RobotStatusResponse() const;
  void Set_RobotStatusResponse(const Anki::Victor::ExternalComms::RobotStatusResponse& new_RobotStatusResponse);
  void Set_RobotStatusResponse(Anki::Victor::ExternalComms::RobotStatusResponse&& new_RobotStatusResponse);
  
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  size_t Size() const;
  
  bool operator==(const AppGeneral& other) const;
  bool operator!=(const AppGeneral& other) const;
private:
  void ClearCurrent();
  Tag _tag;
  
  union {
    Anki::Victor::ExternalComms::Error _Error;
    Anki::Victor::ExternalComms::RobotStatusRequest _RobotStatusRequest;
    Anki::Victor::ExternalComms::RobotStatusResponse _RobotStatusResponse;
  };
};
extern const char* AppGeneralVersionHashStr;
extern const uint8_t AppGeneralVersionHash[16];

// MESSAGE MeetVictorRequest
struct MeetVictorRequest
{
  
  /**** Constructors ****/
  MeetVictorRequest() = default;
  MeetVictorRequest(const MeetVictorRequest& other) = default;
  MeetVictorRequest(MeetVictorRequest& other) = default;
  MeetVictorRequest(MeetVictorRequest&& other) noexcept = default;
  MeetVictorRequest& operator=(const MeetVictorRequest& other) = default;
  MeetVictorRequest& operator=(MeetVictorRequest&& other) = default;
  
  explicit MeetVictorRequest(const uint8_t* buff, size_t len);
  explicit MeetVictorRequest(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const MeetVictorRequest& other) const;
  bool operator!=(const MeetVictorRequest& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* MeetVictorRequestVersionHashStr;
extern const uint8_t MeetVictorRequestVersionHash[16];

// MESSAGE MeetVictorReadyResponse
struct MeetVictorReadyResponse
{
  std::string faceID;
  
  /**** Constructors ****/
  MeetVictorReadyResponse() = default;
  MeetVictorReadyResponse(const MeetVictorReadyResponse& other) = default;
  MeetVictorReadyResponse(MeetVictorReadyResponse& other) = default;
  MeetVictorReadyResponse(MeetVictorReadyResponse&& other) noexcept = default;
  MeetVictorReadyResponse& operator=(const MeetVictorReadyResponse& other) = default;
  MeetVictorReadyResponse& operator=(MeetVictorReadyResponse&& other) = default;
  
  explicit MeetVictorReadyResponse(const std::string& faceID)
  : faceID(faceID)
  {}
  
  explicit MeetVictorReadyResponse(const uint8_t* buff, size_t len);
  explicit MeetVictorReadyResponse(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const MeetVictorReadyResponse& other) const;
  bool operator!=(const MeetVictorReadyResponse& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(faceID);
  }
};

extern const char* MeetVictorReadyResponseVersionHashStr;
extern const uint8_t MeetVictorReadyResponseVersionHash[16];

// MESSAGE MeetVictorFaceScanStarted
struct MeetVictorFaceScanStarted
{
  
  /**** Constructors ****/
  MeetVictorFaceScanStarted() = default;
  MeetVictorFaceScanStarted(const MeetVictorFaceScanStarted& other) = default;
  MeetVictorFaceScanStarted(MeetVictorFaceScanStarted& other) = default;
  MeetVictorFaceScanStarted(MeetVictorFaceScanStarted&& other) noexcept = default;
  MeetVictorFaceScanStarted& operator=(const MeetVictorFaceScanStarted& other) = default;
  MeetVictorFaceScanStarted& operator=(MeetVictorFaceScanStarted&& other) = default;
  
  explicit MeetVictorFaceScanStarted(const uint8_t* buff, size_t len);
  explicit MeetVictorFaceScanStarted(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const MeetVictorFaceScanStarted& other) const;
  bool operator!=(const MeetVictorFaceScanStarted& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* MeetVictorFaceScanStartedVersionHashStr;
extern const uint8_t MeetVictorFaceScanStartedVersionHash[16];

// MESSAGE MeetVictorFaceScanComplete
struct MeetVictorFaceScanComplete
{
  
  /**** Constructors ****/
  MeetVictorFaceScanComplete() = default;
  MeetVictorFaceScanComplete(const MeetVictorFaceScanComplete& other) = default;
  MeetVictorFaceScanComplete(MeetVictorFaceScanComplete& other) = default;
  MeetVictorFaceScanComplete(MeetVictorFaceScanComplete&& other) noexcept = default;
  MeetVictorFaceScanComplete& operator=(const MeetVictorFaceScanComplete& other) = default;
  MeetVictorFaceScanComplete& operator=(MeetVictorFaceScanComplete&& other) = default;
  
  explicit MeetVictorFaceScanComplete(const uint8_t* buff, size_t len);
  explicit MeetVictorFaceScanComplete(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const MeetVictorFaceScanComplete& other) const;
  bool operator!=(const MeetVictorFaceScanComplete& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func();
  }
};

extern const char* MeetVictorFaceScanCompleteVersionHashStr;
extern const uint8_t MeetVictorFaceScanCompleteVersionHash[16];

// MESSAGE MeetVictorSetUserName
struct MeetVictorSetUserName
{
  std::string faceID;
  std::string name;
  
  /**** Constructors ****/
  MeetVictorSetUserName() = default;
  MeetVictorSetUserName(const MeetVictorSetUserName& other) = default;
  MeetVictorSetUserName(MeetVictorSetUserName& other) = default;
  MeetVictorSetUserName(MeetVictorSetUserName&& other) noexcept = default;
  MeetVictorSetUserName& operator=(const MeetVictorSetUserName& other) = default;
  MeetVictorSetUserName& operator=(MeetVictorSetUserName&& other) = default;
  
  explicit MeetVictorSetUserName(const std::string& faceID,
    const std::string& name)
  : faceID(faceID)
  , name(name)
  {}
  
  explicit MeetVictorSetUserName(const uint8_t* buff, size_t len);
  explicit MeetVictorSetUserName(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const MeetVictorSetUserName& other) const;
  bool operator!=(const MeetVictorSetUserName& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(faceID, name);
  }
};

extern const char* MeetVictorSetUserNameVersionHashStr;
extern const uint8_t MeetVictorSetUserNameVersionHash[16];

// MESSAGE MeetVictorComplete
struct MeetVictorComplete
{
  bool success;
  
  /**** Constructors ****/
  MeetVictorComplete() = default;
  MeetVictorComplete(const MeetVictorComplete& other) = default;
  MeetVictorComplete(MeetVictorComplete& other) = default;
  MeetVictorComplete(MeetVictorComplete&& other) noexcept = default;
  MeetVictorComplete& operator=(const MeetVictorComplete& other) = default;
  MeetVictorComplete& operator=(MeetVictorComplete&& other) = default;
  
  explicit MeetVictorComplete(bool success)
  : success(success)
  {}
  
  explicit MeetVictorComplete(const uint8_t* buff, size_t len);
  explicit MeetVictorComplete(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const MeetVictorComplete& other) const;
  bool operator!=(const MeetVictorComplete& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(success);
  }
};

extern const char* MeetVictorCompleteVersionHashStr;
extern const uint8_t MeetVictorCompleteVersionHash[16];

// MESSAGE MeetVictorError
struct MeetVictorError
{
  std::string errorString;
  
  /**** Constructors ****/
  MeetVictorError() = default;
  MeetVictorError(const MeetVictorError& other) = default;
  MeetVictorError(MeetVictorError& other) = default;
  MeetVictorError(MeetVictorError&& other) noexcept = default;
  MeetVictorError& operator=(const MeetVictorError& other) = default;
  MeetVictorError& operator=(MeetVictorError&& other) = default;
  
  explicit MeetVictorError(const std::string& errorString)
  : errorString(errorString)
  {}
  
  explicit MeetVictorError(const uint8_t* buff, size_t len);
  explicit MeetVictorError(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const MeetVictorError& other) const;
  bool operator!=(const MeetVictorError& other) const;
  
  template <typename Callable>
  void Invoke(Callable&& func) const {
     func(errorString);
  }
};

extern const char* MeetVictorErrorVersionHashStr;
extern const uint8_t MeetVictorErrorVersionHash[16];

// "Lookup Tables" for getting type by tag using template specializations
template<MeetVictorTag tag>
struct MeetVictor_TagToType;

template<>
struct MeetVictor_TagToType<MeetVictorTag::Error> {
  using type = Anki::Victor::ExternalComms::Error;
};
template<>
struct MeetVictor_TagToType<MeetVictorTag::MeetVictorRequest> {
  using type = Anki::Victor::ExternalComms::MeetVictorRequest;
};
template<>
struct MeetVictor_TagToType<MeetVictorTag::MeetVictorReadyResponse> {
  using type = Anki::Victor::ExternalComms::MeetVictorReadyResponse;
};
template<>
struct MeetVictor_TagToType<MeetVictorTag::MeetVictorFaceScanStarted> {
  using type = Anki::Victor::ExternalComms::MeetVictorFaceScanStarted;
};
template<>
struct MeetVictor_TagToType<MeetVictorTag::MeetVictorFaceScanComplete> {
  using type = Anki::Victor::ExternalComms::MeetVictorFaceScanComplete;
};
template<>
struct MeetVictor_TagToType<MeetVictorTag::MeetVictorSetUserName> {
  using type = Anki::Victor::ExternalComms::MeetVictorSetUserName;
};
template<>
struct MeetVictor_TagToType<MeetVictorTag::MeetVictorComplete> {
  using type = Anki::Victor::ExternalComms::MeetVictorComplete;
};
template<>
struct MeetVictor_TagToType<MeetVictorTag::MeetVictorError> {
  using type = Anki::Victor::ExternalComms::MeetVictorError;
};

// UNION MeetVictor
class MeetVictor
{
public:
  using Tag = MeetVictorTag;
  /**** Constructors ****/
  MeetVictor() :_tag(Tag::INVALID) { }
  explicit MeetVictor(const CLAD::SafeMessageBuffer& buff);
  explicit MeetVictor(const uint8_t* buffer, size_t length);
  MeetVictor(const MeetVictor& other);
  MeetVictor(MeetVictor&& other) noexcept;
  MeetVictor& operator=(const MeetVictor& other);
  MeetVictor& operator=(MeetVictor&& other) noexcept;
  
  ~MeetVictor() { ClearCurrent(); }
  Tag GetTag() const { return _tag; }
  
  // Templated getter for union members by type
  // NOTE: Always returns a reference, even for trivial types, unlike untemplated version
  template<Tag tag>
  const typename MeetVictor_TagToType<tag>::type & Get_() const;
  
  // Templated creator for making a union object out of one if its members
  template <Tag tag>
  static MeetVictor Create_(typename MeetVictor_TagToType<tag>::type member);
  
  /** Error **/
  static MeetVictor CreateError(Anki::Victor::ExternalComms::Error&& new_Error);
  explicit MeetVictor(Anki::Victor::ExternalComms::Error&& new_Error);
  const Anki::Victor::ExternalComms::Error& Get_Error() const;
  void Set_Error(const Anki::Victor::ExternalComms::Error& new_Error);
  void Set_Error(Anki::Victor::ExternalComms::Error&& new_Error);
  
  /** MeetVictorRequest **/
  static MeetVictor CreateMeetVictorRequest(Anki::Victor::ExternalComms::MeetVictorRequest&& new_MeetVictorRequest);
  explicit MeetVictor(Anki::Victor::ExternalComms::MeetVictorRequest&& new_MeetVictorRequest);
  const Anki::Victor::ExternalComms::MeetVictorRequest& Get_MeetVictorRequest() const;
  void Set_MeetVictorRequest(const Anki::Victor::ExternalComms::MeetVictorRequest& new_MeetVictorRequest);
  void Set_MeetVictorRequest(Anki::Victor::ExternalComms::MeetVictorRequest&& new_MeetVictorRequest);
  
  /** MeetVictorReadyResponse **/
  static MeetVictor CreateMeetVictorReadyResponse(Anki::Victor::ExternalComms::MeetVictorReadyResponse&& new_MeetVictorReadyResponse);
  explicit MeetVictor(Anki::Victor::ExternalComms::MeetVictorReadyResponse&& new_MeetVictorReadyResponse);
  const Anki::Victor::ExternalComms::MeetVictorReadyResponse& Get_MeetVictorReadyResponse() const;
  void Set_MeetVictorReadyResponse(const Anki::Victor::ExternalComms::MeetVictorReadyResponse& new_MeetVictorReadyResponse);
  void Set_MeetVictorReadyResponse(Anki::Victor::ExternalComms::MeetVictorReadyResponse&& new_MeetVictorReadyResponse);
  
  /** MeetVictorFaceScanStarted **/
  static MeetVictor CreateMeetVictorFaceScanStarted(Anki::Victor::ExternalComms::MeetVictorFaceScanStarted&& new_MeetVictorFaceScanStarted);
  explicit MeetVictor(Anki::Victor::ExternalComms::MeetVictorFaceScanStarted&& new_MeetVictorFaceScanStarted);
  const Anki::Victor::ExternalComms::MeetVictorFaceScanStarted& Get_MeetVictorFaceScanStarted() const;
  void Set_MeetVictorFaceScanStarted(const Anki::Victor::ExternalComms::MeetVictorFaceScanStarted& new_MeetVictorFaceScanStarted);
  void Set_MeetVictorFaceScanStarted(Anki::Victor::ExternalComms::MeetVictorFaceScanStarted&& new_MeetVictorFaceScanStarted);
  
  /** MeetVictorFaceScanComplete **/
  static MeetVictor CreateMeetVictorFaceScanComplete(Anki::Victor::ExternalComms::MeetVictorFaceScanComplete&& new_MeetVictorFaceScanComplete);
  explicit MeetVictor(Anki::Victor::ExternalComms::MeetVictorFaceScanComplete&& new_MeetVictorFaceScanComplete);
  const Anki::Victor::ExternalComms::MeetVictorFaceScanComplete& Get_MeetVictorFaceScanComplete() const;
  void Set_MeetVictorFaceScanComplete(const Anki::Victor::ExternalComms::MeetVictorFaceScanComplete& new_MeetVictorFaceScanComplete);
  void Set_MeetVictorFaceScanComplete(Anki::Victor::ExternalComms::MeetVictorFaceScanComplete&& new_MeetVictorFaceScanComplete);
  
  /** MeetVictorSetUserName **/
  static MeetVictor CreateMeetVictorSetUserName(Anki::Victor::ExternalComms::MeetVictorSetUserName&& new_MeetVictorSetUserName);
  explicit MeetVictor(Anki::Victor::ExternalComms::MeetVictorSetUserName&& new_MeetVictorSetUserName);
  const Anki::Victor::ExternalComms::MeetVictorSetUserName& Get_MeetVictorSetUserName() const;
  void Set_MeetVictorSetUserName(const Anki::Victor::ExternalComms::MeetVictorSetUserName& new_MeetVictorSetUserName);
  void Set_MeetVictorSetUserName(Anki::Victor::ExternalComms::MeetVictorSetUserName&& new_MeetVictorSetUserName);
  
  /** MeetVictorComplete **/
  static MeetVictor CreateMeetVictorComplete(Anki::Victor::ExternalComms::MeetVictorComplete&& new_MeetVictorComplete);
  explicit MeetVictor(Anki::Victor::ExternalComms::MeetVictorComplete&& new_MeetVictorComplete);
  const Anki::Victor::ExternalComms::MeetVictorComplete& Get_MeetVictorComplete() const;
  void Set_MeetVictorComplete(const Anki::Victor::ExternalComms::MeetVictorComplete& new_MeetVictorComplete);
  void Set_MeetVictorComplete(Anki::Victor::ExternalComms::MeetVictorComplete&& new_MeetVictorComplete);
  
  /** MeetVictorError **/
  static MeetVictor CreateMeetVictorError(Anki::Victor::ExternalComms::MeetVictorError&& new_MeetVictorError);
  explicit MeetVictor(Anki::Victor::ExternalComms::MeetVictorError&& new_MeetVictorError);
  const Anki::Victor::ExternalComms::MeetVictorError& Get_MeetVictorError() const;
  void Set_MeetVictorError(const Anki::Victor::ExternalComms::MeetVictorError& new_MeetVictorError);
  void Set_MeetVictorError(Anki::Victor::ExternalComms::MeetVictorError&& new_MeetVictorError);
  
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  size_t Size() const;
  
  bool operator==(const MeetVictor& other) const;
  bool operator!=(const MeetVictor& other) const;
private:
  void ClearCurrent();
  Tag _tag;
  
  union {
    Anki::Victor::ExternalComms::Error _Error;
    Anki::Victor::ExternalComms::MeetVictorRequest _MeetVictorRequest;
    Anki::Victor::ExternalComms::MeetVictorReadyResponse _MeetVictorReadyResponse;
    Anki::Victor::ExternalComms::MeetVictorFaceScanStarted _MeetVictorFaceScanStarted;
    Anki::Victor::ExternalComms::MeetVictorFaceScanComplete _MeetVictorFaceScanComplete;
    Anki::Victor::ExternalComms::MeetVictorSetUserName _MeetVictorSetUserName;
    Anki::Victor::ExternalComms::MeetVictorComplete _MeetVictorComplete;
    Anki::Victor::ExternalComms::MeetVictorError _MeetVictorError;
  };
};
extern const char* MeetVictorVersionHashStr;
extern const uint8_t MeetVictorVersionHash[16];

// "Lookup Tables" for getting type by tag using template specializations
template<ExternalCommsTag tag>
struct ExternalComms_TagToType;

template<>
struct ExternalComms_TagToType<ExternalCommsTag::Error> {
  using type = Anki::Victor::ExternalComms::Error;
};
template<>
struct ExternalComms_TagToType<ExternalCommsTag::RtsConnection> {
  using type = Anki::Victor::ExternalComms::RtsConnection;
};
template<>
struct ExternalComms_TagToType<ExternalCommsTag::AppGeneral> {
  using type = Anki::Victor::ExternalComms::AppGeneral;
};
template<>
struct ExternalComms_TagToType<ExternalCommsTag::MeetVictor> {
  using type = Anki::Victor::ExternalComms::MeetVictor;
};

// UNION ExternalComms
class ExternalComms
{
public:
  using Tag = ExternalCommsTag;
  /**** Constructors ****/
  ExternalComms() :_tag(Tag::INVALID) { }
  explicit ExternalComms(const CLAD::SafeMessageBuffer& buff);
  explicit ExternalComms(const uint8_t* buffer, size_t length);
  ExternalComms(const ExternalComms& other);
  ExternalComms(ExternalComms&& other) noexcept;
  ExternalComms& operator=(const ExternalComms& other);
  ExternalComms& operator=(ExternalComms&& other) noexcept;
  
  ~ExternalComms() { ClearCurrent(); }
  Tag GetTag() const { return _tag; }
  
  // Templated getter for union members by type
  // NOTE: Always returns a reference, even for trivial types, unlike untemplated version
  template<Tag tag>
  const typename ExternalComms_TagToType<tag>::type & Get_() const;
  
  // Templated creator for making a union object out of one if its members
  template <Tag tag>
  static ExternalComms Create_(typename ExternalComms_TagToType<tag>::type member);
  
  /** Error **/
  static ExternalComms CreateError(Anki::Victor::ExternalComms::Error&& new_Error);
  explicit ExternalComms(Anki::Victor::ExternalComms::Error&& new_Error);
  const Anki::Victor::ExternalComms::Error& Get_Error() const;
  void Set_Error(const Anki::Victor::ExternalComms::Error& new_Error);
  void Set_Error(Anki::Victor::ExternalComms::Error&& new_Error);
  
  /** RtsConnection **/
  static ExternalComms CreateRtsConnection(Anki::Victor::ExternalComms::RtsConnection&& new_RtsConnection);
  explicit ExternalComms(Anki::Victor::ExternalComms::RtsConnection&& new_RtsConnection);
  const Anki::Victor::ExternalComms::RtsConnection& Get_RtsConnection() const;
  void Set_RtsConnection(const Anki::Victor::ExternalComms::RtsConnection& new_RtsConnection);
  void Set_RtsConnection(Anki::Victor::ExternalComms::RtsConnection&& new_RtsConnection);
  
  /** AppGeneral **/
  static ExternalComms CreateAppGeneral(Anki::Victor::ExternalComms::AppGeneral&& new_AppGeneral);
  explicit ExternalComms(Anki::Victor::ExternalComms::AppGeneral&& new_AppGeneral);
  const Anki::Victor::ExternalComms::AppGeneral& Get_AppGeneral() const;
  void Set_AppGeneral(const Anki::Victor::ExternalComms::AppGeneral& new_AppGeneral);
  void Set_AppGeneral(Anki::Victor::ExternalComms::AppGeneral&& new_AppGeneral);
  
  /** MeetVictor **/
  static ExternalComms CreateMeetVictor(Anki::Victor::ExternalComms::MeetVictor&& new_MeetVictor);
  explicit ExternalComms(Anki::Victor::ExternalComms::MeetVictor&& new_MeetVictor);
  const Anki::Victor::ExternalComms::MeetVictor& Get_MeetVictor() const;
  void Set_MeetVictor(const Anki::Victor::ExternalComms::MeetVictor& new_MeetVictor);
  void Set_MeetVictor(Anki::Victor::ExternalComms::MeetVictor&& new_MeetVictor);
  
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  size_t Size() const;
  
  bool operator==(const ExternalComms& other) const;
  bool operator!=(const ExternalComms& other) const;
private:
  void ClearCurrent();
  Tag _tag;
  
  union {
    Anki::Victor::ExternalComms::Error _Error;
    Anki::Victor::ExternalComms::RtsConnection _RtsConnection;
    Anki::Victor::ExternalComms::AppGeneral _AppGeneral;
    Anki::Victor::ExternalComms::MeetVictor _MeetVictor;
  };
};
extern const char* ExternalCommsVersionHashStr;
extern const uint8_t ExternalCommsVersionHash[16];

} // namespace ExternalComms

} // namespace Victor

} // namespace Anki

#endif // __CLAD_EXTERNAL_INTERFACE_MESSAGE_EXTERNAL_COMMS_H__
