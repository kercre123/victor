#!/usr/bin/env python3

import sys, socket, struct, time
from ReliableTransport import *

if sys.version_info.major < 3:
    sys.exit("minipegReceiver only works with python3+")

def mini2jpeg(minipeg):
    header = [
      0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 
      0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x10, 0x0B, 0x0C, 0x0E, 0x0C, 0x0A, 0x10, # 0x19 = QTable
      0x0E, 0x0D, 0x0E, 0x12, 0x11, 0x10, 0x13, 0x18, 0x28, 0x1A, 0x18, 0x16, 0x16, 0x18, 0x31, 0x23, 
      0x25, 0x1D, 0x28, 0x3A, 0x33, 0x3D, 0x3C, 0x39, 0x33, 0x38, 0x37, 0x40, 0x48, 0x5C, 0x4E, 0x40, 
      0x44, 0x57, 0x45, 0x37, 0x38, 0x50, 0x6D, 0x51, 0x57, 0x5F, 0x62, 0x67, 0x68, 0x67, 0x3E, 0x4D, 
      0x71, 0x79, 0x70, 0x64, 0x78, 0x5C, 0x65, 0x67, 0x63, 0xFF, 0xC0, 0x00, 0x0B, 0x08, 0x00, 0xF0, # 0x5E = Height x Width
      0x01, 0x40, 0x01, 0x01, 0x11, 0x00, 0xFF, 0xC4, 0x00, 0xD2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 
      0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 
      0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01, 0x03, 0x03, 0x02, 0x04, 0x03, 
      0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 
      0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xA1, 0x08, 
      0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0A, 0x16, 
      0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 
      0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 
      0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 
      0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 
      0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 
      0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 
      0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 
      0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFF, 0xDA, 0x00, 0x08, 0x01, 0x01, 
      0x00, 0x00, 0x3F, 0x00
    ]
    out = header
    for b in minipeg:
        out.append(b)
        if b == 0xFF:
            out.append(0x00)
    out.append(0xff)
    out.append(0xd9)
    return bytes(out)

class ImageChunk(struct.Struct):
    """A one off python implementation of the ImageChunk CLAD message
    This should be replaced ASAP by importing CLAD generated python code.
    See messageRobotToEngine.clad for the definition"""
    
    ID = 0x82
    
    def __init__(self, buffer=None):
        struct.Struct.__init__(self, "IIBBBBH")
        self.frameTimeStamp = 0
        self.imageId = 0
        self.imageEncoding = 0
        self.imageResolution = 0
        self.imageChunkCount = 0
        self.chunkId = 0
        self.data = bytes()
        if buffer is not None:
            self.deserialize(buffer)

    def __repr__(self):
        return "ImageChunk({:d}, {:d}, {:d}, {:d}, {:d}, {:d}, {:d})".format(self.frameTimeStamp, self.imageId, \
                        self.imageEncoding, self.imageResolution, self.imageChunkCount, self.chunkId, len(self.data))

    def serialize(self):
        "Convert python struct into CLAD wire format"
        return bytes([self.ID]) + self.pack(self.frameTimeStamp, self.imageId, self.imageEncoding, self.imageResolution,
                                            self.imageChunkCount, self.chunkId, len(self.data)) + self.data

    def deserialize(self, buffer):
        "Load the ImageChunk from a bytestream"
        assert(buffer[0] == self.ID) # Check the ID
        self.frameTimeStamp, self.imageId, self.imageEncoding, self.imageResolution, self.imageChunkCount, \
            self.chunkId, length = self.unpack(buffer[1:self.size+1])
        self.data = buffer[self.size+1:]
        assert(len(self.data) == length)

class CozmoReceiver(IDataReceiver):
    "ReliableTransport receiver class"
    
    def __init__(self, robotAddress=("172.31.1.1", 5551)):
        sys.stdout.write("Connecting to robot at {}:{}\r\n".format(*robotAddress))
        self.robot = robotAddress
        ut = UDPTransport(logInPackets="rxPackets.bin")
        ut.OpenSocket()
        self.transport = ReliableTransport(ut, self)
        self.transport.Connect(self.robot)
        self.transport.start()
        
    def __del__(self):
        self.transport.KillThread()
        
    def OnConnectionRequest(self, sourceAddress):
        raise Exception("CozmoReceiver wasn't expecing a connection request")

    def OnConnected(self, sourceAddress):
        sys.stdout.write("Connected to robot at {}\r\n".format(repr(sourceAddress)))

    def OnDisconnected(self, sourceAddress):
        sys.stdout.write("Lost connection to robot at {}\r\n".format(repr(sourceAddress)))

    def ReceiveData(self, buffer, sourceAddress):
        if sourceAddress != self.robot:
            sys.stderr.write("Received data from unexpected address {}\r\n".format(repr(sourceAddress)))
        elif buffer[0] != ImageChunk.ID:
            sys.stderr.write("Received unexpected message {:02x}[{:d}]\r\n".format(buffer[0], len(buffer)))
        else:
            chunk = ImageChunk(buffer)
            sys.stdout.write(repr(chunk) + "\r\n")
            if chunk.imageChunkCount != 0:
                open("img{:05d}.minipeg".format(chunk.imageId), 'wb').write(chunk.data)

    def SendData(self, buffer):
        return self.transport.SendData(True, False, self.robot, buffer)
        
if __name__ == '__main__':
    c = CozmoReceiver()
    time.sleep(5)
