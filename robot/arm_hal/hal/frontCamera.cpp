#include "lib/stm32f4xx.h"
#include "anki/cozmo/robot/hal.h"
#include "anki/common/robot/trig_fast.h"
#include "hal/portable.h"

#include "anki/cozmo/shared/cozmoConfig.h" // for calibration parameters
#include "anki/common/robot/config.h"
#include "anki/common/robot/benchmarking.h"

#include "hal/i2c.h"

#include "clad/types/imageTypes.h"

/***************************************************************************
 *
 *                          Camera Calibration
 *
 **************************************************************************/

namespace Anki
{
  namespace Cozmo
  {
    
#ifdef COZMO_ROBOT_V40
    // Calibration values from August 11, 2015 - on headboard with SSID 3a99
    const u16 HEAD_CAM_CALIB_WIDTH  = 400;
    const u16 HEAD_CAM_CALIB_HEIGHT = 296;
    const f32 HEAD_CAM_CALIB_FOCAL_LENGTH_X = 273.316765624f;
    const f32 HEAD_CAM_CALIB_FOCAL_LENGTH_Y = 274.838250766f;
    const f32 HEAD_CAM_CALIB_CENTER_X       = 199.638842523f;
    const f32 HEAD_CAM_CALIB_CENTER_Y       = 160.682934109f;
    const f32 HEAD_CAM_CALIB_DISTORTION[NUM_RADIAL_DISTORTION_COEFFS] = {
      0.03956f,
      -0.08955f,
      0.00044f,
      0.00188f
    };
#else
    // Calibration values from Sept 1, 2015 - on 4.1 robot headboard with SSID 3a97
    const u16 HEAD_CAM_CALIB_WIDTH  = 400;
    const u16 HEAD_CAM_CALIB_HEIGHT = 296;
    const f32 HEAD_CAM_CALIB_FOCAL_LENGTH_X = 278.065116921f;
    const f32 HEAD_CAM_CALIB_FOCAL_LENGTH_Y = 278.867229568f;
    const f32 HEAD_CAM_CALIB_CENTER_X       = 197.801561858f;
    const f32 HEAD_CAM_CALIB_CENTER_Y       = 151.672492176f;
    const f32 HEAD_CAM_CALIB_DISTORTION[NUM_RADIAL_DISTORTION_COEFFS] = {
      0.11281163f,
      -0.31673507f,
      -0.00226334f,
      0.00200109f
    };
#endif
    
    
    namespace HAL
    {
      // For headboard 4.0
      GPIO_PIN_SOURCE(D0, GPIOA, 9);
      GPIO_PIN_SOURCE(D1, GPIOA, 10);
      GPIO_PIN_SOURCE(D2, GPIOG, 10);
      GPIO_PIN_SOURCE(D3, GPIOG, 11);
      GPIO_PIN_SOURCE(D4, GPIOE, 4);
      GPIO_PIN_SOURCE(D5, GPIOI, 4);
      GPIO_PIN_SOURCE(D6, GPIOI, 6);
      GPIO_PIN_SOURCE(D7, GPIOI, 7);
      GPIO_PIN_SOURCE(VSYNC, GPIOI, 5);
      GPIO_PIN_SOURCE(HSYNC, GPIOA, 4);
      GPIO_PIN_SOURCE(PCLK, GPIOA, 6);

      GPIO_PIN_SOURCE(XCLK, GPIOA, 3);
      GPIO_PIN_SOURCE(RESET_N, GPIOA, 8);  // Hacked onto TP1 in 4.0
      GPIO_PIN_SOURCE(PWDN, GPIOE, 2);
      
      // GPIO_PIN_SOURCE(FSIN, GPIOA, 1);  // Not connected in 4.0

      const u32 DCMI_TIMEOUT_MAX = 10000;

      const u8 I2C_ADDR = 0x3C;        // Address for GC2145
      
      unsigned short m_camScript[] =
        {
0xfe, 0xf0,
0xfe, 0xf0,
0xfe, 0xf0,
0xfc, 0x06,
0xf6, 0x00,
0xf7, 0x1d,
0xf8, 0x88,   // PLL divx4
0xfa, 0x00,
0xf9, 0xfe,
0xf2, 0x00,
//////////////////////////////////////////////////////
////////////////////  Analog & Cisctl ////////////////
//////////////////////////////////////////////////////
0xfe, 0x00,
0x03, 0x04,
0x04, 0x00,
0x09, 0x00,
0x0a, 0x00,
0x0b, 0x00,
0x0c, 0x00,
          
0x0d, 0x04,   // Physical window height
0x0e, 0xc0,

0x0f, 0x06,   // Physical window width
0x10, 0x52,

0x12, 0x2e,
0x17, 0x14,  // 14
0x18, 0x22,
0x19, 0x0f,
0x1a, 0x01,
0x1b, 0x4b,
0x1c, 0x07,
0x1d, 0x10,
0x1e, 0x88,
0x1f, 0x78,
0x20, 0x03,
0x21, 0x40,
0x22, 0xf0,
0x24, 0x16,
0x25, 0x01,
0x26, 0x10,
0x2d, 0x60,
0x30, 0x01,
0x31, 0x90,
0x33, 0x06,
0x34, 0x01,
///////////////////////////////////////////////////
////////////////////  ISP reg  //////////////////////
//////////////////////////////////////////////////////
0x80, 0xff,
0x81, 0x24,
0x82, 0xfa,
0x83, 0x00,
0x84, 0x03,   // Image format: YUYV
//0x84, 0x17,   // Image format: Bayer
0x86, 0x06,
0x88, 0x03,
0x89, 0x03,
0x85, 0x30,
0x8a, 0x00,
0x8b, 0x00,
0xb0, 0x55,
0xc3, 0x00,
0xc4, 0x80,
0xc5, 0x90,
0xc6, 0x38,
0xc7, 0x40,
0xec, 0x06,
0xed, 0x04,
0xee, 0x60,
0xef, 0x90,
0xb6, 0x01,
0x90, 0x01,
0x91, 0x00,
0x92, 0x00,
0x93, 0x00,
0x94, 0x00,

0x95, 0x04, // Output window height
0x96, 0xb0,

0x97, 0x06, // Output window width
0x98, 0x40,

///////////////////////////////////////////////
///////////  BLK ////////////////////////
///////////////////////////////////////////////
0x18, 0x02,
0x40, 0x42,
0x41, 0x00,
0x43, 0x54,
0x5e, 0x00,
0x5f, 0x00,
0x60, 0x00,
0x61, 0x00,
0x62, 0x00,
0x63, 0x00,
0x64, 0x00,
0x65, 0x00,
0x66, 0x20,
0x67, 0x20,
0x68, 0x20,
0x69, 0x20,
0x76, 0x00,
0x6a, 0x02,
0x6b, 0x02,
0x6c, 0x02,
0x6d, 0x02,
0x6e, 0x02,
0x6f, 0x02,
0x70, 0x02,
0x71, 0x02,
0x76, 0x00,
0x72, 0xf0,
0x7e, 0x3c,
0x7f, 0x00,
0xfe, 0x02,
0x48, 0x15,
0x49, 0x00,
0x4b, 0x0b,
0xfe, 0x00,
///////////////////////////////////////////////
/////////// AEC ////////////////////////
///////////////////////////////////////////////
0xfe, 0x01,
0x01, 0x04,
0x02, 0xc0,
0x03, 0x04,
0x04, 0x90,
0x05, 0x30,
0x06, 0x90,
0x07, 0x20,
0x08, 0x70,
0x09, 0x00,
0x0a, 0xc2,
0x0b, 0x11,
0x0c, 0x10,
0x13, 0x40,
0x17, 0x00,
0x1c, 0x11,
0x1e, 0x61,
0x1f, 0x30,
0x20, 0x40,
0x22, 0x80,
0x23, 0x20,
0xfe, 0x02,
0x0f, 0x04,
0xfe, 0x01,
0x12, 0x00,
0x15, 0x50,
0x10, 0x31,
0x3e, 0x28,
0x3f, 0xe0,
0x40, 0xe0,
0x41, 0x0f,
/////////////////////////////
//////// INTPEE /////////////
/////////////////////////////
0xfe, 0x02,
0x90, 0x6c,
0x91, 0x03,
0x92, 0xc8,
0x94, 0x66,
0x95, 0xb5,
0x97, 0x64,
0xa2, 0x11,
0xfe, 0x00,
/////////////////////////////
//////// DNDD///////////////
/////////////////////////////
0xfe, 0x02,
0x80, 0xc1,
0x81, 0x08,
0x82, 0x08,
0x83, 0x05,
0x84, 0x0a,
0x86, 0x50,
0x87, 0x30,
0x88, 0x15,
0x89, 0x80,
0x8a, 0x60,
0x8b, 0x30,
/////////////////////////////////////////////////
///////////// ASDE ////////////////////////
/////////////////////////////////////////////////
0xfe, 0x01,
0x21, 0x14,
0xfe, 0x02,
0xa3, 0x40,
0xa4, 0x20,
0xa5, 0x40,
0xa6, 0x80,
0xab, 0x40,
0xae, 0x0c,
0xb3, 0x34,
0xb4, 0x44,
0xb6, 0x38,
0xb7, 0x02,
0xb9, 0x30,
0x3c, 0x08,
0x3d, 0x30,
0x4b, 0x0d,
0x4c, 0x20,
0xfe, 0x00,
/////////////gamma1//////////////////
/////////////////////Gamma///////////////////////
///////////////////////////////////////
0xfe, 0x02,
0x10, 0x10,
0x11, 0x15,
0x12, 0x1a,
0x13, 0x1f,
0x14, 0x2c,
0x15, 0x39,
0x16, 0x45,
0x17, 0x54,
0x18, 0x69,
0x19, 0x7d,
0x1a, 0x8f,
0x1b, 0x9d,
0x1c, 0xa9,
0x1d, 0xbd,
0x1e, 0xcd,
0x1f, 0xd9,
0x20, 0xe3,
0x21, 0xea,
0x22, 0xef,
0x23, 0xf5,
0x24, 0xf9,
0x25, 0xff,
/////auto gamma///// 
0xfe, 0x02,
0x26, 0x0f,
0x27, 0x14,
0x28, 0x19,
0x29, 0x1e,
0x2a, 0x27,
0x2b, 0x33,
0x2c, 0x3b,
0x2d, 0x45,
0x2e, 0x59,
0x2f, 0x69,
0x30, 0x7c,
0x31, 0x89,
0x32, 0x98,
0x33, 0xae,
0x34, 0xc0,
0x35, 0xcf,
0x36, 0xda,
0x37, 0xe2,
0x38, 0xe9,
0x39, 0xf3,
0x3a, 0xf9,
0x3b, 0xff,
	///////////////////gamma2////////////////////
	////Gamma outdoor
	/*
0xfe, 0x02,
0x26, 0x17,
0x27, 0x18,
0x28, 0x1c,
0x29, 0x20,
0x2a, 0x28,
0x2b, 0x34,
0x2c, 0x40,
0x2d, 0x49,
0x2e, 0x5b,
0x2f, 0x6d,
0x30, 0x7d,
0x31, 0x89,
0x32, 0x97,
0x33, 0xac,
0x34, 0xc0,
0x35, 0xcf,
0x36, 0xda,
0x37, 0xe5,
0x38, 0xec,
0x39, 0xf8,
0x3a, 0xfd,
0x3b, 0xff,
	*/

	///////////////////////////////////////////////      
	///////////   YCP       ///////////////////////  
	///////////////////////////////////////////////  
0xfe, 0x02,
0xd1, 0x30,
0xd2, 0x30,
0xd3, 0x45,
0xdd, 0x14,
0xde, 0x86,
0xed, 0x01,
0xee, 0x28,
0xef, 0x30,
0xd8, 0xd8,

	////////////////////////////
	//////// LSC  0.8///////////////
	////////////////////////////
0xfe, 0x01,
0xc2, 0x1a,
0xc3, 0x0b,
0xc4, 0x0e,
0xc8, 0x20,
0xc9, 0x0c,
0xca, 0x12,
0xbc, 0x41,
0xbd, 0x1f,
0xbe, 0x29,
0xb6, 0x48,
0xb7, 0x22,
0xb8, 0x28,
0xc5, 0x04,
0xc6, 0x00,
0xc7, 0x00,
0xcb, 0x12,
0xcc, 0x00,
0xcd, 0x08,
0xbf, 0x14,
0xc0, 0x00,
0xc1, 0x10,
0xb9, 0x0f,
0xba, 0x00,
0xbb, 0x00,
0xaa, 0x0a,
0xab, 0x00,
0xac, 0x00,
0xad, 0x09,
0xae, 0x00,
0xaf, 0x02,
0xb0, 0x04,
0xb1, 0x00,
0xb2, 0x00,
0xb3, 0x03,
0xb4, 0x00,
0xb5, 0x02,
0xd0, 0x42,
0xd1, 0x00,
0xd2, 0x00,
0xd6, 0x47,
0xd7, 0x07,
0xd8, 0x00,
0xd9, 0x34,
0xda, 0x13,
0xdb, 0x00,
0xd3, 0x2b,
0xd4, 0x18,
0xd5, 0x10,
0xa4, 0x00,
0xa5, 0x00,
0xa6, 0x77,
0xa7, 0x77,
0xa8, 0x77,
0xa9, 0x77,
0xa1, 0x80,
0xa2, 0x80,
	
0xfe, 0x01,
0xdf, 0x00,
0xdc, 0x80,
0xdd, 0x30,
0xe0, 0x6b,
0xe1, 0x70,
0xe2, 0x6b,
0xe3, 0x70,
0xe6, 0xa0,
0xe7, 0x60,
0xe8, 0xa0,
0xe9, 0x60,
0xfe, 0x00,

	/////////////////////////////////////////////////
	/////////////    AWB     ////////////////////////
	/////////////////////////////////////////////////
#if 1  ///pheobe_cao 
	0xfe , 0x01,
	0x4f , 0x00,
	0x4f , 0x00,
	0x4b , 0x01,
	0x4f , 0x00,
	0x4c , 0x01, // D75
	0x4d , 0x71,
	0x4e , 0x01,
	0x4c , 0x01,
	0x4d , 0x91,
	0x4e , 0x01,
	0x4c , 0x01,
	0x4d , 0x70,
	0x4e , 0x01,
	0x4c , 0x01, // D65
	0x4d , 0x90,
	0x4e , 0x02,
	0x4c , 0x01,
	0x4d , 0xb0,
	0x4e , 0x02,
	0x4c , 0x01,
	0x4d , 0x8f,
	0x4e , 0x02,
	0x4c , 0x01,
	0x4d , 0x6f,
	0x4e , 0x02,
	0x4c , 0x01,
	0x4d , 0xaf,
	0x4e , 0x02,
	0x4c , 0x01,
	0x4d , 0xd0,
	0x4e , 0x02,
	0x4c , 0x01,
	0x4d , 0xf0,
	0x4e , 0x02,
	0x4c , 0x01,
	0x4d , 0xcf,
	0x4e , 0x02,
	0x4c , 0x01,
	0x4d , 0xef,
	0x4e , 0x02,
	0x4c , 0x01,//D50
	0x4d , 0x6e,
	0x4e , 0x03,
	0x4c , 0x01, 
	0x4d , 0x8e,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0xae,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0xce,
	0x4e , 0x03,
		//0x4c , 0x01,
		//0x4d , 0xcf,
		//0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0xee,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0x6d,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0x8d,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0xad,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0xcd,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0xed,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0x6c,
	0x4e , 0x03,
		//0x4c , 0x01,
		//0x4d , 0xed,
		//0x4e , 0x03,//skin
	0x4c , 0x01,
	0x4d , 0x8c,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0xac,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0xcc,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0xec,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0x6b,
	0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0x8b,
	0x4e , 0x03,//skin
		//0x4c , 0x01,
		//0x4d , 0xab,
		//0x4e , 0x03,
		//0x4c , 0x01,
		//0x4d , 0xcb,
		//0x4e , 0x03,
		//0x4c , 0x01,
		//0x4d , 0xeb,
		//0x4e , 0x03,
	0x4c , 0x01,
	0x4d , 0x8a,
	0x4e , 0x03,
									   
		//0x4c , 0x02,
		//0x4d , 0x2b,
		//0x4e , 0x03,
		//0x4c , 0x02,
		//0x4d , 0x4b,
		//0x4e , 0x03,
		
	0x4c , 0x01, // CWF
	0x4d , 0xaa,
	0x4e , 0x04,
	0x4c , 0x01, // CWF
	0x4d , 0xab,
	0x4e , 0x04,
	0x4c , 0x01, // CWF
	0x4d , 0xcb,
	0x4e , 0x04,
	0x4c , 0x01, // CWF
	0x4d , 0xa9,
	0x4e , 0x04,
	0x4c , 0x01,
	0x4d , 0xca,
	0x4e , 0x04,
	0x4c , 0x01,
	0x4d , 0xc9,
	0x4e , 0x04,
	0x4c , 0x01,
	0x4d , 0x8a,
	0x4e , 0x04,
	0x4c , 0x01,
	0x4d , 0x89,
	0x4e , 0x04,
	0x4c , 0x01, // TL84
	0x4d , 0xeb,
	0x4e , 0x05,
	0x4c , 0x02,
	0x4d , 0x0b,
	0x4e , 0x05,
	0x4c , 0x02,
	0x4d , 0x0c,
	0x4e , 0x05,
	0x4c , 0x02,
	0x4d , 0x2c,
	0x4e , 0x05,
	0x4c , 0x02,
	0x4d , 0x2b,
	0x4e , 0x05,
	0x4c , 0x01,
	0x4d , 0xea,
	0x4e , 0x05,
	0x4c , 0x02,
	0x4d , 0x0a,
	0x4e , 0x05,
		
	0x4c , 0x02,
	0x4d , 0x8b,
	0x4e , 0x06,
	0x4c , 0x02,
	0x4d , 0x2a,
	0x4e , 0x06,
	0x4c , 0x02,
	0x4d , 0x4a,
	0x4e , 0x06,
	0x4c , 0x02,
	0x4d , 0x6a,
	0x4e , 0x06,
	0x4c , 0x02,
	0x4d , 0x8a,
	0x4e , 0x06,
	0x4c , 0x02,
	0x4d , 0xaa,
	0x4e , 0x06,
	0x4c , 0x02,
	0x4d , 0x09,
	0x4e , 0x06,
	0x4c , 0x02,
	0x4d , 0x29,
	0x4e , 0x06,
	0x4c , 0x02,
	0x4d , 0x49,
	0x4e , 0x06,
	0x4c , 0x02,
	0x4d , 0x69,
	0x4e , 0x06,
	0x4c , 0x02, // H
	0x4d , 0xcc,
	0x4e , 0x07,
	0x4c , 0x02,
	0x4d , 0xca,
	0x4e , 0x07,
	0x4c , 0x02,
	0x4d , 0xa9,
	0x4e , 0x07,
	0x4c , 0x02,
	0x4d , 0xc9,
	0x4e , 0x07,
	0x4c , 0x02,
	0x4d , 0xe9,
	0x4e , 0x07,
		
	0x4f , 0x01,
	0x50 , 0x80,
	0x51 , 0xa8,
	0x52 , 0x47,
	0x53 , 0x38,
	0x54 , 0xc7,
	0x56 , 0x0e,
	0x58 , 0x08,
	0x5b , 0x00,
	0x5c , 0x74,
	0x5d , 0x8b,
	0x61 , 0xdb,
	0x62 , 0xb8,
	0x63 , 0x86,
	0x64 , 0xc0,
	0x65 , 0x04,
		
	0x67 , 0xa8,
	0x68 , 0xb0,
	0x69 , 0x00,
	0x6a , 0xa8,
	0x6b , 0xb0,
	0x6c , 0xaf,
	0x6d , 0x8b,
	0x6e , 0x50,
	0x6f , 0x18,
	0x73 , 0xe0,
	0x70 , 0x0d,
	0x71 , 0x68,
	0x72 , 0x81,
	0x74 , 0x01,
	0x75 , 0x01,
	0x7f , 0x0c,
	0x76 , 0x70,
	0x77 , 0x58,
	0x78 , 0xa0,
	0x79 , 0x5e,
	0x7a , 0x54,
	0x7b , 0x55,										
	0xfe , 0x00,
#endif

#if 0
0xfe, 0x01,
0x4f, 0x00,
0x4f, 0x00,
0x4b, 0x01,
0x4f, 0x00,
0x4c, 0x01, // D75
0x4d, 0x71,
0x4e, 0x01,
0x4c, 0x01,
0x4d, 0x91,
0x4e, 0x01,
0x4c, 0x01,
0x4d, 0x70,
0x4e, 0x01,
0x4c, 0x01, // D65
0x4d, 0x90,
0x4e, 0x02,
0x4c, 0x01,
0x4d, 0x8f,
0x4e, 0x02,
0x4c, 0x01,
0x4d, 0xb0,
0x4e, 0x02,
0x4c, 0x01,
0x4d, 0xaf,
0x4e, 0x02,
0x4c, 0x01,
0x4d, 0x6f,
0x4e, 0x02,
0x4c, 0x01, // D50
0x4d, 0xad,
0x4e, 0x33,
0x4c, 0x01,
0x4d, 0xae,
0x4e, 0x33,
0x4c, 0x01,
0x4d, 0x8c,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0xac,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0xcd,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0x8e,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0x8d,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0x8b,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0x6a,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0x6b,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0x6c,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0x6d,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0x6e,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0xab,
0x4e, 0x03,
0x4c, 0x01,
0x4d, 0xcb,
0x4e, 0x03,
0x4c, 0x01, // CWF
0x4d, 0xaa,
0x4e, 0x04,
0x4c, 0x01, // CWF
0x4d, 0xa9,
0x4e, 0x04,
0x4c, 0x01,
0x4d, 0xca,
0x4e, 0x04,
0x4c, 0x01,
0x4d, 0xc9,
0x4e, 0x04,
0x4c, 0x01,
0x4d, 0x8a,
0x4e, 0x04,
0x4c, 0x01,
0x4d, 0x89,
0x4e, 0x04,
0x4c, 0x02,
0x4d, 0x0b,
0x4e, 0x05,
0x4c, 0x02,
0x4d, 0x0a,
0x4e, 0x05,
0x4c, 0x02,
0x4d, 0x2a,
0x4e, 0x05,
0x4c, 0x02, // A
0x4d, 0x6a,
0x4e, 0x06,
0x4c, 0x02,
0x4d, 0x69,
0x4e, 0x06,
0x4c, 0x02,
0x4d, 0x29,
0x4e, 0x06,
0x4c, 0x02,
0x4d, 0x09,
0x4e, 0x06,
0x4c, 0x02,
0x4d, 0x49,
0x4e, 0x06,
0x4c, 0x02, // H
0x4d, 0xc9,
0x4e, 0x07,
0x4c, 0x02,
0x4d, 0xc8,
0x4e, 0x07,
0x4c, 0x02,
0x4d, 0x68,
0x4e, 0x07,
0x4c, 0x02,
0x4d, 0xa8,
0x4e, 0x07,
0x4c, 0x02,
0x4d, 0x88,
0x4e, 0x07,
0x4f, 0x01,
0x50, 0x80, 
0x51, 0xa8,
0x52, 0x57,
0x53, 0x38,
0x54, 0xc7,
0x56, 0x0e,
0x58, 0x09,
0x5b, 0x00,
0x5c, 0x74,
0x5d, 0x8b,
0x61, 0xa7,
0x62, 0xb5,
0x63, 0xaa,
0x64, 0x80,
0x65, 0x04,
0x67, 0xa4,
0x68, 0xb0,
0x69, 0x00,
0x6a, 0xa4,
0x6b, 0xb0, 
0x6c, 0xb2, 
0x6d, 0xac, 
0x6e, 0x60, 
0x6f, 0x15,
0x73, 0x0f, 
0x70, 0x10, 
0x71, 0xe8, 
0x72, 0xc0, 
0x74, 0x01, 
0x75, 0x01, 
0x7f, 0x08, 
0x76, 0x70, 
0x77, 0x58, 
0x78, 0xa0, 
0xfe, 0x00,
#endif
	//////////////////////////////////////////
	///////////  CC   ////////////////////////
	//////////////////////////////////////////
0xfe, 0x02,
0xc0, 0x01,
0xC1, 0x44,
0xc2, 0xF4,
0xc3, 0x02,
0xc4, 0xf2,
0xc5, 0x44,
0xc6, 0xf8,
0xC7, 0x50,
0xc8, 0xf2,
0xc9, 0x00,
0xcA, 0xE0,
0xcB, 0x45,
0xcC, 0xec,
0xCd, 0x45,
0xce, 0xf0,
0xcf, 0x00,
0xe3, 0xf0,
0xe4, 0x45,
0xe5, 0xe8,
	
	///////output//////////////////////////
0xfe, 0x00,
0xf2, 0x0f,

	////////////////dark  sun//////////////
0x18, 0x22,
0xfe, 0x02,
0x40, 0xbf,
0x46, 0xcf,
0xfe, 0x00,

	//////////////frame rate   50Hz
0xfe, 0x00,
0x05, 0x01,
0x06, 0x56,
0x07, 0x00,
0x08, 0x32,
0xfe, 0x01,
0x25, 0x00,
0x26, 0xfa,
0x27, 0x04,
0x28, 0xe2,
0x29, 0x05,
0x2a, 0xdc,
0x2b, 0x06,
0x2c, 0xd6,
0x2d, 0x0b,
0x2e, 0xb8,
0xfe, 0x00,

/////SVGA SETTING//

	0xfe , 0x00,
	0xfa , 0x00,
	0xfd , 0x01, 
	//// crop window              
	0xfe , 0x00,
	0x99 , 0x22,  // 1/2 subsample for 800x600 to 400x300
	0x9a , 0x06,  // Subsample mode - smooth chroma, average neighbors
	0x9b , 0x00,
	0x9c , 0x00,
	0x9d , 0x00,
	0x9e , 0x00,
	0x9f , 0x00,
	0xa0 , 0x00,  
	0xa1 , 0x00,
	0xa2  ,0x00,
	
	0x90 , 0x01, // Crop out window
	0x91 , 0x00,
	0x92 , 0x00,
	0x93 , 0x00,
	0x94 , 0x00,
	
	0x95 , 0x01,  // Output window height
	0x96 , 0x28,  // NDM - this is 296 to stay divisible by 8 
  
	0x97 , 0x01,
	0x98 , 0x90,

	//// AWB                      
	0xfe , 0x00,
	0xec , 0x01, 
	0xed , 0x02,
	0xee , 0x30,
	0xef , 0x48,
	0xfe , 0x01,
	0x74 , 0x00, 
	//// AEC                      
	0xfe , 0x01,
	0x01 , 0x04,
	0x02 , 0x60,
	0x03 , 0x02,
	0x04 , 0x48,
	0x05 , 0x18,
	0x06 , 0x4c,
	0x07 , 0x14,
	0x08 , 0x36,
	
	0x0a , 0xc0, 
	0x21 , 0x14,
	0xfe , 0x00,
  
//  0xb6 , 0x00,  // P0: AEC off
//  0x03 , 0x00,  // P0: Exposure MSB
//  0x04 , 0x40,  // P0: Exposure LSB
  
          0, 0
        };

      // Set by the DMA Transfer Complete interrupt
      volatile bool m_isEOF = false;

      // Camera exposure value
      u32 m_exposure;

      bool m_enableVignettingCorrection;

      // DMA is limited to 256KB - 1
      const int TOTAL_COLS = 400, TOTAL_ROWS = 296, BUFFER_ROWS = 8, BYTES_PER_PIX = 2;
      const int BUFFER_SIZE = TOTAL_COLS * BUFFER_ROWS * BYTES_PER_PIX;  // 8 rows of YUYV (2 bytes each)
      ONCHIP u8 m_buffer[2][BUFFER_SIZE];   // Double buffer
      volatile int m_readyBuffer = 1, m_readyRow = -8;
     
      // Get raw data from the camera
      u8* CamGetRaw() { return m_buffer[m_readyBuffer]; }
      int CamGetReadyRow() { return m_readyRow; }

      void UARTPutHex(u8 c);
      
      // For self-test purposes only.
      static void CamSetPulls(GPIO_TypeDef* GPIOx, u32 pin, int index)
      {
        GPIO_InitTypeDef GPIO_InitStructure;
        GPIO_InitStructure.GPIO_PuPd = index ? GPIO_PuPd_UP : GPIO_PuPd_DOWN;
        GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
        GPIO_InitStructure.GPIO_Pin =  pin;
        GPIO_Init(GPIOx, &GPIO_InitStructure);
      }
      static int CamGetPulls(GPIO_TypeDef* GPIOx, u32 pin, int index)
      {
        return (!!(GPIO_READ(GPIOx) & pin)) << index;
      }
      static int CamReadDB(int pullup)
      {
        CamSetPulls(GPIO_D0, PIN_D0, pullup & 1);
        CamSetPulls(GPIO_D1, PIN_D1, pullup & 2);
        CamSetPulls(GPIO_D2, PIN_D2, pullup & 4);
        CamSetPulls(GPIO_D3, PIN_D3, pullup & 8);
        CamSetPulls(GPIO_D4, PIN_D4, pullup & 16);
        CamSetPulls(GPIO_D5, PIN_D5, pullup & 32);
        CamSetPulls(GPIO_D6, PIN_D6, pullup & 64);
        CamSetPulls(GPIO_D7, PIN_D7, pullup & 128);
        
        MicroWait(25);
        
        return
          CamGetPulls(GPIO_D0, PIN_D0, 0) |
          CamGetPulls(GPIO_D1, PIN_D1, 1) |
          CamGetPulls(GPIO_D2, PIN_D2, 2) |
          CamGetPulls(GPIO_D3, PIN_D3, 3) |
          CamGetPulls(GPIO_D4, PIN_D4, 4) |
          CamGetPulls(GPIO_D5, PIN_D5, 5) |
          CamGetPulls(GPIO_D6, PIN_D6, 6) |
          CamGetPulls(GPIO_D7, PIN_D7, 7);
      }

      volatile int m_test = 0;
      
      void GC2145Init()
      {
        m_exposure = u32_MAX;
        m_enableVignettingCorrection = false;

        // Configure the camera interface
        DCMI_InitTypeDef DCMI_InitStructure;
        DCMI_InitStructure.DCMI_CaptureMode = DCMI_CaptureMode_Continuous;
        DCMI_InitStructure.DCMI_SynchroMode = DCMI_SynchroMode_Hardware;
        DCMI_InitStructure.DCMI_PCKPolarity = DCMI_PCKPolarity_Falling;
        DCMI_InitStructure.DCMI_VSPolarity = DCMI_VSPolarity_Low;
        DCMI_InitStructure.DCMI_HSPolarity = DCMI_HSPolarity_High;
        DCMI_InitStructure.DCMI_CaptureRate = DCMI_CaptureRate_All_Frame;
        DCMI_InitStructure.DCMI_ExtendedDataMode = DCMI_ExtendedDataMode_8b;
        DCMI_Init(&DCMI_InitStructure);

        // Read ID regs to get I2C state machine into proper state
        I2CInit();
        I2CRead(I2C_ADDR, 0xf0);
        I2CRead(I2C_ADDR, 0xf1);
        
        // Write the configuration registers        
        unsigned short* p = m_camScript;
        while (*p) {
          I2CWrite(I2C_ADDR, p[0], p[1]);
          p += 2;
        }

        // Configure DMA2_Stream1 channel 1 for DMA from DCMI->DR to RAM
        DMA_DeInit(DMA2_Stream1);
        DMA_InitTypeDef DMA_InitStructure;
        DMA_InitStructure.DMA_Channel = DMA_Channel_1;
        DMA_InitStructure.DMA_PeripheralBaseAddr = (u32)&DCMI->DR;
        DMA_InitStructure.DMA_Memory0BaseAddr = (u32)m_buffer[0];
        DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
        DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE / 4;  // numBytes / sizeof(word)
        DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
        DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
        DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
        DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
        DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
        DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
        DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Enable;
        DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_Full;
        DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
        DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
        DMA_Init(DMA2_Stream1, &DMA_InitStructure);
        
        // Set up double buffering
        DMA_DoubleBufferModeConfig(DMA2_Stream1, (u32)m_buffer[1], DMA_Memory_0);
        DMA_DoubleBufferModeCmd(DMA2_Stream1, ENABLE);

        // Enable the DMA interrupt for transfer complete to give enough time
        // between frames to do some extra work
        DMA_ITConfig(DMA2_Stream1, DMA_IT_TC, ENABLE);

        NVIC_InitTypeDef NVIC_InitStructure;
        NVIC_InitStructure.NVIC_IRQChannel = DMA2_Stream1_IRQn;
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
        NVIC_Init(&NVIC_InitStructure);
        
        __disable_irq();
        
        // Wait for VSYNC before enabling capture
        while ((GPIO_READ(GPIO_VSYNC) & PIN_VSYNC))
          ;
        while (!(GPIO_READ(GPIO_VSYNC) & PIN_VSYNC))
          ;
        while ((GPIO_READ(GPIO_VSYNC) & PIN_VSYNC))
          ;
        
        for (int i = 0; i < 4; i++)
        {
          while (!(GPIO_READ(GPIO_HSYNC) & PIN_HSYNC))
            ;
          while ((GPIO_READ(GPIO_HSYNC) & PIN_HSYNC))
            ;          
        }
        
        // Enable DMA
        DMA_Cmd(DMA2_Stream1, ENABLE);

        // Enable DCMI
        DCMI_Cmd(ENABLE);

        // Enable the DCMI peripheral to capture frames from vsync
        DCMI_CaptureCmd(ENABLE);
        
        __enable_irq();
      }

      void FrontCameraInit()
      {
        // Clock configuration
        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOG, ENABLE);
        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOI, ENABLE);

        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
        RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_DCMI, ENABLE);
        RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM9, ENABLE);
        
        // TODO: Check that the GPIOs are okay
        //for (u8 i = 1; i; i <<= 1)
        //  printf("\r\nCam dbus: set %x, got %x", i, CamReadDB(i));        

        // Configure the pins for DCMI in AF mode
        GPIO_PinAFConfig(GPIO_D0, SOURCE_D0, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_D1, SOURCE_D1, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_D2, SOURCE_D2, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_D3, SOURCE_D3, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_D4, SOURCE_D4, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_D5, SOURCE_D5, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_D6, SOURCE_D6, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_D7, SOURCE_D7, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_VSYNC, SOURCE_VSYNC, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_HSYNC, SOURCE_HSYNC, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_PCLK, SOURCE_PCLK, GPIO_AF_DCMI);
        GPIO_PinAFConfig(GPIO_XCLK, SOURCE_XCLK, GPIO_AF_TIM9);

        // Initialize the camera pins
        GPIO_InitTypeDef GPIO_InitStructure;
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
        GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
        GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

        GPIO_InitStructure.GPIO_Pin = PIN_D0 | PIN_D1 | PIN_HSYNC | PIN_PCLK | PIN_XCLK;
        GPIO_Init(GPIOA, &GPIO_InitStructure);

        GPIO_InitStructure.GPIO_Pin = PIN_D2 | PIN_D3;
        GPIO_Init(GPIOG, &GPIO_InitStructure);

        GPIO_InitStructure.GPIO_Pin = PIN_D4;
        GPIO_Init(GPIOE, &GPIO_InitStructure);

        GPIO_InitStructure.GPIO_Pin = PIN_D5 | PIN_D6 | PIN_D7 | PIN_VSYNC;
        GPIO_Init(GPIOI, &GPIO_InitStructure);

        // PWDN and RESET_N are normal GPIO
        GPIO_SET(GPIO_PWDN, PIN_PWDN);          // PWDN starts high
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
        GPIO_InitStructure.GPIO_Pin = PIN_PWDN;
        GPIO_Init(GPIO_PWDN, &GPIO_InitStructure);
        
        GPIO_RESET(GPIO_RESET_N, PIN_RESET_N);  // RESET_N starts low
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
        GPIO_InitStructure.GPIO_Pin = PIN_RESET_N;
        GPIO_Init(GPIO_RESET_N, &GPIO_InitStructure);

        // Configure XCLK for 12 MHz (unevenly divisible by 180 MHz)
        TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
        TIM_OCInitTypeDef  TIM_OCInitStructure;

        TIM_TimeBaseStructure.TIM_Prescaler = 0;
        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
        TIM_TimeBaseStructure.TIM_ClockDivision = 0;
        TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;

        TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
        TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
        TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
        TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
        TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
        TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
        TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;

        // XXX-NDM:  I screwed up the duty cycle here to get 10.6MHz - 15fps at 400x300, so shoot me
        TIM_TimeBaseStructure.TIM_Period = 16;  // clockFrequency = 180MHz / (period+1)
        TIM_OCInitStructure.TIM_Pulse = 9;     // pulse = (period+1) / 2

        TIM_TimeBaseInit(TIM9, &TIM_TimeBaseStructure);
        TIM_OC2Init(TIM9, &TIM_OCInitStructure);
        TIM_Cmd(TIM9, ENABLE);
        TIM_CtrlPWMOutputs(TIM9, ENABLE);

        // With clock running, power-up/reset the camera
        MicroWait(50);
        GPIO_RESET(GPIO_PWDN, PIN_PWDN);
        MicroWait(50);
        GPIO_SET(GPIO_RESET_N, PIN_RESET_N);

        GC2145Init();
      }

      void CameraSetParameters(f32 exposure, bool enableVignettingCorrection)
      {
        //TODO: vignetting correction
        
        const f32 maxExposure = 0xf00; // Determined empirically
        
        f32 correctedExposure = exposure;
        
        if(exposure < 0.0f)
        {
          correctedExposure = 0;
        } else if(exposure > 1.0f)
        {
          correctedExposure = 1.0f;
        } 
        
        const u32 exposureU32 = (u32) floorf(correctedExposure * maxExposure + 0.5f);
        
        if (m_exposure != exposureU32)
        {
          m_exposure = exposureU32;
          
          //CamWrite(0x3501, (exposureU32 >> 8) & 0xFF);
          MicroWait(100);
          //CamWrite(0x3502, exposureU32 & 0xFF);
        }

        if(enableVignettingCorrection) {
          AnkiAssert(false);
        }
      }

      void CameraGetFrame(u8* frame, ImageResolution res, bool enableLight)
      {
        m_isEOF = false;

        // Wait until the frame has completed (based on DMA_FLAG_TCIF1)
        while (!m_isEOF)
        {  
        }
        
        return;
      }

      const CameraInfo* GetHeadCamInfo(void)
      {
        static CameraInfo s_headCamInfo = {
          HEAD_CAM_CALIB_FOCAL_LENGTH_X,
          HEAD_CAM_CALIB_FOCAL_LENGTH_Y,
          HEAD_CAM_CALIB_CENTER_X,
          HEAD_CAM_CALIB_CENTER_Y,
          0.f,
          HEAD_CAM_CALIB_HEIGHT,
          HEAD_CAM_CALIB_WIDTH
        };

        return &s_headCamInfo;
      }
    }
  }
}

extern "C"
void DMA2_Stream1_IRQHandler(void)
{
  using namespace Anki::Cozmo::HAL;

  // Clear the DMA Transfer Complete flag
  //DMA_ClearFlag(DMA2_Stream1, DMA_FLAG_TCIF1);
  DMA2->LIFCR = DMA_FLAG_TCIF1 & 0x0F7D0F7D;  // Direct version of call above

  m_readyBuffer = !m_readyBuffer;   // Other buffer is now the ready one
  m_readyRow += BUFFER_ROWS;        // A new row is now ready
  if (m_readyRow >= TOTAL_ROWS)
    m_readyRow = 0;
}
