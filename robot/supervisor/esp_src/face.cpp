#include "face.h"
#include "messages.h"
#include "anki/cozmo/robot/faceDisplayDecode.h"
#include "anki/cozmo/robot/esp.h"
#include <stdarg.h>

namespace Anki {
namespace Cozmo {
namespace Face {

#define COLS 128
#define ROWS 64

  namespace { // Anonymous namespace for "private" members
    u64 m_frame[COLS];
    s16 _pumpByte;
    bool _textMode;
    
    // 96 characters from ASCII 32 to 127, each 5x8 pixels in 5 bytes oriented vertically
    const int CHAR_WIDTH = 5, CHAR_HEIGHT = 8, CHAR_START = 32, CHAR_END = 127;
    static const u8 FONT[] = {
       0x00,0x00,0x00,0x00,0x00, 0x00,0x00,0x5F,0x00,0x00, 0x00,0x07,0x00,0x07,0x00, 0x14,0x7F,0x14,0x7F,0x14,
       0x24,0x2A,0x7F,0x2A,0x12, 0x23,0x13,0x08,0x64,0x62, 0x36,0x49,0x56,0x20,0x50, 0x00,0x08,0x07,0x03,0x00,
       0x00,0x1C,0x22,0x41,0x00, 0x00,0x41,0x22,0x1C,0x00, 0x2A,0x1C,0x7F,0x1C,0x2A, 0x08,0x08,0x3E,0x08,0x08,
       0x00,0x80,0x70,0x30,0x00, 0x08,0x08,0x08,0x08,0x08, 0x00,0x00,0x60,0x60,0x00, 0x20,0x10,0x08,0x04,0x02,
       0x3E,0x51,0x49,0x45,0x3E, 0x00,0x42,0x7F,0x40,0x00, 0x72,0x49,0x49,0x49,0x46, 0x21,0x41,0x49,0x4D,0x33,
       0x18,0x14,0x12,0x7F,0x10, 0x27,0x45,0x45,0x45,0x39, 0x3C,0x4A,0x49,0x49,0x31, 0x41,0x21,0x11,0x09,0x07,
       0x36,0x49,0x49,0x49,0x36, 0x46,0x49,0x49,0x29,0x1E, 0x00,0x00,0x14,0x00,0x00, 0x00,0x40,0x34,0x00,0x00,
       0x00,0x08,0x14,0x22,0x41, 0x14,0x14,0x14,0x14,0x14, 0x00,0x41,0x22,0x14,0x08, 0x02,0x01,0x59,0x09,0x06,
       0x3E,0x41,0x5D,0x59,0x4E, 0x7C,0x12,0x11,0x12,0x7C, 0x7F,0x49,0x49,0x49,0x36, 0x3E,0x41,0x41,0x41,0x22,
       0x7F,0x41,0x41,0x41,0x3E, 0x7F,0x49,0x49,0x49,0x41, 0x7F,0x09,0x09,0x09,0x01, 0x3E,0x41,0x41,0x51,0x73,
       0x7F,0x08,0x08,0x08,0x7F, 0x00,0x41,0x7F,0x41,0x00, 0x20,0x40,0x41,0x3F,0x01, 0x7F,0x08,0x14,0x22,0x41,
       0x7F,0x40,0x40,0x40,0x40, 0x7F,0x02,0x1C,0x02,0x7F, 0x7F,0x04,0x08,0x10,0x7F, 0x3E,0x41,0x41,0x41,0x3E,
       0x7F,0x09,0x09,0x09,0x06, 0x3E,0x41,0x51,0x21,0x5E, 0x7F,0x09,0x19,0x29,0x46, 0x26,0x49,0x49,0x49,0x32,
       0x03,0x01,0x7F,0x01,0x03, 0x3F,0x40,0x40,0x40,0x3F, 0x1F,0x20,0x40,0x20,0x1F, 0x3F,0x40,0x38,0x40,0x3F,
       0x63,0x14,0x08,0x14,0x63, 0x03,0x04,0x78,0x04,0x03, 0x61,0x59,0x49,0x4D,0x43, 0x00,0x7F,0x41,0x41,0x41,
       0x02,0x04,0x08,0x10,0x20, 0x00,0x41,0x41,0x41,0x7F, 0x04,0x02,0x01,0x02,0x04, 0x40,0x40,0x40,0x40,0x40,
       0x00,0x03,0x07,0x08,0x00, 0x20,0x54,0x54,0x78,0x40, 0x7F,0x28,0x44,0x44,0x38, 0x38,0x44,0x44,0x44,0x28,
       0x38,0x44,0x44,0x28,0x7F, 0x38,0x54,0x54,0x54,0x18, 0x00,0x08,0x7E,0x09,0x02, 0x18,0xA4,0xA4,0x9C,0x78,
       0x7F,0x08,0x04,0x04,0x78, 0x00,0x44,0x7D,0x40,0x00, 0x20,0x40,0x40,0x3D,0x00, 0x7F,0x10,0x28,0x44,0x00,
       0x00,0x41,0x7F,0x40,0x00, 0x7C,0x04,0x78,0x04,0x78, 0x7C,0x08,0x04,0x04,0x78, 0x38,0x44,0x44,0x44,0x38,
       0xFC,0x18,0x24,0x24,0x18, 0x18,0x24,0x24,0x18,0xFC, 0x7C,0x08,0x04,0x04,0x08, 0x48,0x54,0x54,0x54,0x24,
       0x04,0x04,0x3F,0x44,0x24, 0x3C,0x40,0x40,0x20,0x7C, 0x1C,0x20,0x40,0x20,0x1C, 0x3C,0x40,0x30,0x40,0x3C,
       0x44,0x28,0x10,0x28,0x44, 0x4C,0x90,0x90,0x90,0x7C, 0x44,0x64,0x54,0x4C,0x44, 0x00,0x08,0x36,0x41,0x00,
       0x00,0x00,0x77,0x00,0x00, 0x00,0x41,0x36,0x08,0x00, 0x02,0x01,0x02,0x04,0x02, 0x3C,0x26,0x23,0x26,0x3C
    };
  }
  
  Result Init()
  {
    memset(m_frame, 0, sizeof(m_frame));
    _pumpByte = 0;
    _textMode = false;
    return RESULT_OK;
  }
  
  void Update(AnimKeyFrame::FaceImage img)
  {
    if (_textMode) return; // Ignore when in text mode
    
    FaceDisplayDecode(img.image, ROWS, COLS, m_frame);
  }
  
  void Move(s8 xCenter, s8 yCenter)
  {
    // Stub, probably to be deleted later
  }
  
  // Blanks the screen momentarily
  void Blink()
  {
    // Stub, probably to be deleted later
  }
  
  // Enables or disables periodic blinking
  void EnableBlink(bool enable)
  {
    // Stub, probably to be deleted later
  }
  
  // Pump face buffer data out to OLED
  extern "C" u32 PumpScreenData()
  {
    u32 ret;
    memcpy(&ret, (u8*)m_frame + _pumpByte, SCREEN_BYTES_PER_DROP);
    _pumpByte += SCREEN_BYTES_PER_DROP;
    if (_pumpByte >= (ROWS * COLS / 8))
    {
      _pumpByte = 0;
    }
    return ret;
  }
  
  // Display text on the screen until turned off
  extern "C" void FacePrintf(const char *format, ...)
  {
    // Build the printf into a local buffer and zero-terminate it
    char buffer[256];
    va_list argptr;
    va_start(argptr, format);
    vsnprintf(buffer, sizeof(buffer)-1, format, argptr);
    va_end(argptr);
    buffer[sizeof(buffer)-1] = '\0';

    _textMode = true;

    // Build the result into the framebuffer
    int x = 0, y = 0;
    char* cptr = buffer;
    memset(m_frame, 0, sizeof(m_frame));

    // Go character by character until we hit the end
    while (*cptr)
    {
      // Wrap to next row, and bail out past bottom row
      int c = *cptr++;
      if (c == '\n' || x >= COLS / (CHAR_WIDTH+1))
      {
        x = 0;
        y++;
      }
      if (y >= ROWS / CHAR_HEIGHT)
        break;

      // Skip unrecognized chars
      if (c < CHAR_START || c > CHAR_END)
        continue;

      // Copy the character from the font buffer to the display buffer
      const u8* fptr = FONT + (c - CHAR_START) * CHAR_WIDTH;
      u8* gptr = (u8*)(m_frame) + y + x * (CHAR_WIDTH + 1) * (ROWS / CHAR_HEIGHT);
      for (int i = 0; i < CHAR_WIDTH; i++)
      {
        *gptr = *fptr++;
        gptr += ROWS / CHAR_HEIGHT;
      }
      x++;
    }
  }
  
  // Return display to normal function
  extern "C" void UnPrintf(void)
  {
    _textMode = false;
  }
  
  
} // Face
} // Cozmo
} // Anki
