; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_hash.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_hash.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_hash.crf arm_hal\lib\stm32f4xx_hash.c]
                          THUMB

                          AREA ||i.HASH_AutoStartDigest||, CODE, READONLY, ALIGN=2

                  HASH_AutoStartDigest PROC
;;;464      */
;;;465    void HASH_AutoStartDigest(FunctionalState NewState)
000000  4904              LDR      r1,|L1.20|
;;;466    {
;;;467      /* Check the parameters */
;;;468      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;469    
;;;470      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;471      {
;;;472        /* Enable the auto start of the final message digest at the end of DMA transfer */
;;;473        HASH->CR &= ~HASH_CR_MDMAT;
;;;474      }
;;;475      else
;;;476      {
;;;477        /* Disable the auto start of the final message digest at the end of DMA transfer */
;;;478        HASH->CR |= HASH_CR_MDMAT;
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;473
000008  f4205000          BICNE    r0,r0,#0x2000         ;473
00000c  f4405000          ORREQ    r0,r0,#0x2000
000010  6008              STR      r0,[r1,#0]            ;473
;;;479      }
;;;480    }
000012  4770              BX       lr
;;;481      
                          ENDP

                  |L1.20|
                          DCD      0x50060400

                          AREA ||i.HASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  HASH_ClearFlag PROC
;;;650      */
;;;651    void HASH_ClearFlag(uint32_t HASH_FLAG)
000000  4901              LDR      r1,|L2.8|
;;;652    {
;;;653      /* Check the parameters */
;;;654      assert_param(IS_HASH_CLEAR_FLAG(HASH_FLAG));
;;;655      
;;;656      /* Clear the selected HASH flags */
;;;657      HASH->SR = ~(uint32_t)HASH_FLAG;
000002  43c0              MVNS     r0,r0
000004  6008              STR      r0,[r1,#0]
;;;658    }
000006  4770              BX       lr
;;;659    /**
                          ENDP

                  |L2.8|
                          DCD      0x50060424

                          AREA ||i.HASH_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  HASH_ClearITPendingBit PROC
;;;700      */
;;;701    void HASH_ClearITPendingBit(uint32_t HASH_IT)
000000  4901              LDR      r1,|L3.8|
;;;702    {
;;;703      /* Check the parameters */
;;;704      assert_param(IS_HASH_IT(HASH_IT));
;;;705    
;;;706      /* Clear the selected HASH interrupt pending bit */
;;;707      HASH->SR = (uint32_t)(~HASH_IT);
000002  43c0              MVNS     r0,r0
000004  6008              STR      r0,[r1,#0]
;;;708    }
000006  4770              BX       lr
;;;709    
                          ENDP

                  |L3.8|
                          DCD      0x50060424

                          AREA ||i.HASH_DMACmd||, CODE, READONLY, ALIGN=2

                  HASH_DMACmd PROC
;;;488      */
;;;489    void HASH_DMACmd(FunctionalState NewState)
000000  4904              LDR      r1,|L4.20|
;;;490    {
;;;491      /* Check the parameters */
;;;492      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;493    
;;;494      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;495      {
;;;496        /* Enable the HASH DMA request */
;;;497        HASH->CR |= HASH_CR_DMAE;
;;;498      }
;;;499      else
;;;500      {
;;;501        /* Disable the HASH DMA request */
;;;502        HASH->CR &= ~HASH_CR_DMAE;
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;497
000008  f0400008          ORRNE    r0,r0,#8              ;497
00000c  f0200008          BICEQ    r0,r0,#8
000010  6008              STR      r0,[r1,#0]            ;497
;;;503      }
;;;504    }
000012  4770              BX       lr
;;;505    /**
                          ENDP

                  |L4.20|
                          DCD      0x50060400

                          AREA ||i.HASH_DataIn||, CODE, READONLY, ALIGN=2

                  HASH_DataIn PROC
;;;305      */
;;;306    void HASH_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L5.8|
;;;307    {
;;;308      /* Write in the DIN register a new data */
;;;309      HASH->DIN = Data;
000002  6008              STR      r0,[r1,#0]
;;;310    }
000004  4770              BX       lr
;;;311    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x50060404

                          AREA ||i.HASH_DeInit||, CODE, READONLY, ALIGN=1

                  HASH_DeInit PROC
;;;170      */
;;;171    void HASH_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;172    {
;;;173      /* Enable HASH reset state */
;;;174      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, ENABLE);
000002  2101              MOVS     r1,#1
000004  2020              MOVS     r0,#0x20
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;175      /* Release HASH from reset state */
;;;176      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_HASH, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  e8bd4010          POP      {r4,lr}
000010  2020              MOVS     r0,#0x20
000012  f7ffbffe          B.W      RCC_AHB2PeriphResetCmd
;;;177    }
;;;178    
                          ENDP


                          AREA ||i.HASH_GetDigest||, CODE, READONLY, ALIGN=2

                  HASH_GetDigest PROC
;;;334      */
;;;335    void HASH_GetDigest(HASH_MsgDigest* HASH_MessageDigest)
000000  490c              LDR      r1,|L7.52|
;;;336    {
;;;337      /* Get the data field */
;;;338      HASH_MessageDigest->Data[0] = HASH->HR[0];
000002  6809              LDR      r1,[r1,#0]
;;;339      HASH_MessageDigest->Data[1] = HASH->HR[1];
000004  6001              STR      r1,[r0,#0]
000006  490c              LDR      r1,|L7.56|
000008  6809              LDR      r1,[r1,#0]
;;;340      HASH_MessageDigest->Data[2] = HASH->HR[2];
00000a  6041              STR      r1,[r0,#4]
00000c  490b              LDR      r1,|L7.60|
00000e  6809              LDR      r1,[r1,#0]
;;;341      HASH_MessageDigest->Data[3] = HASH->HR[3];
000010  6081              STR      r1,[r0,#8]
000012  490b              LDR      r1,|L7.64|
000014  6809              LDR      r1,[r1,#0]
;;;342      HASH_MessageDigest->Data[4] = HASH->HR[4];
000016  60c1              STR      r1,[r0,#0xc]
000018  490a              LDR      r1,|L7.68|
00001a  6809              LDR      r1,[r1,#0]
;;;343      HASH_MessageDigest->Data[5] = HASH_DIGEST->HR[5];
00001c  6101              STR      r1,[r0,#0x10]
00001e  490a              LDR      r1,|L7.72|
000020  6809              LDR      r1,[r1,#0]
;;;344      HASH_MessageDigest->Data[6] = HASH_DIGEST->HR[6];
000022  6141              STR      r1,[r0,#0x14]
000024  4909              LDR      r1,|L7.76|
000026  6809              LDR      r1,[r1,#0]
;;;345      HASH_MessageDigest->Data[7] = HASH_DIGEST->HR[7];
000028  6181              STR      r1,[r0,#0x18]
00002a  4909              LDR      r1,|L7.80|
00002c  6809              LDR      r1,[r1,#0]
00002e  61c1              STR      r1,[r0,#0x1c]
;;;346    }
000030  4770              BX       lr
;;;347    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      0x5006040c
                  |L7.56|
                          DCD      0x50060410
                  |L7.60|
                          DCD      0x50060414
                  |L7.64|
                          DCD      0x50060418
                  |L7.68|
                          DCD      0x5006041c
                  |L7.72|
                          DCD      0x50060724
                  |L7.76|
                          DCD      0x50060728
                  |L7.80|
                          DCD      0x5006072c

                          AREA ||i.HASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetFlagStatus PROC
;;;609      */
;;;610    FlagStatus HASH_GetFlagStatus(uint32_t HASH_FLAG)
000000  2200              MOVS     r2,#0
;;;611    {
;;;612      FlagStatus bitstatus = RESET;
;;;613      uint32_t tempreg = 0;
;;;614    
;;;615      /* Check the parameters */
;;;616      assert_param(IS_HASH_GET_FLAG(HASH_FLAG));
;;;617    
;;;618      /* check if the FLAG is in CR register */
;;;619      if ((HASH_FLAG & HASH_FLAG_DINNE) != (uint32_t)RESET ) 
000002  f4105f80          TST      r0,#0x1000
;;;620      {
;;;621        tempreg = HASH->CR;
000006  bf14              ITE      NE
000008  4903              LDRNE    r1,|L8.24|
;;;622      }
;;;623      else /* The FLAG is in SR register */
;;;624      {
;;;625        tempreg = HASH->SR;
00000a  4904              LDREQ    r1,|L8.28|
00000c  6809              LDR      r1,[r1,#0]
;;;626      }
;;;627    
;;;628      /* Check the status of the specified HASH flag */
;;;629      if ((tempreg & HASH_FLAG) != (uint32_t)RESET)
00000e  4201              TST      r1,r0
;;;630      {
;;;631        /* HASH is set */
;;;632        bitstatus = SET;
000010  bf18              IT       NE
000012  2201              MOVNE    r2,#1
;;;633      }
;;;634      else
;;;635      {
;;;636        /* HASH_FLAG is reset */
;;;637        bitstatus = RESET;
;;;638      }
;;;639    
;;;640      /* Return the HASH_FLAG status */
;;;641      return  bitstatus;
000014  4610              MOV      r0,r2
;;;642    }
000016  4770              BX       lr
;;;643    /**
                          ENDP

                  |L8.24|
                          DCD      0x50060400
                  |L8.28|
                          DCD      0x50060424

                          AREA ||i.HASH_GetITStatus||, CODE, READONLY, ALIGN=2

                  HASH_GetITStatus PROC
;;;666      */
;;;667    ITStatus HASH_GetITStatus(uint32_t HASH_IT)
000000  4905              LDR      r1,|L9.24|
;;;668    {
000002  4602              MOV      r2,r0
;;;669      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;670      uint32_t tmpreg = 0;
;;;671    
;;;672      /* Check the parameters */
;;;673      assert_param(IS_HASH_GET_IT(HASH_IT));  
;;;674    
;;;675    
;;;676      /* Check the status of the specified HASH interrupt */
;;;677      tmpreg =  HASH->SR;
000006  6809              LDR      r1,[r1,#0]
;;;678    
;;;679      if (((HASH->IMR & tmpreg) & HASH_IT) != RESET)
000008  4b04              LDR      r3,|L9.28|
00000a  681b              LDR      r3,[r3,#0]
00000c  4011              ANDS     r1,r1,r2
00000e  420b              TST      r3,r1
;;;680      {
;;;681        /* HASH_IT is set */
;;;682        bitstatus = SET;
000010  bf18              IT       NE
000012  2001              MOVNE    r0,#1
;;;683      }
;;;684      else
;;;685      {
;;;686        /* HASH_IT is reset */
;;;687        bitstatus = RESET;
;;;688      }
;;;689      /* Return the HASH_IT status */
;;;690      return bitstatus;
;;;691    }
000014  4770              BX       lr
;;;692    
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x50060424
                  |L9.28|
                          DCD      0x50060420

                          AREA ||i.HASH_GetInFIFOWordsNbr||, CODE, READONLY, ALIGN=2

                  HASH_GetInFIFOWordsNbr PROC
;;;316      */
;;;317    uint8_t HASH_GetInFIFOWordsNbr(void)
000000  4802              LDR      r0,|L10.12|
;;;318    {
;;;319      /* Return the value of NBW bits */
;;;320      return ((HASH->CR & HASH_CR_NBW) >> 8);
000002  6800              LDR      r0,[r0,#0]
000004  f3c02003          UBFX     r0,r0,#8,#4
;;;321    }
000008  4770              BX       lr
;;;322    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x50060400

                          AREA ||i.HASH_ITConfig||, CODE, READONLY, ALIGN=2

                  HASH_ITConfig PROC
;;;580      */
;;;581    void HASH_ITConfig(uint32_t HASH_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L11.20|
;;;582    {
;;;583      /* Check the parameters */
;;;584      assert_param(IS_HASH_IT(HASH_IT));
;;;585      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;586    
;;;587      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;588      {
;;;589        /* Enable the selected HASH interrupt */
;;;590        HASH->IMR |= HASH_IT;
;;;591      }
;;;592      else
;;;593      {
;;;594        /* Disable the selected HASH interrupt */
;;;595        HASH->IMR &= (uint32_t)(~HASH_IT);
000004  6811              LDR      r1,[r2,#0]
000006  bf14              ITE      NE                    ;590
000008  4308              ORRNE    r0,r0,r1              ;590
00000a  ea210000          BICEQ    r0,r1,r0
00000e  6010              STR      r0,[r2,#0]            ;590
;;;596      }
;;;597    }
000010  4770              BX       lr
;;;598    
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x50060420

                          AREA ||i.HASH_Init||, CODE, READONLY, ALIGN=2

                  HASH_Init PROC
;;;190      */
;;;191    void HASH_Init(HASH_InitTypeDef* HASH_InitStruct)
000000  490f              LDR      r1,|L12.64|
;;;192    {
;;;193      /* Check the parameters */
;;;194      assert_param(IS_HASH_ALGOSELECTION(HASH_InitStruct->HASH_AlgoSelection));
;;;195      assert_param(IS_HASH_DATATYPE(HASH_InitStruct->HASH_DataType));
;;;196      assert_param(IS_HASH_ALGOMODE(HASH_InitStruct->HASH_AlgoMode));
;;;197      
;;;198      /* Configure the Algorithm used, algorithm mode and the datatype */
;;;199      HASH->CR &= ~ (HASH_CR_ALGO | HASH_CR_DATATYPE | HASH_CR_MODE);
000002  680a              LDR      r2,[r1,#0]
000004  f02202f0          BIC      r2,r2,#0xf0
000008  f4222280          BIC      r2,r2,#0x40000
00000c  600a              STR      r2,[r1,#0]
;;;200      HASH->CR |= (HASH_InitStruct->HASH_AlgoSelection | \
00000e  680a              LDR      r2,[r1,#0]
000010  6803              LDR      r3,[r0,#0]
000012  431a              ORRS     r2,r2,r3
000014  e9d0c301          LDRD     r12,r3,[r0,#4]
000018  ea43030c          ORR      r3,r3,r12
00001c  431a              ORRS     r2,r2,r3
00001e  600a              STR      r2,[r1,#0]
;;;201                   HASH_InitStruct->HASH_DataType | \
;;;202                   HASH_InitStruct->HASH_AlgoMode);
;;;203      
;;;204      /* if algorithm mode is HMAC, set the Key */  
;;;205      if(HASH_InitStruct->HASH_AlgoMode == HASH_AlgoMode_HMAC) 
000020  6842              LDR      r2,[r0,#4]
000022  2a40              CMP      r2,#0x40
000024  d107              BNE      |L12.54|
;;;206      {
;;;207        assert_param(IS_HASH_HMAC_KEYTYPE(HASH_InitStruct->HASH_HMACKeyType));
;;;208        HASH->CR &= ~HASH_CR_LKEY;
000026  680a              LDR      r2,[r1,#0]
000028  f4223280          BIC      r2,r2,#0x10000
00002c  600a              STR      r2,[r1,#0]
;;;209        HASH->CR |= HASH_InitStruct->HASH_HMACKeyType;
00002e  680a              LDR      r2,[r1,#0]
000030  68c0              LDR      r0,[r0,#0xc]
000032  4310              ORRS     r0,r0,r2
000034  6008              STR      r0,[r1,#0]
                  |L12.54|
;;;210      }
;;;211    
;;;212      /* Reset the HASH processor core, so that the HASH will be ready to compute 
;;;213         the message digest of a new message */
;;;214      HASH->CR |= HASH_CR_INIT;  
000036  6808              LDR      r0,[r1,#0]
000038  f0400004          ORR      r0,r0,#4
00003c  6008              STR      r0,[r1,#0]
;;;215    }
00003e  4770              BX       lr
;;;216    
                          ENDP

                  |L12.64|
                          DCD      0x50060400

                          AREA ||i.HASH_Reset||, CODE, READONLY, ALIGN=2

                  HASH_Reset PROC
;;;248      */
;;;249    void HASH_Reset(void)
000000  4802              LDR      r0,|L13.12|
;;;250    {
;;;251      /* Reset the HASH processor core */
;;;252      HASH->CR |= HASH_CR_INIT;
000002  6801              LDR      r1,[r0,#0]
000004  f0410104          ORR      r1,r1,#4
000008  6001              STR      r1,[r0,#0]
;;;253    }
00000a  4770              BX       lr
;;;254    /**
                          ENDP

                  |L13.12|
                          DCD      0x50060400

                          AREA ||i.HASH_RestoreContext||, CODE, READONLY, ALIGN=2

                  HASH_RestoreContext PROC
;;;417      */
;;;418    void HASH_RestoreContext(HASH_Context* HASH_ContextRestore)  
000000  4b0e              LDR      r3,|L14.60|
;;;419    {
;;;420      uint8_t i = 0;
;;;421      
;;;422      /* restore context registers */
;;;423      HASH->IMR = HASH_ContextRestore->HASH_IMR;   
000002  6802              LDR      r2,[r0,#0]
000004  2100              MOVS     r1,#0                 ;420
000006  601a              STR      r2,[r3,#0]
;;;424      HASH->STR = HASH_ContextRestore->HASH_STR;     
000008  4b0d              LDR      r3,|L14.64|
00000a  6842              LDR      r2,[r0,#4]
00000c  601a              STR      r2,[r3,#0]
;;;425      HASH->CR = HASH_ContextRestore->HASH_CR;
00000e  4a0d              LDR      r2,|L14.68|
000010  6883              LDR      r3,[r0,#8]
000012  6013              STR      r3,[r2,#0]
;;;426      
;;;427      /* Initialize the hash processor */
;;;428      HASH->CR |= HASH_CR_INIT; 
000014  6813              LDR      r3,[r2,#0]
000016  f0430304          ORR      r3,r3,#4
00001a  6013              STR      r3,[r2,#0]
                  |L14.28|
;;;429      
;;;430       /* continue restoring context registers */     
;;;431      for(i=0; i<=53;i++)
;;;432      {
;;;433         HASH->CSR[i] = HASH_ContextRestore->HASH_CSR[i];
00001c  008b              LSLS     r3,r1,#2
00001e  eb000281          ADD      r2,r0,r1,LSL #2
000022  f10343a0          ADD      r3,r3,#0x50000000
000026  f50323c0          ADD      r3,r3,#0x60000
00002a  68d2              LDR      r2,[r2,#0xc]
00002c  f8c324f8          STR      r2,[r3,#0x4f8]
000030  1c49              ADDS     r1,r1,#1
000032  b2c9              UXTB     r1,r1                 ;431
000034  2935              CMP      r1,#0x35              ;431
000036  d9f1              BLS      |L14.28|
;;;434      }   
;;;435    }
000038  4770              BX       lr
;;;436    /**
                          ENDP

00003a  0000              DCW      0x0000
                  |L14.60|
                          DCD      0x50060420
                  |L14.64|
                          DCD      0x50060408
                  |L14.68|
                          DCD      0x50060400

                          AREA ||i.HASH_SaveContext||, CODE, READONLY, ALIGN=2

                  HASH_SaveContext PROC
;;;395      */
;;;396    void HASH_SaveContext(HASH_Context* HASH_ContextSave)
000000  4a0c              LDR      r2,|L15.52|
;;;397    {
;;;398      uint8_t i = 0;
000002  2100              MOVS     r1,#0
;;;399      
;;;400      /* save context registers */
;;;401      HASH_ContextSave->HASH_IMR = HASH->IMR;  
000004  6812              LDR      r2,[r2,#0]
;;;402      HASH_ContextSave->HASH_STR = HASH->STR;      
000006  6002              STR      r2,[r0,#0]
000008  4a0b              LDR      r2,|L15.56|
00000a  6812              LDR      r2,[r2,#0]
;;;403      HASH_ContextSave->HASH_CR  = HASH->CR;     
00000c  6042              STR      r2,[r0,#4]
00000e  4a0b              LDR      r2,|L15.60|
000010  6812              LDR      r2,[r2,#0]
000012  6082              STR      r2,[r0,#8]
                  |L15.20|
;;;404      for(i=0; i<=53;i++)
;;;405      {
;;;406         HASH_ContextSave->HASH_CSR[i] = HASH->CSR[i];
000014  008a              LSLS     r2,r1,#2
000016  f10242a0          ADD      r2,r2,#0x50000000
00001a  f50222c0          ADD      r2,r2,#0x60000
00001e  f8d224f8          LDR      r2,[r2,#0x4f8]
000022  eb000381          ADD      r3,r0,r1,LSL #2
000026  1c49              ADDS     r1,r1,#1
000028  b2c9              UXTB     r1,r1                 ;404
00002a  60da              STR      r2,[r3,#0xc]          ;404
00002c  2935              CMP      r1,#0x35              ;404
00002e  d9f1              BLS      |L15.20|
;;;407      }   
;;;408    }
000030  4770              BX       lr
;;;409    
                          ENDP

000032  0000              DCW      0x0000
                  |L15.52|
                          DCD      0x50060420
                  |L15.56|
                          DCD      0x50060408
                  |L15.60|
                          DCD      0x50060400

                          AREA ||i.HASH_SetLastWordValidBitsNbr||, CODE, READONLY, ALIGN=2

                  HASH_SetLastWordValidBitsNbr PROC
;;;290      */
;;;291    void HASH_SetLastWordValidBitsNbr(uint16_t ValidNumber)
000000  4904              LDR      r1,|L16.20|
;;;292    {
;;;293      /* Check the parameters */
;;;294      assert_param(IS_HASH_VALIDBITSNUMBER(ValidNumber));
;;;295      
;;;296      /* Configure the Number of valid bits in last word of the message */
;;;297      HASH->STR &= ~(HASH_STR_NBW);
000002  680a              LDR      r2,[r1,#0]
000004  f022021f          BIC      r2,r2,#0x1f
000008  600a              STR      r2,[r1,#0]
;;;298      HASH->STR |= ValidNumber;
00000a  680a              LDR      r2,[r1,#0]
00000c  4310              ORRS     r0,r0,r2
00000e  6008              STR      r0,[r1,#0]
;;;299    }
000010  4770              BX       lr
;;;300    
                          ENDP

000012  0000              DCW      0x0000
                  |L16.20|
                          DCD      0x50060408

                          AREA ||i.HASH_StartDigest||, CODE, READONLY, ALIGN=2

                  HASH_StartDigest PROC
;;;352      */
;;;353    void HASH_StartDigest(void)
000000  4802              LDR      r0,|L17.12|
;;;354    {
;;;355      /* Start the Digest calculation */
;;;356      HASH->STR |= HASH_STR_DCAL;
000002  6801              LDR      r1,[r0,#0]
000004  f4417180          ORR      r1,r1,#0x100
000008  6001              STR      r1,[r0,#0]
;;;357    }
00000a  4770              BX       lr
;;;358    /**
                          ENDP

                  |L17.12|
                          DCD      0x50060408

                          AREA ||i.HASH_StructInit||, CODE, READONLY, ALIGN=1

                  HASH_StructInit PROC
;;;224      */
;;;225    void HASH_StructInit(HASH_InitTypeDef* HASH_InitStruct)
000000  2100              MOVS     r1,#0
;;;226    {
;;;227      /* Initialize the HASH_AlgoSelection member */
;;;228      HASH_InitStruct->HASH_AlgoSelection = HASH_AlgoSelection_SHA1;
;;;229    
;;;230      /* Initialize the HASH_AlgoMode member */
;;;231      HASH_InitStruct->HASH_AlgoMode = HASH_AlgoMode_HASH;
000002  6001              STR      r1,[r0,#0]
;;;232    
;;;233      /* Initialize the HASH_DataType member */
;;;234      HASH_InitStruct->HASH_DataType = HASH_DataType_32b;
000004  6041              STR      r1,[r0,#4]
;;;235    
;;;236      /* Initialize the HASH_HMACKeyType member */
;;;237      HASH_InitStruct->HASH_HMACKeyType = HASH_HMACKeyType_ShortKey;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;238    }
00000a  4770              BX       lr
;;;239    
                          ENDP


;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_hash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_hash_c_90573c7c____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___16_stm32f4xx_hash_c_90573c7c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_hash_c_90573c7c____REVSH|
#line 144
|__asm___16_stm32f4xx_hash_c_90573c7c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
