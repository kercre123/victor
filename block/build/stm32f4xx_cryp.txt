; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\build\stm32f4xx_cryp.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\build\stm32f4xx_cryp.d --cpu=Cortex-M4.fp --apcs=interwork -Otime -I.\arm_hal -I.\arm_hal\lib -I..\include -I..\coretech\common\include -I..\coretech\messaging\include -I..\coretech\planning\include -I..\coretech\vision\include -I.\supervisor\src -I..\..\coretech-external\heatshrink -IC:\Keil\ARM\Pack\ARM\CMSIS\3.20.4\Device\ARM\ARMCM4\Include -I.\include -DSTM32F401xC -DUSE_STDPERIPH_DRIVER -DSTM32F411xE -DCOZMO_ROBOT -DROBOT_HARDWARE -DCORETECH_ROBOT -DOFFBOARD_VISION -DSTM32F401xx --omf_browse=.\build\stm32f4xx_cryp.crf arm_hal\lib\stm32f4xx_cryp.c]
                          THUMB

                          AREA ||i.CRYP_Cmd||, CODE, READONLY, ALIGN=2

                  CRYP_Cmd PROC
;;;402      */
;;;403    void CRYP_Cmd(FunctionalState NewState)
000000  4904              LDR      r1,|L1.20|
;;;404    {
;;;405      /* Check the parameters */
;;;406      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;407    
;;;408      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;409      {
;;;410        /* Enable the Cryptographic processor */
;;;411        CRYP->CR |= CRYP_CR_CRYPEN;
;;;412      }
;;;413      else
;;;414      {
;;;415        /* Disable the Cryptographic processor */
;;;416        CRYP->CR &= ~CRYP_CR_CRYPEN;
000004  6808              LDR      r0,[r1,#0]
000006  bf14              ITE      NE                    ;411
000008  f4404000          ORRNE    r0,r0,#0x8000         ;411
00000c  f4204000          BICEQ    r0,r0,#0x8000
000010  6008              STR      r0,[r1,#0]            ;411
;;;417      }
;;;418    }
000012  4770              BX       lr
;;;419    /**
                          ENDP

                  |L1.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_DMACmd||, CODE, READONLY, ALIGN=2

                  CRYP_DMACmd PROC
;;;680      */
;;;681    void CRYP_DMACmd(uint8_t CRYP_DMAReq, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;682    {
;;;683      /* Check the parameters */
;;;684      assert_param(IS_CRYP_DMAREQ(CRYP_DMAReq));
;;;685      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;686    
;;;687      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;688      {
;;;689        /* Enable the selected CRYP DMA request */
;;;690        CRYP->DMACR |= CRYP_DMAReq;
;;;691      }
;;;692      else
;;;693      {
;;;694        /* Disable the selected CRYP DMA request */
;;;695        CRYP->DMACR &= (uint8_t)~CRYP_DMAReq;
000004  6911              LDR      r1,[r2,#0x10]
000006  bf11              ITEEE    NE                    ;690
000008  4308              ORRNE    r0,r0,r1              ;690
00000a  43c0              MVNEQ    r0,r0
00000c  b2c0              UXTBEQ   r0,r0
00000e  4008              ANDEQ    r0,r0,r1
000010  6110              STR      r0,[r2,#0x10]         ;690
;;;696      }
;;;697    }
000012  4770              BX       lr
;;;698    /**
                          ENDP

                  |L2.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataIn||, CODE, READONLY, ALIGN=2

                  CRYP_DataIn PROC
;;;445      */
;;;446    void CRYP_DataIn(uint32_t Data)
000000  4901              LDR      r1,|L3.8|
;;;447    {
;;;448      CRYP->DR = Data;
000002  6088              STR      r0,[r1,#8]
;;;449    }
000004  4770              BX       lr
;;;450    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DataOut||, CODE, READONLY, ALIGN=2

                  CRYP_DataOut PROC
;;;455      */
;;;456    uint32_t CRYP_DataOut(void)
000000  4801              LDR      r0,|L4.8|
;;;457    {
;;;458      return CRYP->DOUT;
000002  68c0              LDR      r0,[r0,#0xc]
;;;459    }
000004  4770              BX       lr
;;;460    /**
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x50060000

                          AREA ||i.CRYP_DeInit||, CODE, READONLY, ALIGN=1

                  CRYP_DeInit PROC
;;;218      */
;;;219    void CRYP_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;220    {
;;;221      /* Enable CRYP reset state */
;;;222      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_AHB2PeriphResetCmd
;;;223    
;;;224      /* Release CRYP from reset state */
;;;225      RCC_AHB2PeriphResetCmd(RCC_AHB2Periph_CRYP, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  e8bd4010          POP      {r4,lr}
000010  2010              MOVS     r0,#0x10
000012  f7ffbffe          B.W      RCC_AHB2PeriphResetCmd
;;;226    }
;;;227    
                          ENDP


                          AREA ||i.CRYP_FIFOFlush||, CODE, READONLY, ALIGN=2

                  CRYP_FIFOFlush PROC
;;;390      */
;;;391    void CRYP_FIFOFlush(void)
000000  4802              LDR      r0,|L6.12|
;;;392    {
;;;393      /* Reset the read and write pointers of the FIFOs */
;;;394      CRYP->CR |= CRYP_CR_FFLUSH;
000002  6801              LDR      r1,[r0,#0]
000004  f4414180          ORR      r1,r1,#0x4000
000008  6001              STR      r1,[r0,#0]
;;;395    }
00000a  4770              BX       lr
;;;396    
                          ENDP

                  |L6.12|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetCmdStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetCmdStatus PROC
;;;852      */
;;;853    FunctionalState CRYP_GetCmdStatus(void)
000000  4903              LDR      r1,|L7.16|
;;;854    {
;;;855      FunctionalState state = DISABLE;
000002  2000              MOVS     r0,#0
;;;856    
;;;857      if ((CRYP->CR & CRYP_CR_CRYPEN) != 0)
000004  6809              LDR      r1,[r1,#0]
000006  f4114f00          TST      r1,#0x8000
;;;858      {
;;;859        /* CRYPEN bit is set */
;;;860        state = ENABLE;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;861      }
;;;862      else
;;;863      {
;;;864        /* CRYPEN bit is reset */
;;;865        state = DISABLE;
;;;866      }
;;;867      return state;
;;;868    }
00000e  4770              BX       lr
;;;869    
                          ENDP

                  |L7.16|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetFlagStatus PROC
;;;882      */
;;;883    FlagStatus CRYP_GetFlagStatus(uint8_t CRYP_FLAG)
000000  2200              MOVS     r2,#0
;;;884    {
;;;885      FlagStatus bitstatus = RESET;
;;;886      uint32_t tempreg = 0;
;;;887    
;;;888      /* Check the parameters */
;;;889      assert_param(IS_CRYP_GET_FLAG(CRYP_FLAG));
;;;890    
;;;891      /* check if the FLAG is in RISR register */
;;;892      if ((CRYP_FLAG & FLAG_MASK) != 0x00) 
;;;893      {
;;;894        tempreg = CRYP->RISR;
000002  4905              LDR      r1,|L8.24|
000004  f0100f20          TST      r0,#0x20              ;892
000008  bf14              ITE      NE
00000a  6989              LDRNE    r1,[r1,#0x18]
;;;895      }
;;;896      else  /* The FLAG is in SR register */
;;;897      {
;;;898        tempreg = CRYP->SR;
00000c  6849              LDREQ    r1,[r1,#4]
;;;899      }
;;;900    
;;;901    
;;;902      /* Check the status of the specified CRYP flag */
;;;903      if ((tempreg & CRYP_FLAG ) != (uint8_t)RESET)
00000e  4201              TST      r1,r0
;;;904      {
;;;905        /* CRYP_FLAG is set */
;;;906        bitstatus = SET;
000010  bf18              IT       NE
000012  2201              MOVNE    r2,#1
;;;907      }
;;;908      else
;;;909      {
;;;910        /* CRYP_FLAG is reset */
;;;911        bitstatus = RESET;
;;;912      }
;;;913    
;;;914      /* Return the CRYP_FLAG status */
;;;915      return  bitstatus;
000014  4610              MOV      r0,r2
;;;916    }
000016  4770              BX       lr
;;;917    
                          ENDP

                  |L8.24|
                          DCD      0x50060000

                          AREA ||i.CRYP_GetITStatus||, CODE, READONLY, ALIGN=2

                  CRYP_GetITStatus PROC
;;;826      */
;;;827    ITStatus CRYP_GetITStatus(uint8_t CRYP_IT)
000000  4a03              LDR      r2,|L9.16|
;;;828    {
000002  4601              MOV      r1,r0
;;;829      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;830      /* Check the parameters */
;;;831      assert_param(IS_CRYP_GET_IT(CRYP_IT));
;;;832    
;;;833      /* Check the status of the specified CRYP interrupt */
;;;834      if ((CRYP->MISR &  CRYP_IT) != (uint8_t)RESET)
000006  69d2              LDR      r2,[r2,#0x1c]
000008  420a              TST      r2,r1
;;;835      {
;;;836        /* CRYP_IT is set */
;;;837        bitstatus = SET;
00000a  bf18              IT       NE
00000c  2001              MOVNE    r0,#1
;;;838      }
;;;839      else
;;;840      {
;;;841        /* CRYP_IT is reset */
;;;842        bitstatus = RESET;
;;;843      }
;;;844      /* Return the CRYP_IT status */
;;;845      return bitstatus;
;;;846    }
00000e  4770              BX       lr
;;;847    
                          ENDP

                  |L9.16|
                          DCD      0x50060000

                          AREA ||i.CRYP_ITConfig||, CODE, READONLY, ALIGN=2

                  CRYP_ITConfig PROC
;;;798      */
;;;799    void CRYP_ITConfig(uint8_t CRYP_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;800    {
;;;801      /* Check the parameters */
;;;802      assert_param(IS_CRYP_CONFIG_IT(CRYP_IT));
;;;803      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;804    
;;;805      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;806      {
;;;807        /* Enable the selected CRYP interrupt */
;;;808        CRYP->IMSCR |= CRYP_IT;
;;;809      }
;;;810      else
;;;811      {
;;;812        /* Disable the selected CRYP interrupt */
;;;813        CRYP->IMSCR &= (uint8_t)~CRYP_IT;
000004  6951              LDR      r1,[r2,#0x14]
000006  bf11              ITEEE    NE                    ;808
000008  4308              ORRNE    r0,r0,r1              ;808
00000a  43c0              MVNEQ    r0,r0
00000c  b2c0              UXTBEQ   r0,r0
00000e  4008              ANDEQ    r0,r0,r1
000010  6150              STR      r0,[r2,#0x14]         ;808
;;;814      }
;;;815    }
000012  4770              BX       lr
;;;816    
                          ENDP

                  |L10.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVInit||, CODE, READONLY, ALIGN=2

                  CRYP_IVInit PROC
;;;332      */
;;;333    void CRYP_IVInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  4904              LDR      r1,|L11.20|
;;;334    {
;;;335      CRYP->IV0LR = CRYP_IVInitStruct->CRYP_IV0Left;
000002  6802              LDR      r2,[r0,#0]
000004  640a              STR      r2,[r1,#0x40]
;;;336      CRYP->IV0RR = CRYP_IVInitStruct->CRYP_IV0Right;
000006  6842              LDR      r2,[r0,#4]
000008  644a              STR      r2,[r1,#0x44]
;;;337      CRYP->IV1LR = CRYP_IVInitStruct->CRYP_IV1Left;
00000a  6882              LDR      r2,[r0,#8]
00000c  648a              STR      r2,[r1,#0x48]
;;;338      CRYP->IV1RR = CRYP_IVInitStruct->CRYP_IV1Right;
00000e  68c0              LDR      r0,[r0,#0xc]
000010  64c8              STR      r0,[r1,#0x4c]
;;;339    }
000012  4770              BX       lr
;;;340    
                          ENDP

                  |L11.20|
                          DCD      0x50060000

                          AREA ||i.CRYP_IVStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_IVStructInit PROC
;;;346      */
;;;347    void CRYP_IVStructInit(CRYP_IVInitTypeDef* CRYP_IVInitStruct)
000000  2100              MOVS     r1,#0
;;;348    {
;;;349      CRYP_IVInitStruct->CRYP_IV0Left  = 0;
;;;350      CRYP_IVInitStruct->CRYP_IV0Right = 0;
000002  6001              STR      r1,[r0,#0]
;;;351      CRYP_IVInitStruct->CRYP_IV1Left  = 0;
000004  6041              STR      r1,[r0,#4]
;;;352      CRYP_IVInitStruct->CRYP_IV1Right = 0;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;353    }
00000a  4770              BX       lr
;;;354    
                          ENDP


                          AREA ||i.CRYP_Init||, CODE, READONLY, ALIGN=2

                  CRYP_Init PROC
;;;234      */
;;;235    void CRYP_Init(CRYP_InitTypeDef* CRYP_InitStruct)
000000  4a16              LDR      r2,|L13.92|
;;;236    {
;;;237      /* Check the parameters */
;;;238      assert_param(IS_CRYP_ALGOMODE(CRYP_InitStruct->CRYP_AlgoMode));
;;;239      assert_param(IS_CRYP_DATATYPE(CRYP_InitStruct->CRYP_DataType));
;;;240      assert_param(IS_CRYP_ALGODIR(CRYP_InitStruct->CRYP_AlgoDir));
;;;241    
;;;242      /* Select Algorithm mode*/  
;;;243      CRYP->CR &= ~CRYP_CR_ALGOMODE;
000002  6811              LDR      r1,[r2,#0]
000004  f0210138          BIC      r1,r1,#0x38
000008  f4212100          BIC      r1,r1,#0x80000
00000c  6011              STR      r1,[r2,#0]
;;;244      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoMode;
00000e  6811              LDR      r1,[r2,#0]
000010  6843              LDR      r3,[r0,#4]
000012  4319              ORRS     r1,r1,r3
000014  6011              STR      r1,[r2,#0]
;;;245    
;;;246      /* Select dataType */ 
;;;247      CRYP->CR &= ~CRYP_CR_DATATYPE;
000016  6811              LDR      r1,[r2,#0]
000018  f02101c0          BIC      r1,r1,#0xc0
00001c  6011              STR      r1,[r2,#0]
;;;248      CRYP->CR |= CRYP_InitStruct->CRYP_DataType;
00001e  6811              LDR      r1,[r2,#0]
000020  6883              LDR      r3,[r0,#8]
000022  4319              ORRS     r1,r1,r3
000024  6011              STR      r1,[r2,#0]
;;;249    
;;;250      /* select Key size (used only with AES algorithm) */
;;;251      if ((CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_ECB) &&
000026  6841              LDR      r1,[r0,#4]
000028  2900              CMP      r1,#0
;;;252          (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_TDES_CBC) &&
00002a  bf18              IT       NE
00002c  2908              CMPNE    r1,#8
00002e  d00b              BEQ      |L13.72|
;;;253          (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_ECB) &&
000030  2910              CMP      r1,#0x10
;;;254          (CRYP_InitStruct->CRYP_AlgoMode != CRYP_AlgoMode_DES_CBC))
000032  bf18              IT       NE
000034  2918              CMPNE    r1,#0x18
000036  d007              BEQ      |L13.72|
;;;255      {
;;;256        assert_param(IS_CRYP_KEYSIZE(CRYP_InitStruct->CRYP_KeySize));
;;;257        CRYP->CR &= ~CRYP_CR_KEYSIZE;
000038  6811              LDR      r1,[r2,#0]
00003a  f4217140          BIC      r1,r1,#0x300
00003e  6011              STR      r1,[r2,#0]
;;;258        CRYP->CR |= CRYP_InitStruct->CRYP_KeySize; /* Key size and value must be 
000040  6811              LDR      r1,[r2,#0]
000042  68c3              LDR      r3,[r0,#0xc]
000044  4319              ORRS     r1,r1,r3
000046  6011              STR      r1,[r2,#0]
                  |L13.72|
;;;259                                                      configured once the key has 
;;;260                                                      been prepared */
;;;261      }
;;;262    
;;;263      /* Select data Direction */ 
;;;264      CRYP->CR &= ~CRYP_CR_ALGODIR;
000048  6811              LDR      r1,[r2,#0]
00004a  f0210104          BIC      r1,r1,#4
00004e  6011              STR      r1,[r2,#0]
;;;265      CRYP->CR |= CRYP_InitStruct->CRYP_AlgoDir;
000050  6811              LDR      r1,[r2,#0]
000052  6800              LDR      r0,[r0,#0]
000054  4308              ORRS     r0,r0,r1
000056  6010              STR      r0,[r2,#0]
;;;266    }
000058  4770              BX       lr
;;;267    
                          ENDP

00005a  0000              DCW      0x0000
                  |L13.92|
                          DCD      0x50060000

                          AREA ||i.CRYP_KeyInit||, CODE, READONLY, ALIGN=2

                  CRYP_KeyInit PROC
;;;295      */
;;;296    void CRYP_KeyInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  4908              LDR      r1,|L14.36|
;;;297    {
;;;298      /* Key Initialisation */
;;;299      CRYP->K0LR = CRYP_KeyInitStruct->CRYP_Key0Left;
000002  6802              LDR      r2,[r0,#0]
000004  620a              STR      r2,[r1,#0x20]
;;;300      CRYP->K0RR = CRYP_KeyInitStruct->CRYP_Key0Right;
000006  6842              LDR      r2,[r0,#4]
000008  624a              STR      r2,[r1,#0x24]
;;;301      CRYP->K1LR = CRYP_KeyInitStruct->CRYP_Key1Left;
00000a  6882              LDR      r2,[r0,#8]
00000c  628a              STR      r2,[r1,#0x28]
;;;302      CRYP->K1RR = CRYP_KeyInitStruct->CRYP_Key1Right;
00000e  68c2              LDR      r2,[r0,#0xc]
000010  62ca              STR      r2,[r1,#0x2c]
;;;303      CRYP->K2LR = CRYP_KeyInitStruct->CRYP_Key2Left;
000012  6902              LDR      r2,[r0,#0x10]
000014  630a              STR      r2,[r1,#0x30]
;;;304      CRYP->K2RR = CRYP_KeyInitStruct->CRYP_Key2Right;
000016  6942              LDR      r2,[r0,#0x14]
000018  634a              STR      r2,[r1,#0x34]
;;;305      CRYP->K3LR = CRYP_KeyInitStruct->CRYP_Key3Left;
00001a  6982              LDR      r2,[r0,#0x18]
00001c  638a              STR      r2,[r1,#0x38]
;;;306      CRYP->K3RR = CRYP_KeyInitStruct->CRYP_Key3Right;
00001e  69c0              LDR      r0,[r0,#0x1c]
000020  63c8              STR      r0,[r1,#0x3c]
;;;307    }
000022  4770              BX       lr
;;;308    
                          ENDP

                  |L14.36|
                          DCD      0x50060000

                          AREA ||i.CRYP_KeyStructInit||, CODE, READONLY, ALIGN=1

                  CRYP_KeyStructInit PROC
;;;314      */
;;;315    void CRYP_KeyStructInit(CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
000000  2100              MOVS     r1,#0
;;;316    {
;;;317      CRYP_KeyInitStruct->CRYP_Key0Left  = 0;
;;;318      CRYP_KeyInitStruct->CRYP_Key0Right = 0;
000002  6001              STR      r1,[r0,#0]
;;;319      CRYP_KeyInitStruct->CRYP_Key1Left  = 0;
000004  6041              STR      r1,[r0,#4]
;;;320      CRYP_KeyInitStruct->CRYP_Key1Right = 0;
000006  6081              STR      r1,[r0,#8]
;;;321      CRYP_KeyInitStruct->CRYP_Key2Left  = 0;
000008  60c1              STR      r1,[r0,#0xc]
;;;322      CRYP_KeyInitStruct->CRYP_Key2Right = 0;
00000a  6101              STR      r1,[r0,#0x10]
;;;323      CRYP_KeyInitStruct->CRYP_Key3Left  = 0;
00000c  6141              STR      r1,[r0,#0x14]
;;;324      CRYP_KeyInitStruct->CRYP_Key3Right = 0;
00000e  6181              STR      r1,[r0,#0x18]
000010  61c1              STR      r1,[r0,#0x1c]
;;;325    }
000012  4770              BX       lr
;;;326    /**
                          ENDP


                          AREA ||i.CRYP_PhaseConfig||, CODE, READONLY, ALIGN=2

                  CRYP_PhaseConfig PROC
;;;365      */
;;;366    void CRYP_PhaseConfig(uint32_t CRYP_Phase)
000000  4a03              LDR      r2,|L16.16|
;;;367    { uint32_t tempcr = 0;
;;;368    
;;;369      /* Check the parameter */
;;;370      assert_param(IS_CRYP_PHASE(CRYP_Phase));
;;;371    
;;;372      /* Get the CR register */
;;;373      tempcr = CRYP->CR;
000002  6811              LDR      r1,[r2,#0]
;;;374      
;;;375      /* Reset the phase configuration bits: GCMP_CCMPH */
;;;376      tempcr &= (uint32_t)(~CRYP_CR_GCM_CCMPH);
000004  f4213140          BIC      r1,r1,#0x30000
;;;377      /* Set the selected phase */
;;;378      tempcr |= (uint32_t)CRYP_Phase;
000008  4308              ORRS     r0,r0,r1
;;;379    
;;;380      /* Set the CR register */ 
;;;381      CRYP->CR = tempcr;    
00000a  6010              STR      r0,[r2,#0]
;;;382    }
00000c  4770              BX       lr
;;;383    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      0x50060000

                          AREA ||i.CRYP_RestoreContext||, CODE, READONLY, ALIGN=2

                  CRYP_RestoreContext PROC
;;;601      */
;;;602    void CRYP_RestoreContext(CRYP_Context* CRYP_ContextRestore)  
000000  4921              LDR      r1,|L17.136|
;;;603    {
;;;604    
;;;605      /* Configure the processor with the saved configuration */
;;;606      CRYP->CR = CRYP_ContextRestore->CR_CurrentConfig;
000002  6802              LDR      r2,[r0,#0]
000004  f8412b10          STR      r2,[r1],#0x10
;;;607    
;;;608      /* restore The key value */
;;;609      CRYP->K0LR = CRYP_ContextRestore->CRYP_K0LR; 
000008  6942              LDR      r2,[r0,#0x14]
00000a  610a              STR      r2,[r1,#0x10]
;;;610      CRYP->K0RR = CRYP_ContextRestore->CRYP_K0RR;
00000c  6982              LDR      r2,[r0,#0x18]
00000e  614a              STR      r2,[r1,#0x14]
;;;611      CRYP->K1LR = CRYP_ContextRestore->CRYP_K1LR;
000010  69c2              LDR      r2,[r0,#0x1c]
000012  618a              STR      r2,[r1,#0x18]
;;;612      CRYP->K1RR = CRYP_ContextRestore->CRYP_K1RR;
000014  6a02              LDR      r2,[r0,#0x20]
000016  61ca              STR      r2,[r1,#0x1c]
;;;613      CRYP->K2LR = CRYP_ContextRestore->CRYP_K2LR;
000018  6a42              LDR      r2,[r0,#0x24]
00001a  620a              STR      r2,[r1,#0x20]
;;;614      CRYP->K2RR = CRYP_ContextRestore->CRYP_K2RR;
00001c  6a82              LDR      r2,[r0,#0x28]
00001e  624a              STR      r2,[r1,#0x24]
;;;615      CRYP->K3LR = CRYP_ContextRestore->CRYP_K3LR;
000020  6ac2              LDR      r2,[r0,#0x2c]
000022  628a              STR      r2,[r1,#0x28]
;;;616      CRYP->K3RR = CRYP_ContextRestore->CRYP_K3RR;
000024  6b02              LDR      r2,[r0,#0x30]
000026  62ca              STR      r2,[r1,#0x2c]
;;;617    
;;;618      /* and the initialization vectors. */
;;;619      CRYP->IV0LR = CRYP_ContextRestore->CRYP_IV0LR;
000028  6842              LDR      r2,[r0,#4]
00002a  630a              STR      r2,[r1,#0x30]
;;;620      CRYP->IV0RR = CRYP_ContextRestore->CRYP_IV0RR;
00002c  6882              LDR      r2,[r0,#8]
00002e  634a              STR      r2,[r1,#0x34]
;;;621      CRYP->IV1LR = CRYP_ContextRestore->CRYP_IV1LR;
000030  68c2              LDR      r2,[r0,#0xc]
000032  638a              STR      r2,[r1,#0x38]
;;;622      CRYP->IV1RR = CRYP_ContextRestore->CRYP_IV1RR;
000034  6902              LDR      r2,[r0,#0x10]
000036  63ca              STR      r2,[r1,#0x3c]
;;;623    
;;;624      /* Restore the content of context swap registers */
;;;625      CRYP->CSGCMCCM0R = CRYP_ContextRestore->CRYP_CSGCMCCMR[0];
000038  6b42              LDR      r2,[r0,#0x34]
00003a  640a              STR      r2,[r1,#0x40]
;;;626      CRYP->CSGCMCCM1R = CRYP_ContextRestore->CRYP_CSGCMCCMR[1];
00003c  6b82              LDR      r2,[r0,#0x38]
00003e  644a              STR      r2,[r1,#0x44]
;;;627      CRYP->CSGCMCCM2R = CRYP_ContextRestore->CRYP_CSGCMCCMR[2];
000040  6bc2              LDR      r2,[r0,#0x3c]
000042  648a              STR      r2,[r1,#0x48]
;;;628      CRYP->CSGCMCCM3R = CRYP_ContextRestore->CRYP_CSGCMCCMR[3];
000044  6c02              LDR      r2,[r0,#0x40]
000046  64ca              STR      r2,[r1,#0x4c]
;;;629      CRYP->CSGCMCCM4R = CRYP_ContextRestore->CRYP_CSGCMCCMR[4];
000048  6c42              LDR      r2,[r0,#0x44]
00004a  650a              STR      r2,[r1,#0x50]
;;;630      CRYP->CSGCMCCM5R = CRYP_ContextRestore->CRYP_CSGCMCCMR[5];
00004c  6c82              LDR      r2,[r0,#0x48]
00004e  654a              STR      r2,[r1,#0x54]
;;;631      CRYP->CSGCMCCM6R = CRYP_ContextRestore->CRYP_CSGCMCCMR[6];
000050  6cc2              LDR      r2,[r0,#0x4c]
000052  658a              STR      r2,[r1,#0x58]
;;;632      CRYP->CSGCMCCM7R = CRYP_ContextRestore->CRYP_CSGCMCCMR[7];
000054  6d02              LDR      r2,[r0,#0x50]
000056  65ca              STR      r2,[r1,#0x5c]
;;;633      
;;;634      CRYP->CSGCM0R = CRYP_ContextRestore->CRYP_CSGCMR[0];
000058  6d42              LDR      r2,[r0,#0x54]
00005a  660a              STR      r2,[r1,#0x60]
;;;635      CRYP->CSGCM1R = CRYP_ContextRestore->CRYP_CSGCMR[1];
00005c  6d82              LDR      r2,[r0,#0x58]
00005e  664a              STR      r2,[r1,#0x64]
;;;636      CRYP->CSGCM2R = CRYP_ContextRestore->CRYP_CSGCMR[2];
000060  6dc2              LDR      r2,[r0,#0x5c]
000062  668a              STR      r2,[r1,#0x68]
;;;637      CRYP->CSGCM3R = CRYP_ContextRestore->CRYP_CSGCMR[3];
000064  6e02              LDR      r2,[r0,#0x60]
000066  66ca              STR      r2,[r1,#0x6c]
;;;638      CRYP->CSGCM4R = CRYP_ContextRestore->CRYP_CSGCMR[4];
000068  6e42              LDR      r2,[r0,#0x64]
00006a  670a              STR      r2,[r1,#0x70]
;;;639      CRYP->CSGCM5R = CRYP_ContextRestore->CRYP_CSGCMR[5];
00006c  6e82              LDR      r2,[r0,#0x68]
00006e  674a              STR      r2,[r1,#0x74]
;;;640      CRYP->CSGCM6R = CRYP_ContextRestore->CRYP_CSGCMR[6];
000070  6ec2              LDR      r2,[r0,#0x6c]
000072  678a              STR      r2,[r1,#0x78]
;;;641      CRYP->CSGCM7R = CRYP_ContextRestore->CRYP_CSGCMR[7];
000074  6f00              LDR      r0,[r0,#0x70]
000076  67c8              STR      r0,[r1,#0x7c]
;;;642      
;;;643      /* Enable the cryptographic processor */
;;;644      CRYP->CR |= CRYP_CR_CRYPEN;
000078  f8510c10          LDR      r0,[r1,#-0x10]
00007c  f4404000          ORR      r0,r0,#0x8000
000080  f8410c10          STR      r0,[r1,#-0x10]
;;;645    }
000084  4770              BX       lr
;;;646    /**
                          ENDP

000086  0000              DCW      0x0000
                  |L17.136|
                          DCD      0x50060000

                          AREA ||i.CRYP_SaveContext||, CODE, READONLY, ALIGN=2

                  CRYP_SaveContext PROC
;;;496      */
;;;497    ErrorStatus CRYP_SaveContext(CRYP_Context* CRYP_ContextSave,
000000  b438              PUSH     {r3-r5}
;;;498                                 CRYP_KeyInitTypeDef* CRYP_KeyInitStruct)
;;;499    {
;;;500      __IO uint32_t timeout = 0;
000002  2200              MOVS     r2,#0
;;;501      uint32_t ckeckmask = 0, bitstatus;    
;;;502      ErrorStatus status = ERROR;
;;;503    
;;;504      /* Stop DMA transfers on the IN FIFO by clearing the DIEN bit in the CRYP_DMACR */
;;;505      CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DIEN;
000004  9200              STR      r2,[sp,#0]
000006  4a37              LDR      r2,|L18.228|
000008  6913              LDR      r3,[r2,#0x10]
00000a  f0230301          BIC      r3,r3,#1
00000e  6113              STR      r3,[r2,#0x10]
;;;506        
;;;507      /* Wait until both the IN and OUT FIFOs are empty  
;;;508        (IFEM=1 and OFNE=0 in the CRYP_SR register) and the 
;;;509         BUSY bit is cleared. */
;;;510    
;;;511      if ((CRYP->CR & (uint32_t)(CRYP_CR_ALGOMODE_TDES_ECB | CRYP_CR_ALGOMODE_TDES_CBC)) != (uint32_t)0 )/* TDES */
000010  6813              LDR      r3,[r2,#0]
000012  f0130f08          TST      r3,#8
;;;512      { 
;;;513        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY ;
000016  bf14              ITE      NE
000018  2311              MOVNE    r3,#0x11
;;;514      }
;;;515      else /* AES or DES */
;;;516      {
;;;517        ckeckmask =  CRYP_SR_IFEM | CRYP_SR_BUSY | CRYP_SR_OFNE;
00001a  2315              MOVEQ    r3,#0x15
;;;518      }           
;;;519       
;;;520      do 
;;;521      {
;;;522        bitstatus = CRYP->SR & ckeckmask;
;;;523        timeout++;
;;;524      }
;;;525      while ((timeout != MAX_TIMEOUT) && (bitstatus != CRYP_SR_IFEM));
00001c  f64f74ff          MOV      r4,#0xffff
                  |L18.32|
000020  f8d2c004          LDR      r12,[r2,#4]           ;522
000024  9d00              LDR      r5,[sp,#0]            ;523
000026  ea0c0c03          AND      r12,r12,r3            ;522
00002a  1c6d              ADDS     r5,r5,#1              ;523
00002c  9500              STR      r5,[sp,#0]
00002e  42a5              CMP      r5,r4
000030  bf18              IT       NE
000032  f1bc0f01          CMPNE    r12,#1
000036  d1f3              BNE      |L18.32|
;;;526         
;;;527      if ((CRYP->SR & ckeckmask) != CRYP_SR_IFEM)
000038  f8d2c004          LDR      r12,[r2,#4]
00003c  ea0c0303          AND      r3,r12,r3
000040  2b01              CMP      r3,#1
;;;528      {
;;;529        status = ERROR;
000042  bf1e              ITTT     NE
000044  2000              MOVNE    r0,#0
;;;530      }
;;;531      else
;;;532      {      
;;;533        /* Stop DMA transfers on the OUT FIFO by 
;;;534           - writing the DOEN bit to 0 in the CRYP_DMACR register 
;;;535           - and clear the CRYPEN bit. */
;;;536    
;;;537        CRYP->DMACR &= ~(uint32_t)CRYP_DMACR_DOEN;
;;;538        CRYP->CR &= ~(uint32_t)CRYP_CR_CRYPEN;
;;;539    
;;;540        /* Save the current configuration (bit 19, bit[17:16] and bits [9:2] in the CRYP_CR register) */
;;;541        CRYP_ContextSave->CR_CurrentConfig  = CRYP->CR & (CRYP_CR_GCM_CCMPH |
;;;542                                                          CRYP_CR_KEYSIZE  |
;;;543                                                          CRYP_CR_DATATYPE |
;;;544                                                          CRYP_CR_ALGOMODE |
;;;545                                                          CRYP_CR_ALGODIR);
;;;546    
;;;547        /* and, if not in ECB mode, the initialization vectors. */
;;;548        CRYP_ContextSave->CRYP_IV0LR = CRYP->IV0LR;
;;;549        CRYP_ContextSave->CRYP_IV0RR = CRYP->IV0RR;
;;;550        CRYP_ContextSave->CRYP_IV1LR = CRYP->IV1LR;
;;;551        CRYP_ContextSave->CRYP_IV1RR = CRYP->IV1RR;
;;;552    
;;;553        /* save The key value */
;;;554        CRYP_ContextSave->CRYP_K0LR = CRYP_KeyInitStruct->CRYP_Key0Left; 
;;;555        CRYP_ContextSave->CRYP_K0RR = CRYP_KeyInitStruct->CRYP_Key0Right; 
;;;556        CRYP_ContextSave->CRYP_K1LR = CRYP_KeyInitStruct->CRYP_Key1Left; 
;;;557        CRYP_ContextSave->CRYP_K1RR = CRYP_KeyInitStruct->CRYP_Key1Right; 
;;;558        CRYP_ContextSave->CRYP_K2LR = CRYP_KeyInitStruct->CRYP_Key2Left; 
;;;559        CRYP_ContextSave->CRYP_K2RR = CRYP_KeyInitStruct->CRYP_Key2Right; 
;;;560        CRYP_ContextSave->CRYP_K3LR = CRYP_KeyInitStruct->CRYP_Key3Left; 
;;;561        CRYP_ContextSave->CRYP_K3RR = CRYP_KeyInitStruct->CRYP_Key3Right; 
;;;562    
;;;563        /* Save the content of context swap registers */
;;;564        CRYP_ContextSave->CRYP_CSGCMCCMR[0] = CRYP->CSGCMCCM0R;
;;;565        CRYP_ContextSave->CRYP_CSGCMCCMR[1] = CRYP->CSGCMCCM1R;
;;;566        CRYP_ContextSave->CRYP_CSGCMCCMR[2] = CRYP->CSGCMCCM2R;
;;;567        CRYP_ContextSave->CRYP_CSGCMCCMR[3] = CRYP->CSGCMCCM3R;
;;;568        CRYP_ContextSave->CRYP_CSGCMCCMR[4] = CRYP->CSGCMCCM4R;
;;;569        CRYP_ContextSave->CRYP_CSGCMCCMR[5] = CRYP->CSGCMCCM5R;
;;;570        CRYP_ContextSave->CRYP_CSGCMCCMR[6] = CRYP->CSGCMCCM6R;
;;;571        CRYP_ContextSave->CRYP_CSGCMCCMR[7] = CRYP->CSGCMCCM7R;
;;;572        
;;;573        CRYP_ContextSave->CRYP_CSGCMR[0] = CRYP->CSGCM0R;
;;;574        CRYP_ContextSave->CRYP_CSGCMR[1] = CRYP->CSGCM1R;
;;;575        CRYP_ContextSave->CRYP_CSGCMR[2] = CRYP->CSGCM2R;
;;;576        CRYP_ContextSave->CRYP_CSGCMR[3] = CRYP->CSGCM3R;
;;;577        CRYP_ContextSave->CRYP_CSGCMR[4] = CRYP->CSGCM4R;
;;;578        CRYP_ContextSave->CRYP_CSGCMR[5] = CRYP->CSGCM5R;
;;;579        CRYP_ContextSave->CRYP_CSGCMR[6] = CRYP->CSGCM6R;
;;;580        CRYP_ContextSave->CRYP_CSGCMR[7] = CRYP->CSGCM7R;
;;;581        
;;;582       /* When needed, save the DMA status (pointers for IN and OUT messages, 
;;;583          number of remaining bytes, etc.) */
;;;584         
;;;585        status = SUCCESS;
;;;586      }
;;;587    
;;;588       return status;
;;;589    }
000046  bc38              POPNE    {r3-r5}
000048  4770              BXNE     lr
00004a  6913              LDR      r3,[r2,#0x10]         ;537
00004c  f0230302          BIC      r3,r3,#2              ;537
000050  6113              STR      r3,[r2,#0x10]         ;537
000052  6813              LDR      r3,[r2,#0]            ;538
000054  f4234300          BIC      r3,r3,#0x8000         ;538
000058  6013              STR      r3,[r2,#0]            ;538
00005a  f8d2c000          LDR      r12,[r2,#0]           ;541
00005e  4b22              LDR      r3,|L18.232|
000060  ea0c0303          AND      r3,r12,r3             ;541
000064  6003              STR      r3,[r0,#0]            ;548
000066  6c13              LDR      r3,[r2,#0x40]         ;548
000068  6043              STR      r3,[r0,#4]            ;549
00006a  6c53              LDR      r3,[r2,#0x44]         ;549
00006c  6083              STR      r3,[r0,#8]            ;550
00006e  6c93              LDR      r3,[r2,#0x48]         ;550
000070  60c3              STR      r3,[r0,#0xc]          ;551
000072  6cd3              LDR      r3,[r2,#0x4c]         ;551
000074  6103              STR      r3,[r0,#0x10]         ;554
000076  680b              LDR      r3,[r1,#0]            ;554
000078  6143              STR      r3,[r0,#0x14]         ;555
00007a  684b              LDR      r3,[r1,#4]            ;555
00007c  6183              STR      r3,[r0,#0x18]         ;556
00007e  688b              LDR      r3,[r1,#8]            ;556
000080  61c3              STR      r3,[r0,#0x1c]         ;557
000082  68cb              LDR      r3,[r1,#0xc]          ;557
000084  6203              STR      r3,[r0,#0x20]         ;558
000086  690b              LDR      r3,[r1,#0x10]         ;558
000088  6243              STR      r3,[r0,#0x24]         ;559
00008a  694b              LDR      r3,[r1,#0x14]         ;559
00008c  6283              STR      r3,[r0,#0x28]         ;560
00008e  698b              LDR      r3,[r1,#0x18]         ;560
000090  62c3              STR      r3,[r0,#0x2c]         ;561
000092  69c9              LDR      r1,[r1,#0x1c]         ;561
000094  6301              STR      r1,[r0,#0x30]         ;564
000096  6d11              LDR      r1,[r2,#0x50]         ;564
000098  6341              STR      r1,[r0,#0x34]         ;565
00009a  6d51              LDR      r1,[r2,#0x54]         ;565
00009c  6381              STR      r1,[r0,#0x38]         ;566
00009e  6d91              LDR      r1,[r2,#0x58]         ;566
0000a0  63c1              STR      r1,[r0,#0x3c]         ;567
0000a2  6dd1              LDR      r1,[r2,#0x5c]         ;567
0000a4  6401              STR      r1,[r0,#0x40]         ;568
0000a6  6e11              LDR      r1,[r2,#0x60]         ;568
0000a8  6441              STR      r1,[r0,#0x44]         ;569
0000aa  6e51              LDR      r1,[r2,#0x64]         ;569
0000ac  6481              STR      r1,[r0,#0x48]         ;570
0000ae  6e91              LDR      r1,[r2,#0x68]         ;570
0000b0  64c1              STR      r1,[r0,#0x4c]         ;571
0000b2  6ed1              LDR      r1,[r2,#0x6c]         ;571
0000b4  6501              STR      r1,[r0,#0x50]         ;573
0000b6  6f11              LDR      r1,[r2,#0x70]         ;573
0000b8  6541              STR      r1,[r0,#0x54]         ;574
0000ba  6f51              LDR      r1,[r2,#0x74]         ;574
0000bc  6581              STR      r1,[r0,#0x58]         ;575
0000be  6f91              LDR      r1,[r2,#0x78]         ;575
0000c0  65c1              STR      r1,[r0,#0x5c]         ;576
0000c2  6fd1              LDR      r1,[r2,#0x7c]         ;576
0000c4  6601              STR      r1,[r0,#0x60]         ;577
0000c6  f8d21080          LDR      r1,[r2,#0x80]         ;577
0000ca  6641              STR      r1,[r0,#0x64]         ;578
0000cc  f8d21084          LDR      r1,[r2,#0x84]         ;578
0000d0  6681              STR      r1,[r0,#0x68]         ;579
0000d2  f8d21088          LDR      r1,[r2,#0x88]         ;579
0000d6  66c1              STR      r1,[r0,#0x6c]         ;580
0000d8  f8d2108c          LDR      r1,[r2,#0x8c]         ;580
0000dc  6701              STR      r1,[r0,#0x70]         ;585
0000de  bc38              POP      {r3-r5}
0000e0  2001              MOVS     r0,#1                 ;585
0000e2  4770              BX       lr
;;;590    
                          ENDP

                  |L18.228|
                          DCD      0x50060000
                  |L18.232|
                          DCD      0x000b03fc

                          AREA ||i.CRYP_StructInit||, CODE, READONLY, ALIGN=1

                  CRYP_StructInit PROC
;;;273      */
;;;274    void CRYP_StructInit(CRYP_InitTypeDef* CRYP_InitStruct)
000000  2100              MOVS     r1,#0
;;;275    {
;;;276      /* Initialize the CRYP_AlgoDir member */
;;;277      CRYP_InitStruct->CRYP_AlgoDir = CRYP_AlgoDir_Encrypt;
;;;278    
;;;279      /* initialize the CRYP_AlgoMode member */
;;;280      CRYP_InitStruct->CRYP_AlgoMode = CRYP_AlgoMode_TDES_ECB;
000002  6001              STR      r1,[r0,#0]
;;;281    
;;;282      /* initialize the CRYP_DataType member */
;;;283      CRYP_InitStruct->CRYP_DataType = CRYP_DataType_32b;
000004  6041              STR      r1,[r0,#4]
;;;284      
;;;285      /* Initialize the CRYP_KeySize member */
;;;286      CRYP_InitStruct->CRYP_KeySize = CRYP_KeySize_128b;
000006  6081              STR      r1,[r0,#8]
000008  60c1              STR      r1,[r0,#0xc]
;;;287    }
00000a  4770              BX       lr
;;;288    
                          ENDP


;*** Start embedded assembler ***

#line 1 "arm_hal\\lib\\stm32f4xx_cryp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_cryp_c_459f21d3____REV16|
#line 129 ".\\arm_hal\\lib\\core_cmInstr.h"
|__asm___16_stm32f4xx_cryp_c_459f21d3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_cryp_c_459f21d3____REVSH|
#line 144
|__asm___16_stm32f4xx_cryp_c_459f21d3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
