/**
 * File: behaviorPlaypenTest.cpp
 *
 * Author: Al Chaussee
 * Created: 07/25/17
 *
 * Description: Runs individual steps (behaviors) of playpen and manages switching between them and dealing
 *              with failures
 *
 * Copyright: Anki, Inc. 2017
 *
 **/

#include "engine/aiComponent/behaviorComponent/behaviors/devBehaviors/playpen/behaviorPlaypenTest.h"

#include "engine/actions/animActions.h"
#include "engine/actions/basicActions.h"
#include "engine/aiComponent/behaviorComponent/behaviorContainer.h"
#include "engine/aiComponent/behaviorComponent/behaviors/devBehaviors/playpen/iBehaviorPlaypen.h"
#include "engine/blockWorld/blockWorld.h"
#include "engine/components/bodyLightComponent.h"
#include "engine/components/cubes/cubeCommsComponent.h"
#include "engine/components/nvStorageComponent.h"
#include "engine/components/visionComponent.h"
#include "engine/cozmoContext.h"
#include "engine/robot.h"
#include "engine/robotManager.h"

#include "clad/types/behaviorComponent/behaviorTypes.h"

#include "util/console/consoleSystem.h"
#include "util/fileUtils/fileUtils.h"

#include "anki/cozmo/shared/factory/emrHelper.h"

#include <cstddef>

namespace Anki {
namespace Cozmo {

namespace {
  FactoryTestLogger _factoryTestLogger;
}

BehaviorPlaypenTest::BehaviorPlaypenTest(const Json::Value& config)
: ICozmoBehavior( config)
{
  
}


void BehaviorPlaypenTest::InitBehavior() 
{
  Robot& robot = GetBEI().GetRobotInfo()._robot;

  const BehaviorContainer& BC = GetBEI().GetBehaviorContainer();
  
  ICozmoBehaviorPtr waitToStartBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenWaitToStart);
  DEV_ASSERT(waitToStartBehavior != nullptr &&
             waitToStartBehavior->GetClass() == BehaviorClass::PlaypenWaitToStart,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenWaitToStart");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(waitToStartBehavior));

  ICozmoBehaviorPtr initCheckBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenInitChecks);
  DEV_ASSERT(initCheckBehavior != nullptr &&
             initCheckBehavior->GetClass() == BehaviorClass::PlaypenInitChecks,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenInitChecks");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(initCheckBehavior));
  
  ICozmoBehaviorPtr motorCalibBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenMotorCalibration);
  DEV_ASSERT(motorCalibBehavior != nullptr &&
             motorCalibBehavior->GetClass() == BehaviorClass::PlaypenMotorCalibration,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenMotorCalibration");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(motorCalibBehavior));
  
  ICozmoBehaviorPtr driftCheckBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenDriftCheck);
  DEV_ASSERT(driftCheckBehavior != nullptr &&
             driftCheckBehavior->GetClass() == BehaviorClass::PlaypenDriftCheck,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenDriftCheck");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driftCheckBehavior));
  
  ICozmoBehaviorPtr cameraCalibBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenCameraCalibration);
  DEV_ASSERT(cameraCalibBehavior != nullptr &&
             cameraCalibBehavior->GetClass() == BehaviorClass::PlaypenCameraCalibration,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenCameraCalibration");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(cameraCalibBehavior));

  ICozmoBehaviorPtr driveFowardsBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenDriveForwards);
  DEV_ASSERT(driveFowardsBehavior != nullptr &&
             driveFowardsBehavior->GetClass() == BehaviorClass::PlaypenDriveForwards,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenDriveForwards");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(driveFowardsBehavior));

  ICozmoBehaviorPtr soundCheckBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenSoundCheck);
  DEV_ASSERT(soundCheckBehavior != nullptr &&
             soundCheckBehavior->GetClass() == BehaviorClass::PlaypenSoundCheck,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenSoundCheck");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(soundCheckBehavior));
  
  ICozmoBehaviorPtr distanceSensorCheck80mm = BC.FindBehaviorByID(BehaviorID::PlaypenDistanceSensor80mm);
  DEV_ASSERT(distanceSensorCheck80mm != nullptr &&
             distanceSensorCheck80mm->GetClass() == BehaviorClass::PlaypenDistanceSensor,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenDistanceSensor100mm");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(distanceSensorCheck80mm));

  ICozmoBehaviorPtr pickupBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenPickupCube);
  DEV_ASSERT(pickupBehavior != nullptr &&
             pickupBehavior->GetClass() == BehaviorClass::PlaypenPickupCube,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenPickupCube");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(pickupBehavior));

  ICozmoBehaviorPtr endChecksBehavior = BC.FindBehaviorByID(BehaviorID::PlaypenEndChecks);
  DEV_ASSERT(endChecksBehavior != nullptr &&
             endChecksBehavior->GetClass() == BehaviorClass::PlaypenEndChecks,
             "BehaviorPlaypenTest.ImproperClassRetrievedForName.PlaypenEndChecks");
  _playpenBehaviors.push_back(std::static_pointer_cast<IBehaviorPlaypen>(endChecksBehavior));

  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  _currentBehavior = *_currentPlaypenBehaviorIter;

  if(robot.HasExternalInterface())
  {
    auto helper = MakeAnkiEventUtil(*robot.GetExternalInterface(), *this, _signalHandles);
    helper.SubscribeEngineToGame<ExternalInterface::MessageEngineToGameTag::PlaypenBehaviorFailed>();
    helper.SubscribeEngineToGame<ExternalInterface::MessageEngineToGameTag::EnterPairing>();
  }
  
  ICozmoBehavior::SubscribeToTags({RobotInterface::RobotToEngineTag::runFactoryTest});
}

void BehaviorPlaypenTest::GetAllDelegates(std::set<IBehavior*>& delegates) const
{
  for(auto& entry: _playpenBehaviors){
    delegates.insert(entry.get());
  }
}

  
void BehaviorPlaypenTest::OnBehaviorActivated()
{
  // DEPRECATED - Grabbing robot to support current cozmo code, but this should
  // be removed
  Robot& robot = GetBEI().GetRobotInfo()._robot;

  if(robot.HasExternalInterface())
  {
    robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::SetRobotVolume>(PlaypenConfig::kSoundVolume);
  }

  // Start the factory log
  std::stringstream serialNumString;
  serialNumString << std::hex << robot.GetHeadSerialNumber();
  _factoryTestLogger.StartLog( serialNumString.str(), true, robot.GetContextDataPlatform());
  PRINT_NAMED_INFO("BehaviorPlaypenTest.WillLogToDevice",
                   "Log name: %s",
                   _factoryTestLogger.GetLogName().c_str());
  
  // Set blind docking mode
  NativeAnkiUtilConsoleSetValueWithString("PickupDockingMethod", "0");
  
  // Disable driving animations
  NativeAnkiUtilConsoleSetValueWithString("EnableDrivingAnimations", "false");

  // Disable image streaming
  if(robot.IsPhysical())
  {
    NativeAnkiUtilConsoleSetValueWithString("ImageCompressQuality", "0");
  }
  
  // Make sure only Marker Detection mode is enabled; we don't need anything else running
  robot.GetVisionComponent().EnableMode(VisionMode::Idle, true); // first, turn everything off
  robot.GetVisionComponent().EnableMode(VisionMode::DetectingMarkers, true);
  
  // Set and disable auto exposure
  robot.GetVisionComponent().SetAndDisableAutoExposure(PlaypenConfig::kExposure_ms, PlaypenConfig::kGain);

  // Set and disable WhiteBalance
  robot.GetVisionComponent().SetAndDisableWhiteBalance(PlaypenConfig::kGain, PlaypenConfig::kGain, PlaypenConfig::kGain);
  
  // Disable block pool from auto connecting
  if(robot.HasExternalInterface())
  {
    robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::BlockPoolEnabledMessage>(0, false);
  }

  // Toggle cube discovery off and on
  robot.GetCubeCommsComponent().EnableDiscovery(false, PlaypenConfig::kActiveObjectDiscoveryTime_s);
  robot.GetCubeCommsComponent().EnableDiscovery(true, PlaypenConfig::kActiveObjectDiscoveryTime_s);

  // Request a WiFi scan
  if(!(Factory::GetEMR()->fields.playpenTestDisableMask & PlaypenTestMask::WifiScanError)) {
    PRINT_NAMED_INFO("BehaviorPlaypenTest.OnBehaviorActivated.SendingWifiScanRequest", "");
    robot.Broadcast(ExternalInterface::MessageEngineToGame(SwitchboardInterface::WifiScanRequest()));
  }
  
  // Enable writing factory data
  robot.GetNVStorageComponent().EnableWritingFactory(true);

  // Disable filtered touch sensor value tracking
  robot.EnableTrackTouchSensorFilt(false);
  
  _imuTemp.tempStart_c = robot.GetImuTemperature();
  _imuTemp.duration_ms = BaseStationTimer::getInstance()->GetCurrentTimeStamp();
  
  // Delegate to the first behavior
  _currentBehavior->WantsToBeActivated();
  DelegateNow(_currentBehavior.get());
}

void BehaviorPlaypenTest::OnBehaviorDeactivated()
{
  Reset();
}

void BehaviorPlaypenTest::Reset()
{
  // Reset all playpen behaviors
  for(auto& behavior : _playpenBehaviors)
  {
    behavior->Reset();
  }

  _behaviorStartTimes.clear();
  
  // Set current behavior to first playpen behavior
  _currentPlaypenBehaviorIter = _playpenBehaviors.begin();
  _currentBehavior = *_currentPlaypenBehaviorIter;
  
  // Clear imu temp struct
  _imuTemp = IMUTempDuration();
}

void BehaviorPlaypenTest::BehaviorUpdate()
{
  if(_currentBehavior != nullptr)
  {
    // Check if the current behavior has failed
    const FactoryTestResultCode result = _currentBehavior->GetResult();
    if(result != FactoryTestResultCode::UNKNOWN &&
       result != FactoryTestResultCode::SUCCESS)
    {
      // _currentBehavior->OnDeactivated();
      
      PRINT_NAMED_WARNING("BehaviorPlaypenTest.Update.BehaviorFailed",
                          "Behavior %s failed with %s",
                          _currentBehavior->GetDebugLabel().c_str(),
                          EnumToString(_currentBehavior->GetResult()));
      
      HandleResult(result);
      //return RESULT_FAIL;
    }
  }

  // If the current behavior has completed
  if(_currentBehavior->GetResult() == FactoryTestResultCode::SUCCESS)
  {    
    // Move to the next behavior
    _currentPlaypenBehaviorIter++;
    
    // If we still have behaviors to run
    if(_currentPlaypenBehaviorIter != _playpenBehaviors.end())
    {
      // Update current behavior
      _currentBehavior = *_currentPlaypenBehaviorIter;
      DEV_ASSERT(_currentBehavior != nullptr, "BehaviorPlaypenTest.BehaviorUpdate.NullCurrentBehavior");
      
      if(!_currentBehavior->WantsToBeActivated())
      {
        PRINT_NAMED_ERROR("BehaviorPlaypenTest.ChooseNextBehaviorInternal.BehaviorNotRunnable",
                          "Current behavior %s is not runnable",
                          _currentBehavior->GetDebugLabel().c_str());
        
        HandleResult(FactoryTestResultCode::BEHAVIOR_NOT_RUNNABLE);
      }
      
      _behaviorStartTimes.push_back(BaseStationTimer::getInstance()->GetCurrentTimeStamp());

      DelegateNow(_currentBehavior.get());
    }
    // All playpen behaviors have run so success!
    else
    {
      PRINT_NAMED_INFO("BehaviorPlaypenTest.Complete", "All behaviors have been run");
      HandleResult(FactoryTestResultCode::SUCCESS);
    }
  }
}


void BehaviorPlaypenTest::HandleResult(FactoryTestResultCode result)
{
  PRINT_NAMED_INFO("BehaviorPlaypenTest.HandleResult.OrigResult", 
                   "%s", EnumToString(result));

  // DEPRECATED - Grabbing robot to support current cozmo code, but this should
  // be removed
  Robot& robot = GetBEI().GetRobotInfo()._robot;

  // Update imu temp struct with the final temperature and append it to log
  _imuTemp.tempEnd_c = robot.GetImuTemperature();
  _imuTemp.duration_ms = BaseStationTimer::getInstance()->GetCurrentTimeStamp() - _imuTemp.duration_ms;
  if(!_factoryTestLogger.Append(_imuTemp))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.WriteToLogFailed.ImuTemp", "");
    result = FactoryTestResultCode::WRITE_TO_LOG_FAILED;
  }
  
  const auto& allResults = IBehaviorPlaypen::GetAllPlaypenResults();
  // Write all playpen behavior results to log if we are ignoring failures
  if(PlaypenConfig::kIgnoreFailures &&
     !_factoryTestLogger.Append(allResults))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.WriteToLogFailed.AllResults", "");
    result = FactoryTestResultCode::WRITE_TO_LOG_FAILED;
  }

  // If this is a success but we are ignoring failures a behavior may have actually
  // failed so check all results
  if(result == FactoryTestResultCode::SUCCESS && PlaypenConfig::kIgnoreFailures)
  {
    for(const auto& resultPair : allResults)
    {
      for(const auto& res : resultPair.second)
      {
        if(res != FactoryTestResultCode::SUCCESS)
        {
          result = res;
          PRINT_NAMED_INFO("BehaviorPlaypenTest.HandleResultInternal.ChangingResult",
                           "%s actually failed with %s, changing result",
                           resultPair.first.c_str(), EnumToString(res));
          break;
        }
      }
    }
  }

  IBehaviorPlaypen::ResetAllPlaypenResults();

  // Only check EMR PLAYPEN_READY_FLAG on success so that we can run robots through 
  // playpen to check sensors and stuff before even if they have not passed previous fixtures
  if(result == FactoryTestResultCode::SUCCESS &&
     (Factory::GetEMR() == nullptr || 
      !Factory::GetEMR()->fields.PLAYPEN_READY_FLAG))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.NotReadyForPlaypen", 
                        "Either couldn't read EMR or robot not ready for playpen");
    result = FactoryTestResultCode::ROBOT_FAILED_PREPLAYPEN_TESTS;
  }

  FactoryTestResultEntry resultEntry;
  
  _behaviorStartTimes.resize(resultEntry.timestamps.size());
  _behaviorStartTimes[_behaviorStartTimes.size() - 1] = BaseStationTimer::getInstance()->GetCurrentTimeStamp();

  resultEntry.result = result;
  resultEntry.engineSHA1 = 0; // TODO: Populate
  resultEntry.utcTime = time(0);
  resultEntry.stationID = 0; // TODO: Populate from fixture
  std::copy(_behaviorStartTimes.begin(),
            _behaviorStartTimes.begin() + resultEntry.timestamps.size(),
            resultEntry.timestamps.begin());
  
  u8 buf[resultEntry.Size()];
  size_t numBytes = resultEntry.Pack(buf, sizeof(buf));
  if(PlaypenConfig::kWriteToStorage &&
     !robot.GetNVStorageComponent().Write(NVStorage::NVEntryTag::NVEntry_PlaypenTestResults,
                                          buf,
                                          numBytes))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.WriteTestResultToRobotFailed",
                        "Writing test results to robot failed");
    resultEntry.result = FactoryTestResultCode::TEST_RESULT_WRITE_FAILED;
    result = FactoryTestResultCode::TEST_RESULT_WRITE_FAILED;
  }

  if(!_factoryTestLogger.Append(resultEntry))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.WriteToLogFailed",
                        "Failed to write result entry to log");
    result = FactoryTestResultCode::WRITE_TO_LOG_FAILED;
  }

  if((result == FactoryTestResultCode::SUCCESS) && PlaypenConfig::kWriteToStorage)
  {
    time_t nowTime = time(0);
    struct tm* tmStruct = gmtime(&nowTime);
    
    // TODO: System time will be incorrect need to have a fixture set it
    BirthCertificate bc;
    bc.year   = static_cast<u8>(tmStruct->tm_year % 100);
    bc.month  = static_cast<u8>(tmStruct->tm_mon + 1); // Months start at zero
    bc.day    = static_cast<u8>(tmStruct->tm_mday);
    bc.hour   = static_cast<u8>(tmStruct->tm_hour);
    bc.minute = static_cast<u8>(tmStruct->tm_min);
    bc.second = static_cast<u8>(tmStruct->tm_sec);
    
    u8 buf[bc.Size()];
    size_t numBytes = bc.Pack(buf, sizeof(buf));

    if(!robot.GetNVStorageComponent().Write(NVStorage::NVEntryTag::NVEntry_BirthCertificate,
                                            buf,
                                            numBytes))
    {
      PRINT_NAMED_ERROR("BehaviorPlaypenTest.HandleResultInternal.BCWriteFailed", "");
      resultEntry.result = FactoryTestResultCode::BIRTH_CERTIFICATE_WRITE_FAILED;
      result = FactoryTestResultCode::BIRTH_CERTIFICATE_WRITE_FAILED;
    }


    static_assert(sizeof(Factory::EMR::Fields::playpen) >= sizeof(BirthCertificate),
                  "Not enough space for BirthCertificate in EMR::Playpen");
    Factory::WriteEMR(offsetof(Factory::EMR::Fields, playpen)/sizeof(uint32_t), buf, sizeof(buf));
  }

  const u32 kPlaypenPassedFlag = ((result == FactoryTestResultCode::SUCCESS) ? 1 : 0);
  Factory::WriteEMR(offsetof(Factory::EMR::Fields, PLAYPEN_PASSED_FLAG)/sizeof(uint32_t), kPlaypenPassedFlag);
  
  robot.Broadcast(ExternalInterface::MessageEngineToGame(FactoryTestResultEntry(resultEntry)));

  PRINT_NAMED_INFO("BehaviorPlaypenTest.HandleResultInternal.Result", 
                   "Playpen completed with %s",
                   EnumToString(result));

  // Copy engine logs if the test failed or we are ignoring failures
  if((result != FactoryTestResultCode::SUCCESS || PlaypenConfig::kIgnoreFailures) &&
     !_factoryTestLogger.CopyEngineLog(robot.GetContextDataPlatform()))
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.CopyEngineLogFailed", "");
  }
  _factoryTestLogger.CloseLog();

  DisplayResult(result);
  
  // Reset playpen
  Reset();

  // Fake being re-activated to startup playpen again
  OnBehaviorActivated();

  // If data directory is too large, delete it
  if(Util::FileUtils::GetDirectorySize(PlaypenConfig::kDataDirPath) > PlaypenConfig::kMaxDataDirSize_bytes)
  {
    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleResultInternal.DeletingDataDir",
                        "%s is larger than %zd, deleting",
                        PlaypenConfig::kDataDirPath.c_str(),
                        PlaypenConfig::kMaxDataDirSize_bytes);

    Util::FileUtils::RemoveDirectory(PlaypenConfig::kDataDirPath);
  }
  
  // TODO(Al): Turn off Victor at end of playpen?
}

void BehaviorPlaypenTest::DisplayResult(FactoryTestResultCode result)
{
  // DEPRECATED - Grabbing robot to support current cozmo code, but this should
  // be removed
  Robot& robot = GetBEI().GetRobotInfo()._robot;

  if(result == FactoryTestResultCode::SUCCESS)
  {
    static const BackpackLights passLights = {
      .onColors               = {{NamedColors::GREEN,NamedColors::GREEN,NamedColors::GREEN}},
      .offColors              = {{NamedColors::BLACK,NamedColors::BLACK,NamedColors::BLACK}},
      .onPeriod_ms            = {{1000,1000,1000}},
      .offPeriod_ms           = {{100,100,100}},
      .transitionOnPeriod_ms  = {{450,450,450}},
      .transitionOffPeriod_ms = {{450,450,450}},
      .offset                 = {{0,0,0}}
    };
    
    robot.GetBodyLightComponent().SetBackpackLights(passLights);

    robot.SendMessage(RobotInterface::EngineToRobot(RobotInterface::DrawTextOnScreen(true,
                                                                                     RobotInterface::ColorRGB(0,0,0),
                                                                                     RobotInterface::ColorRGB(0,255,0),
                                                                                     "OK")));
  }
  else
  {
    PlayAnimationAction* action = new PlayAnimationAction("playpenFailAnim");
    robot.GetActionList().AddConcurrentAction(action);

    static const BackpackLights failLights = {
      .onColors               = {{NamedColors::RED,NamedColors::RED,NamedColors::RED}},
      .offColors              = {{NamedColors::BLACK,NamedColors::BLACK,NamedColors::BLACK}},
      .onPeriod_ms            = {{500,500,500}},
      .offPeriod_ms           = {{500,500,500}},
      .transitionOnPeriod_ms  = {{0,0,0}},
      .transitionOffPeriod_ms = {{0,0,0}},
      .offset                 = {{0,0,0}}
    };
    
    robot.GetBodyLightComponent().SetBackpackLights(failLights);

    // Draw result to screen
    robot.SendMessage(RobotInterface::EngineToRobot(RobotInterface::DrawTextOnScreen(true,
                                                                                     RobotInterface::ColorRGB(0,0,0),
                                                                                     RobotInterface::ColorRGB(255,0,0),
                                                                                     std::to_string((u32)result))));
  }
}

FactoryTestLogger& BehaviorPlaypenTest::GetFactoryTestLogger()
{
  return _factoryTestLogger;
}

template<>
void BehaviorPlaypenTest::HandleMessage(const ExternalInterface::PlaypenBehaviorFailed& msg)
{
  PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleMessage.PlaypenBehaviorFailed",
                      "Some behavior failed with %s%s",
                      EnumToString(msg.result),
                      (PlaypenConfig::kIgnoreFailures ? ", ignoring" : ""));

  if(!PlaypenConfig::kIgnoreFailures)
  {
    if(_currentBehavior != nullptr)
    {
      _currentBehavior->OnDeactivated();
    }

    HandleResult(msg.result);
  }
}

template<>
void BehaviorPlaypenTest::HandleMessage(const SwitchboardInterface::EnterPairing& msg)
{
  // Only have playpen handle this message if this is the factory test and
  // we have not been packed out
  if(FACTORY_TEST)
  {
    BEGIN_DONT_RUN_AFTER_PACKOUT

    PRINT_NAMED_WARNING("BehaviorPlaypenTest.HandleMessage.EnterPairing",
                        "Pairing mode triggered. Exiting playpen test.");

    // Reset playpen
    Reset();

    // Fake being re-activated to startup playpen again
    OnBehaviorActivated();

    END_DONT_RUN_AFTER_PACKOUT
  }
}

void BehaviorPlaypenTest::AlwaysHandleInScope(const RobotToEngineEvent& event)
{
  BEGIN_DONT_RUN_AFTER_PACKOUT
  if(FACTORY_TEST)
  {
    const auto& tag = event.GetData().GetTag();
    if(tag != RobotInterface::RobotToEngineTag::runFactoryTest)
    {
      return;
    }
    
    Robot& robot = GetBEI().GetRobotInfo()._robot;
    
    const auto& payload = event.GetData().Get_runFactoryTest();
    switch(payload.test)
    {
      // Mic test is not supported at this time
      case RobotInterface::FactoryTest::MIC_TEST:
        {
          PRINT_NAMED_ERROR("BehaviorPlaypenTest.RunFactoryMicTest.Unsupported", "");
        }
        break;

      // Speaker test
      // First payload arg is which tone to use
      //   (0: 1khz 200ms beep, 1: bell/ding)
      // Second arg is volume from 0 - 255
      case RobotInterface::FactoryTest::SPEAKER_TEST:
        {
          robot.GetExternalInterface()->BroadcastToEngine<ExternalInterface::SetRobotVolume>(payload.args[1] / 255.f);

          const uint8_t whichTone = payload.args[0];
          // 200ms 1khz beep
          if(whichTone == 0)
          {
            CompoundActionParallel* action = new CompoundActionParallel();
            std::weak_ptr<IActionRunner> soundAction = action->AddAction(new PlayAnimationAction("soundTestAnim"));

            // Start WaitForLambdaAction in parallel that will cancel the sound action after 200 milliseconds
            WaitForLambdaAction* waitAction = new WaitForLambdaAction([soundAction](Robot& robot){
              static TimeStamp_t start = 0;
              if(start == 0)
              {
                start = BaseStationTimer::getInstance()->GetCurrentTimeStamp();
              }

              if(BaseStationTimer::getInstance()->GetCurrentTimeStamp() - start > 200)
              {
                start = 0;
                auto sp = soundAction.lock();
                if(sp != nullptr)
                {
                  sp->Cancel();
                  return true;
                }
              }

              return false;
            });
            action->AddAction(waitAction);
            robot.GetActionList().AddConcurrentAction(action);
          }
          // "Pleasant" bell sound 
          else if(whichTone == 1)
          {
            PlayAnimationAction* action = new PlayAnimationAction("soundTestAnimBell");
            robot.GetActionList().AddConcurrentAction(action);
          }
        }
        break;

      case RobotInterface::FactoryTest::TOUCH_SENSOR_INVALID:
        {
          // If this check is enabled
          if(!(Factory::GetEMR()->fields.playpenTestDisableMask & PlaypenTestMask::BackpackElectricalError))
          {

            // Ignore if playpen is waiting to start.
            // Otherwise, a call to HandleResult() here when TOUCH_SENSOR_INVALID is received
            // results in some operations that take ~1 sec (seems to be CopyEngineLog()) which
            // is roughly how often the TOUCH_SENSOR_INVALID message comes in. 
            // Eventually, engine falls behind by seconds in handling the message and crashes 
            // due to sockets filling up.
            if (_currentPlaypenBehaviorIter == _playpenBehaviors.begin()) {
              PRINT_NAMED_INFO("BehaviorPlaypenTest.AlwaysHandleInScope.IgnoringTouchSensorInvalidWhileWaitingToStart", "");
              break;
            }

            // Stop the current behavior
            if(_currentBehavior != nullptr)
            {
              _currentBehavior->OnDeactivated();
            }
            HandleResult(FactoryTestResultCode::BACKPACK_ELECTRICAL_ERROR);
          }
          else
          {
            PRINT_PERIODIC_CH_INFO(5,"Behavior","BehaviorPlaypenTest.SkippingTouchSensorInvalid","");
          }
        }
        break;
      case RobotInterface::FactoryTest::COUNT:
        break;
    }
  }
  END_DONT_RUN_AFTER_PACKOUT
}
  
}
}

