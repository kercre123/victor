// Autogenerated C++ message buffer code.
// Source: util/questEngine/questEngineMessages.clad
// Full command line: ../../../tools/message-buffers/emitters/CPP_emitter.py -C . -o .. ./util/questEngine/questEngineMessages.clad

#include "util/questEngine/questEngineMessages.h"

namespace Anki {

namespace Util {

namespace QuestEngine {

// MESSAGE NoticePair

NoticePair::NoticePair(const uint8_t* buff, size_t len)
{
  const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
  Unpack(buffer);
}

NoticePair::NoticePair(const CLAD::SafeMessageBuffer& buffer)
{
  Unpack(buffer);
}

size_t NoticePair::Pack(uint8_t* buff, size_t len) const
{
  CLAD::SafeMessageBuffer buffer(buff, len, false);
  return Pack(buffer);
}

size_t NoticePair::Pack(CLAD::SafeMessageBuffer& buffer) const
{
  buffer.Write(this->force);
  buffer.Write(this->priority);
  buffer.Write(this->noticeTime);
  buffer.WritePString<uint8_t>(this->guid);
  buffer.WritePString<uint8_t>(this->target);
  buffer.WritePString<uint8_t>(this->titleKey);
  buffer.WritePString<uint8_t>(this->descriptionKey);
  buffer.WritePString<uint8_t>(this->buttonKey);
  buffer.WritePString<uint8_t>(this->navigationAction);
  const size_t bytesWritten {buffer.GetBytesWritten()};
  return bytesWritten;
}

size_t NoticePair::Unpack(const uint8_t* buff, const size_t len)
{
  const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
  return Unpack(buffer);
}

size_t NoticePair::Unpack(const CLAD::SafeMessageBuffer& buffer)
{
  buffer.Read(this->force);
  buffer.Read(this->priority);
  buffer.Read(this->noticeTime);
  buffer.ReadPString<uint8_t>(this->guid);
  buffer.ReadPString<uint8_t>(this->target);
  buffer.ReadPString<uint8_t>(this->titleKey);
  buffer.ReadPString<uint8_t>(this->descriptionKey);
  buffer.ReadPString<uint8_t>(this->buttonKey);
  buffer.ReadPString<uint8_t>(this->navigationAction);
  return buffer.GetBytesRead();
}

size_t NoticePair::Size() const
{
  size_t result = 0;
  // force
  result += 1; // bool
  // priority
  result += 1; // uint_8
  // noticeTime
  result += 8; // float_64
  // guid
  result += 1; // uint_8 (string length)
  result += this->guid.length(); // uint_8
  // target
  result += 1; // uint_8 (string length)
  result += this->target.length(); // uint_8
  // titleKey
  result += 1; // uint_8 (string length)
  result += this->titleKey.length(); // uint_8
  // descriptionKey
  result += 1; // uint_8 (string length)
  result += this->descriptionKey.length(); // uint_8
  // buttonKey
  result += 1; // uint_8 (string length)
  result += this->buttonKey.length(); // uint_8
  // navigationAction
  result += 1; // uint_8 (string length)
  result += this->navigationAction.length(); // uint_8
  return result;
}

bool NoticePair::operator==(const NoticePair& other) const
{
  return (this->force == other.force &&
    this->priority == other.priority &&
    this->noticeTime == other.noticeTime &&
    this->guid == other.guid &&
    this->target == other.target &&
    this->titleKey == other.titleKey &&
    this->descriptionKey == other.descriptionKey &&
    this->buttonKey == other.buttonKey &&
    this->navigationAction == other.navigationAction);
}

bool NoticePair::operator!=(const NoticePair& other) const
{
  return !(operator==(other));
}


// MESSAGE EventPair

EventPair::EventPair(const uint8_t* buff, size_t len)
{
  const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
  Unpack(buffer);
}

EventPair::EventPair(const CLAD::SafeMessageBuffer& buffer)
{
  Unpack(buffer);
}

size_t EventPair::Pack(uint8_t* buff, size_t len) const
{
  CLAD::SafeMessageBuffer buffer(buff, len, false);
  return Pack(buffer);
}

size_t EventPair::Pack(CLAD::SafeMessageBuffer& buffer) const
{
  buffer.WritePString<uint8_t>(this->eventName);
  buffer.Write(this->count);
  const size_t bytesWritten {buffer.GetBytesWritten()};
  return bytesWritten;
}

size_t EventPair::Unpack(const uint8_t* buff, const size_t len)
{
  const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
  return Unpack(buffer);
}

size_t EventPair::Unpack(const CLAD::SafeMessageBuffer& buffer)
{
  buffer.ReadPString<uint8_t>(this->eventName);
  buffer.Read(this->count);
  return buffer.GetBytesRead();
}

size_t EventPair::Size() const
{
  size_t result = 0;
  // eventName
  result += 1; // uint_8 (string length)
  result += this->eventName.length(); // uint_8
  // count
  result += 4; // uint_32
  return result;
}

bool EventPair::operator==(const EventPair& other) const
{
  return (this->eventName == other.eventName &&
    this->count == other.count);
}

bool EventPair::operator!=(const EventPair& other) const
{
  return !(operator==(other));
}


// MESSAGE TriggerLog

TriggerLog::TriggerLog(const uint8_t* buff, size_t len)
{
  const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
  Unpack(buffer);
}

TriggerLog::TriggerLog(const CLAD::SafeMessageBuffer& buffer)
{
  Unpack(buffer);
}

size_t TriggerLog::Pack(uint8_t* buff, size_t len) const
{
  CLAD::SafeMessageBuffer buffer(buff, len, false);
  return Pack(buffer);
}

size_t TriggerLog::Pack(CLAD::SafeMessageBuffer& buffer) const
{
  buffer.WritePString<uint8_t>(this->ruleId);
  buffer.WriteVArray<double, uint16_t>(this->triggerTimes);
  const size_t bytesWritten {buffer.GetBytesWritten()};
  return bytesWritten;
}

size_t TriggerLog::Unpack(const uint8_t* buff, const size_t len)
{
  const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
  return Unpack(buffer);
}

size_t TriggerLog::Unpack(const CLAD::SafeMessageBuffer& buffer)
{
  buffer.ReadPString<uint8_t>(this->ruleId);
  buffer.ReadVArray<double, uint16_t>(this->triggerTimes);
  return buffer.GetBytesRead();
}

size_t TriggerLog::Size() const
{
  size_t result = 0;
  // ruleId
  result += 1; // uint_8 (string length)
  result += this->ruleId.length(); // uint_8
  // triggerTimes
  result += 2; // uint_16 (array length)
  result += 8 * this->triggerTimes.size(); // float_64
  return result;
}

bool TriggerLog::operator==(const TriggerLog& other) const
{
  return (this->ruleId == other.ruleId &&
    this->triggerTimes == other.triggerTimes);
}

bool TriggerLog::operator!=(const TriggerLog& other) const
{
  return !(operator==(other));
}


// MESSAGE QuestStore

QuestStore::QuestStore(const uint8_t* buff, size_t len)
{
  const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
  Unpack(buffer);
}

QuestStore::QuestStore(const CLAD::SafeMessageBuffer& buffer)
{
  Unpack(buffer);
}

size_t QuestStore::Pack(uint8_t* buff, size_t len) const
{
  CLAD::SafeMessageBuffer buffer(buff, len, false);
  return Pack(buffer);
}

size_t QuestStore::Pack(CLAD::SafeMessageBuffer& buffer) const
{
  buffer.Write(static_cast<uint16_t>(eventStats.size()));
  for (const Anki::Util::QuestEngine::EventPair& m : eventStats) {
    m.Pack(buffer);
  }
  buffer.Write(static_cast<uint16_t>(notices.size()));
  for (const Anki::Util::QuestEngine::NoticePair& m : notices) {
    m.Pack(buffer);
  }
  buffer.Write(static_cast<uint16_t>(ruleTriggers.size()));
  for (const Anki::Util::QuestEngine::TriggerLog& m : ruleTriggers) {
    m.Pack(buffer);
  }
  const size_t bytesWritten {buffer.GetBytesWritten()};
  return bytesWritten;
}

size_t QuestStore::Unpack(const uint8_t* buff, const size_t len)
{
  const CLAD::SafeMessageBuffer buffer(const_cast<uint8_t*>(buff), len, false);
  return Unpack(buffer);
}

size_t QuestStore::Unpack(const CLAD::SafeMessageBuffer& buffer)
{
  buffer.ReadCompoundTypeVArray<Anki::Util::QuestEngine::EventPair, uint16_t>(this->eventStats);
  buffer.ReadCompoundTypeVArray<Anki::Util::QuestEngine::NoticePair, uint16_t>(this->notices);
  buffer.ReadCompoundTypeVArray<Anki::Util::QuestEngine::TriggerLog, uint16_t>(this->ruleTriggers);
  return buffer.GetBytesRead();
}

size_t QuestStore::Size() const
{
  size_t result = 0;
  // eventStats
  result += 2; // uint_16 (array length)
  for (const Anki::Util::QuestEngine::EventPair& m : this->eventStats) {
    result += m.Size();
  }
  // notices
  result += 2; // uint_16 (array length)
  for (const Anki::Util::QuestEngine::NoticePair& m : this->notices) {
    result += m.Size();
  }
  // ruleTriggers
  result += 2; // uint_16 (array length)
  for (const Anki::Util::QuestEngine::TriggerLog& m : this->ruleTriggers) {
    result += m.Size();
  }
  return result;
}

bool QuestStore::operator==(const QuestStore& other) const
{
  return (this->eventStats == other.eventStats &&
    this->notices == other.notices &&
    this->ruleTriggers == other.ruleTriggers);
}

bool QuestStore::operator!=(const QuestStore& other) const
{
  return !(operator==(other));
}


} // namespace QuestEngine

} // namespace Util

} // namespace Anki

