<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Royale: royale::Vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="royale-logo-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Royale
   </div>
   <div id="projectbrief">powerful software framework for time-of-flight cameras</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00207.html">royale</a></li><li class="navelem"><a class="el" href="a00108.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00270.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">royale::Vector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a00205_source.html">Vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afe89de40b9f9dd1d98934b00fb3e6413"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00084.html">royale::iterator::royale_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a></td></tr>
<tr class="memdesc:afe89de40b9f9dd1d98934b00fb3e6413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator definitions.  <a href="#afe89de40b9f9dd1d98934b00fb3e6413">More...</a><br /></td></tr>
<tr class="separator:afe89de40b9f9dd1d98934b00fb3e6413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9c16f6656afa6bb848e8b3b6962fbb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00074.html">royale::iterator::royale_const_iterator</a>&lt; std::random_access_iterator_tag, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a></td></tr>
<tr class="separator:ace9c16f6656afa6bb848e8b3b6962fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345b6aabe433b423c419b87699e38554"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00093.html">royale::iterator::royale_reverse_iterator</a>&lt; <a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a345b6aabe433b423c419b87699e38554">reverse_iterator</a></td></tr>
<tr class="separator:a345b6aabe433b423c419b87699e38554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae551b7505e41b02337ef7faf214c001b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00075.html">royale::iterator::royale_const_reverse_iterator</a>&lt; <a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a></td></tr>
<tr class="separator:ae551b7505e41b02337ef7faf214c001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f7046ec665a417b4916a8d61d5c1e6"><td class="memItemLeft" align="right" valign="top">typedef const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ac5f7046ec665a417b4916a8d61d5c1e6">const_pointer</a></td></tr>
<tr class="memdesc:ac5f7046ec665a417b4916a8d61d5c1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">General <a class="el" href="a00108.html">Vector</a> definitions.  <a href="#ac5f7046ec665a417b4916a8d61d5c1e6">More...</a><br /></td></tr>
<tr class="separator:ac5f7046ec665a417b4916a8d61d5c1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c382fd56871e64a7b4a73c4b0bfb66"><td class="memItemLeft" align="right" valign="top">typedef const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a89c382fd56871e64a7b4a73c4b0bfb66">const_reference</a></td></tr>
<tr class="separator:a89c382fd56871e64a7b4a73c4b0bfb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9629956720d18a047f71e79a234826e8"><td class="memItemLeft" align="right" valign="top">typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a9629956720d18a047f71e79a234826e8">pdifference_type</a></td></tr>
<tr class="separator:a9629956720d18a047f71e79a234826e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03da8b51714ed717924a5707ad41d53b"><td class="memItemLeft" align="right" valign="top">typedef T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a03da8b51714ed717924a5707ad41d53b">pointer</a></td></tr>
<tr class="separator:a03da8b51714ed717924a5707ad41d53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c5527991dba00b103732a1bb04b669"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a94c5527991dba00b103732a1bb04b669">size_type</a></td></tr>
<tr class="separator:a94c5527991dba00b103732a1bb04b669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9880be8c3d5a637d76f7cb2c3e8bd09c"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a></td></tr>
<tr class="separator:a9880be8c3d5a637d76f7cb2c3e8bd09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac3aef4b8475c957a9adcd934f306be"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a0ac3aef4b8475c957a9adcd934f306be">reference</a></td></tr>
<tr class="separator:a0ac3aef4b8475c957a9adcd934f306be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac80f0477577f681b5b89b3f9609340e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ac80f0477577f681b5b89b3f9609340e9">Vector</a> ()</td></tr>
<tr class="memdesc:ac80f0477577f681b5b89b3f9609340e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">General constructor, which does not allocate memory and sets everything to it's default.  <a href="#ac80f0477577f681b5b89b3f9609340e9">More...</a><br /></td></tr>
<tr class="separator:ac80f0477577f681b5b89b3f9609340e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c88cbc155e88cf3d0502b74a02f9ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a96c88cbc155e88cf3d0502b74a02f9ab">Vector</a> (size_t <a class="el" href="a00108.html#a0ca30cb729aa167dbaef001172b05f7c">size</a>)</td></tr>
<tr class="memdesc:a96c88cbc155e88cf3d0502b74a02f9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which already performs an allocation of memory during execution Constructs a given number of elements.  <a href="#a96c88cbc155e88cf3d0502b74a02f9ab">More...</a><br /></td></tr>
<tr class="separator:a96c88cbc155e88cf3d0502b74a02f9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a76ebeb3f02f924f70125bb40a5eabf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a0a76ebeb3f02f924f70125bb40a5eabf">Vector</a> (size_t n, const T &amp;item)</td></tr>
<tr class="memdesc:a0a76ebeb3f02f924f70125bb40a5eabf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor which already performs an allocation of memory during execution Constructs the given number of elements pre-initialized with the value of item.  <a href="#a0a76ebeb3f02f924f70125bb40a5eabf">More...</a><br /></td></tr>
<tr class="separator:a0a76ebeb3f02f924f70125bb40a5eabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62308fb469ae0f131bd84e8a414d4670"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a62308fb469ae0f131bd84e8a414d4670">Vector</a> (const <a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a62308fb469ae0f131bd84e8a414d4670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-Constructor for royale compliant vector which allows creation of a royale compliant vector from another royale compliant vector - (NOTE: performs a deep copy!)  <a href="#a62308fb469ae0f131bd84e8a414d4670">More...</a><br /></td></tr>
<tr class="separator:a62308fb469ae0f131bd84e8a414d4670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ac272a9576eb1550b489380294330c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a42ac272a9576eb1550b489380294330c">Vector</a> (<a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&amp;v)</td></tr>
<tr class="memdesc:a42ac272a9576eb1550b489380294330c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-Constructor for royale compliant vector which allows creation of a royale compliant vector by moving memory (NOTE: performs a shallow copy!)  <a href="#a42ac272a9576eb1550b489380294330c">More...</a><br /></td></tr>
<tr class="separator:a42ac272a9576eb1550b489380294330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779e7fda288a902cf2f3224115fd7624"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a779e7fda288a902cf2f3224115fd7624">Vector</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a779e7fda288a902cf2f3224115fd7624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-Constructor for STL compliant vector (std::vector) It allows creation of a royale compliant vector from a STL compliant vector - (NOTE: performs a deep copy!)  <a href="#a779e7fda288a902cf2f3224115fd7624">More...</a><br /></td></tr>
<tr class="separator:a779e7fda288a902cf2f3224115fd7624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834e2045a234c8e81690a89d46899f9e"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a834e2045a234c8e81690a89d46899f9e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a834e2045a234c8e81690a89d46899f9e">Vector</a> (InputIterator <a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a>, InputIterator <a class="el" href="a00108.html#a15884c7e3cc99ef4afa936e23695973e">last</a>)</td></tr>
<tr class="memdesc:a834e2045a234c8e81690a89d46899f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with an input iterator.  <a href="#a834e2045a234c8e81690a89d46899f9e">More...</a><br /></td></tr>
<tr class="separator:a834e2045a234c8e81690a89d46899f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3">Vector</a> (const std::initializer_list&lt; T &gt; &amp;list)</td></tr>
<tr class="memdesc:ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer list initialization to initialize a vector.  <a href="#ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3">More...</a><br /></td></tr>
<tr class="separator:ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f6e58246c226d67ad4337f2291e81b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ac3f6e58246c226d67ad4337f2291e81b">~Vector</a> ()</td></tr>
<tr class="memdesc:ac3f6e58246c226d67ad4337f2291e81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ac3f6e58246c226d67ad4337f2291e81b">More...</a><br /></td></tr>
<tr class="separator:ac3f6e58246c226d67ad4337f2291e81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca30cb729aa167dbaef001172b05f7c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a0ca30cb729aa167dbaef001172b05f7c">size</a> () const </td></tr>
<tr class="memdesc:a0ca30cb729aa167dbaef001172b05f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual size of the vector (this is the used amount of slots in the allocated area) equivalent to <a class="el" href="a00108.html#ade43a55376e0c1a32060a0dc01085e2f" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) equiva...">count()</a>  <a href="#a0ca30cb729aa167dbaef001172b05f7c">More...</a><br /></td></tr>
<tr class="separator:a0ca30cb729aa167dbaef001172b05f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade43a55376e0c1a32060a0dc01085e2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ade43a55376e0c1a32060a0dc01085e2f">count</a> () const </td></tr>
<tr class="memdesc:ade43a55376e0c1a32060a0dc01085e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the actual size of the vector (this is the used amount of slots in the allocated area) equivalent to <a class="el" href="a00108.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) equiva...">size()</a>  <a href="#ade43a55376e0c1a32060a0dc01085e2f">More...</a><br /></td></tr>
<tr class="separator:ade43a55376e0c1a32060a0dc01085e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348f55e8aa9b70d115a25f9627e4c64a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a348f55e8aa9b70d115a25f9627e4c64a">empty</a> () const </td></tr>
<tr class="memdesc:a348f55e8aa9b70d115a25f9627e4c64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the vector is empty.  <a href="#a348f55e8aa9b70d115a25f9627e4c64a">More...</a><br /></td></tr>
<tr class="separator:a348f55e8aa9b70d115a25f9627e4c64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf5f7e6860d6f6a720e40df40253622"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#afdf5f7e6860d6f6a720e40df40253622">capacity</a> () const </td></tr>
<tr class="memdesc:afdf5f7e6860d6f6a720e40df40253622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of allocated slots which are maintained by the vector These allocated slots might be used or unused (refer to <a class="el" href="a00108.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) equiva...">size()</a> for checking the <a class="el" href="a00108.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) equiva...">size()</a> itself)  <a href="#afdf5f7e6860d6f6a720e40df40253622">More...</a><br /></td></tr>
<tr class="separator:afdf5f7e6860d6f6a720e40df40253622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18917eb9ec72f0e745c332a8de2c4b7"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ad18917eb9ec72f0e745c332a8de2c4b7">data</a> ()</td></tr>
<tr class="memdesc:ad18917eb9ec72f0e745c332a8de2c4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a direct pointer to the memory array used internally by the vector to store its owned elements.  <a href="#ad18917eb9ec72f0e745c332a8de2c4b7">More...</a><br /></td></tr>
<tr class="separator:ad18917eb9ec72f0e745c332a8de2c4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8daf6e8b4b66202dddaf7def6702be5"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#af8daf6e8b4b66202dddaf7def6702be5">data</a> () const </td></tr>
<tr class="memdesc:af8daf6e8b4b66202dddaf7def6702be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a direct pointer to the memory array used internally by the vector to store its owned elements.  <a href="#af8daf6e8b4b66202dddaf7def6702be5">More...</a><br /></td></tr>
<tr class="separator:af8daf6e8b4b66202dddaf7def6702be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eb5ad97c226385781f6e43bb1c8dda"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a72eb5ad97c226385781f6e43bb1c8dda">front</a> ()</td></tr>
<tr class="memdesc:a72eb5ad97c226385781f6e43bb1c8dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the vector.  <a href="#a72eb5ad97c226385781f6e43bb1c8dda">More...</a><br /></td></tr>
<tr class="separator:a72eb5ad97c226385781f6e43bb1c8dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708ec6197c4dbffc97d878960deb771e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a708ec6197c4dbffc97d878960deb771e">front</a> () const </td></tr>
<tr class="separator:a708ec6197c4dbffc97d878960deb771e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ca153edea68164687c63a921680612"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a> ()</td></tr>
<tr class="memdesc:a58ca153edea68164687c63a921680612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first element in the vector (see also <a class="el" href="a00108.html#a72eb5ad97c226385781f6e43bb1c8dda" title="Returns a reference to the first element in the vector. ">front()</a>).  <a href="#a58ca153edea68164687c63a921680612">More...</a><br /></td></tr>
<tr class="separator:a58ca153edea68164687c63a921680612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4505dfa742895712d670913ddbafa3a1"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a4505dfa742895712d670913ddbafa3a1">first</a> () const </td></tr>
<tr class="separator:a4505dfa742895712d670913ddbafa3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfda92c3264c8d8ee66e85369053b05"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#afdfda92c3264c8d8ee66e85369053b05">startsWith</a> (const T &amp;value)</td></tr>
<tr class="memdesc:afdfda92c3264c8d8ee66e85369053b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector starts with the given value.  <a href="#afdfda92c3264c8d8ee66e85369053b05">More...</a><br /></td></tr>
<tr class="separator:afdfda92c3264c8d8ee66e85369053b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fef9824d56851a10cde7cfd57d74323"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a8fef9824d56851a10cde7cfd57d74323">startsWith</a> (const T &amp;value) const </td></tr>
<tr class="separator:a8fef9824d56851a10cde7cfd57d74323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7c16f12392d8d91b61442aec162b24"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a7e7c16f12392d8d91b61442aec162b24">back</a> ()</td></tr>
<tr class="memdesc:a7e7c16f12392d8d91b61442aec162b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the vector.  <a href="#a7e7c16f12392d8d91b61442aec162b24">More...</a><br /></td></tr>
<tr class="separator:a7e7c16f12392d8d91b61442aec162b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc26ee0d9b58722fa9b80741c9dcdc7f"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#acc26ee0d9b58722fa9b80741c9dcdc7f">back</a> () const </td></tr>
<tr class="separator:acc26ee0d9b58722fa9b80741c9dcdc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15884c7e3cc99ef4afa936e23695973e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a15884c7e3cc99ef4afa936e23695973e">last</a> ()</td></tr>
<tr class="memdesc:a15884c7e3cc99ef4afa936e23695973e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last element in the vector (see also <a class="el" href="a00108.html#a7e7c16f12392d8d91b61442aec162b24" title="Returns a reference to the last element in the vector. ">back()</a>).  <a href="#a15884c7e3cc99ef4afa936e23695973e">More...</a><br /></td></tr>
<tr class="separator:a15884c7e3cc99ef4afa936e23695973e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46b2c6178c46085a309ec9bf767e72c"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ab46b2c6178c46085a309ec9bf767e72c">last</a> () const </td></tr>
<tr class="separator:ab46b2c6178c46085a309ec9bf767e72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e286375ae6cb38351097004bb90389"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a57e286375ae6cb38351097004bb90389">endsWith</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a57e286375ae6cb38351097004bb90389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the vector ends with the given value.  <a href="#a57e286375ae6cb38351097004bb90389">More...</a><br /></td></tr>
<tr class="separator:a57e286375ae6cb38351097004bb90389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3bd656ce959ff5d7e088565f6443fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#aca3bd656ce959ff5d7e088565f6443fe">endsWith</a> (const T &amp;value) const </td></tr>
<tr class="separator:aca3bd656ce959ff5d7e088565f6443fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed74b6d461869876362c2e340854d39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#aaed74b6d461869876362c2e340854d39">begin</a> ()</td></tr>
<tr class="memdesc:aaed74b6d461869876362c2e340854d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first position Calling this function on an empty vector will result in undefined behavior.  <a href="#aaed74b6d461869876362c2e340854d39">More...</a><br /></td></tr>
<tr class="separator:aaed74b6d461869876362c2e340854d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d555bc13d534f7c4692ff239a48296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a91d555bc13d534f7c4692ff239a48296">begin</a> () const </td></tr>
<tr class="separator:a91d555bc13d534f7c4692ff239a48296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22dea3ab50d48f077a4d8f07d1f47f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#af22dea3ab50d48f077a4d8f07d1f47f1">end</a> ()</td></tr>
<tr class="memdesc:af22dea3ab50d48f077a4d8f07d1f47f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the last position Calling this function on an empty vector will result in undefined behavior.  <a href="#af22dea3ab50d48f077a4d8f07d1f47f1">More...</a><br /></td></tr>
<tr class="separator:af22dea3ab50d48f077a4d8f07d1f47f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dcae6903c3a5f94c92e61e70d6622b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a96dcae6903c3a5f94c92e61e70d6622b">end</a> () const </td></tr>
<tr class="separator:a96dcae6903c3a5f94c92e61e70d6622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2936225109c819e21c56585e1fa39f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#a345b6aabe433b423c419b87699e38554">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a2936225109c819e21c56585e1fa39f0e">rbegin</a> ()</td></tr>
<tr class="memdesc:a2936225109c819e21c56585e1fa39f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the last position (reverse begin) Calling this function on an empty vector will result in undefined behavior.  <a href="#a2936225109c819e21c56585e1fa39f0e">More...</a><br /></td></tr>
<tr class="separator:a2936225109c819e21c56585e1fa39f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad438967718aac460d9fff19fbc89220e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ad438967718aac460d9fff19fbc89220e">rbegin</a> () const </td></tr>
<tr class="separator:ad438967718aac460d9fff19fbc89220e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0bae7c2605499d1ced1f5140319b84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#a345b6aabe433b423c419b87699e38554">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a4e0bae7c2605499d1ced1f5140319b84">rend</a> ()</td></tr>
<tr class="memdesc:a4e0bae7c2605499d1ced1f5140319b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the last position (reverse end) Calling this function on an empty vector will result in undefined behavior.  <a href="#a4e0bae7c2605499d1ced1f5140319b84">More...</a><br /></td></tr>
<tr class="separator:a4e0bae7c2605499d1ced1f5140319b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ab440f5e3508d5c20631dcbc643eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a50ab440f5e3508d5c20631dcbc643eee">rend</a> () const </td></tr>
<tr class="separator:a50ab440f5e3508d5c20631dcbc643eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfcc70141404d47f9b631f1a6a3b2a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a8bfcc70141404d47f9b631f1a6a3b2a4">cbegin</a> ()</td></tr>
<tr class="memdesc:a8bfcc70141404d47f9b631f1a6a3b2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant iterator to the first position Calling this function on an empty vector will result in undefined behavior.  <a href="#a8bfcc70141404d47f9b631f1a6a3b2a4">More...</a><br /></td></tr>
<tr class="separator:a8bfcc70141404d47f9b631f1a6a3b2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ec2c31ec64d5fedd99f60ee7b409e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ad9ec2c31ec64d5fedd99f60ee7b409e2">cbegin</a> () const </td></tr>
<tr class="separator:ad9ec2c31ec64d5fedd99f60ee7b409e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6347ec6af3f53ae823a84bcb737d060a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a6347ec6af3f53ae823a84bcb737d060a">cend</a> ()</td></tr>
<tr class="memdesc:a6347ec6af3f53ae823a84bcb737d060a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an constant iterator to the last position Calling this function on an empty vector will result in undefined behavior.  <a href="#a6347ec6af3f53ae823a84bcb737d060a">More...</a><br /></td></tr>
<tr class="separator:a6347ec6af3f53ae823a84bcb737d060a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83c18d35ce39f1e63496a25e3113808"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ad83c18d35ce39f1e63496a25e3113808">cend</a> () const </td></tr>
<tr class="separator:ad83c18d35ce39f1e63496a25e3113808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652309c4c1b72e74046f3e1abf524900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a652309c4c1b72e74046f3e1abf524900">crbegin</a> ()</td></tr>
<tr class="memdesc:a652309c4c1b72e74046f3e1abf524900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the first position Calling this function on an empty vector will result in undefined behavior.  <a href="#a652309c4c1b72e74046f3e1abf524900">More...</a><br /></td></tr>
<tr class="separator:a652309c4c1b72e74046f3e1abf524900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786fc472484affb3920006e9a59a4410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a786fc472484affb3920006e9a59a4410">crbegin</a> () const </td></tr>
<tr class="separator:a786fc472484affb3920006e9a59a4410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95499bd0fae7196e7ae257f10eb7ef1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a95499bd0fae7196e7ae257f10eb7ef1e">crend</a> ()</td></tr>
<tr class="memdesc:a95499bd0fae7196e7ae257f10eb7ef1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a constant reverse iterator to the last position Calling this function on an empty vector will result in undefined behavior.  <a href="#a95499bd0fae7196e7ae257f10eb7ef1e">More...</a><br /></td></tr>
<tr class="separator:a95499bd0fae7196e7ae257f10eb7ef1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c39d75f3f2a832a6ac7d4158512d75e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a8c39d75f3f2a832a6ac7d4158512d75e">crend</a> () const </td></tr>
<tr class="separator:a8c39d75f3f2a832a6ac7d4158512d75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0abb1e8d3d6b7c7c63b5ee37e3886f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ab0abb1e8d3d6b7c7c63b5ee37e3886f9">iteratorFromIndex</a> (size_t index)</td></tr>
<tr class="memdesc:ab0abb1e8d3d6b7c7c63b5ee37e3886f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an forward iterator for the given index.  <a href="#ab0abb1e8d3d6b7c7c63b5ee37e3886f9">More...</a><br /></td></tr>
<tr class="separator:ab0abb1e8d3d6b7c7c63b5ee37e3886f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337e3cda4c58b172999e37bc79423dad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a337e3cda4c58b172999e37bc79423dad">iteratorFromIndex</a> (size_t index) const </td></tr>
<tr class="separator:a337e3cda4c58b172999e37bc79423dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a9d1d221fe756735b20d16d37d1de1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#a345b6aabe433b423c419b87699e38554">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ac0a9d1d221fe756735b20d16d37d1de1">reverseIteratorFromIndex</a> (size_t index)</td></tr>
<tr class="memdesc:ac0a9d1d221fe756735b20d16d37d1de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an reverse iterator for the given index.  <a href="#ac0a9d1d221fe756735b20d16d37d1de1">More...</a><br /></td></tr>
<tr class="separator:ac0a9d1d221fe756735b20d16d37d1de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7534112d7b4d9741993390fc710ee6fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a7534112d7b4d9741993390fc710ee6fc">reverseIteratorFromIndex</a> (size_t index) const </td></tr>
<tr class="separator:a7534112d7b4d9741993390fc710ee6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0505e57e5b6a8ca590a94418a6b5ed7"><td class="memTemplParams" colspan="2">template&lt;typename... Dummy, typename IteratorType , typename  = typename std::enable_if&lt; (royale::iterator::is_same&lt;IteratorType, reverse_iterator&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:af0505e57e5b6a8ca590a94418a6b5ed7"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#af0505e57e5b6a8ca590a94418a6b5ed7">indexFromIterator</a> (IteratorType it)</td></tr>
<tr class="memdesc:af0505e57e5b6a8ca590a94418a6b5ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index position the given iterator is pointing to One may receive weird results by passing an iterator of another vector object! Take care that only indices from the current vector object are passed!  <a href="#af0505e57e5b6a8ca590a94418a6b5ed7">More...</a><br /></td></tr>
<tr class="separator:af0505e57e5b6a8ca590a94418a6b5ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa95b64c64426aba8713b6529a3a743"><td class="memTemplParams" colspan="2">template&lt;typename... Dummy, typename IteratorType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;IteratorType, reverse_iterator&gt;::value || royale::iterator::is_same&lt;IteratorType, const_reverse_iterator&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:abaa95b64c64426aba8713b6529a3a743"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#abaa95b64c64426aba8713b6529a3a743">indexFromIterator</a> (IteratorType it) const </td></tr>
<tr class="separator:abaa95b64c64426aba8713b6529a3a743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19b08f9b0192cabcacde29d56940421"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType , typename  = typename std::enable_if&lt; (royale::iterator::is_same&lt;IteratorType, iterator&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:ac19b08f9b0192cabcacde29d56940421"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#ac19b08f9b0192cabcacde29d56940421">indexFromIterator</a> (IteratorType it)</td></tr>
<tr class="memdesc:ac19b08f9b0192cabcacde29d56940421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index position the given iterator is pointing to One may receive weird results by passing an iterator of another vector object! Take care that only indices from the current vector object are passed!  <a href="#ac19b08f9b0192cabcacde29d56940421">More...</a><br /></td></tr>
<tr class="separator:ac19b08f9b0192cabcacde29d56940421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af896b45aa142a8909af930892ec9d0f5"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;IteratorType, iterator&gt;::value || royale::iterator::is_same&lt;IteratorType, const_iterator&gt;::value) &gt;::type&gt; </td></tr>
<tr class="memitem:af896b45aa142a8909af930892ec9d0f5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#af896b45aa142a8909af930892ec9d0f5">indexFromIterator</a> (IteratorType it) const </td></tr>
<tr class="separator:af896b45aa142a8909af930892ec9d0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403bf1a12bfa57caaca6fb6ac264ac8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a403bf1a12bfa57caaca6fb6ac264ac8c">push_back</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a403bf1a12bfa57caaca6fb6ac264ac8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new element at the end of the vector, after its current last element.  <a href="#a403bf1a12bfa57caaca6fb6ac264ac8c">More...</a><br /></td></tr>
<tr class="separator:a403bf1a12bfa57caaca6fb6ac264ac8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dc4131f24750c21979d206f9522f86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a70dc4131f24750c21979d206f9522f86">push_back</a> (T &amp;&amp;v)</td></tr>
<tr class="separator:a70dc4131f24750c21979d206f9522f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6ed41542a4812fb665396f32da153c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a4c6ed41542a4812fb665396f32da153c">assign</a> (size_t n, const T &amp;val)</td></tr>
<tr class="memdesc:a4c6ed41542a4812fb665396f32da153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns new contents to the vector, replacing its current contents, and modifying its size accordingly.  <a href="#a4c6ed41542a4812fb665396f32da153c">More...</a><br /></td></tr>
<tr class="separator:a4c6ed41542a4812fb665396f32da153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8e7d996327911ee247dd1cbc0f7b4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a6d8e7d996327911ee247dd1cbc0f7b4c">assign</a> (std::initializer_list&lt; <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &gt; il)</td></tr>
<tr class="separator:a6d8e7d996327911ee247dd1cbc0f7b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba995f3390a557d70545e042b30cbb5"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4ba995f3390a557d70545e042b30cbb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a4ba995f3390a557d70545e042b30cbb5">assign</a> (InputIterator_first <a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a>, InputIterator_last <a class="el" href="a00108.html#a15884c7e3cc99ef4afa936e23695973e">last</a>)</td></tr>
<tr class="separator:a4ba995f3390a557d70545e042b30cbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac3403babde743976dc252374b84443"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename VectorType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if &lt; !std::is_convertible&lt;VectorType, T&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:abac3403babde743976dc252374b84443"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#abac3403babde743976dc252374b84443">insert</a> (InputIterator_pos position, const VectorType &amp;v)</td></tr>
<tr class="memdesc:abac3403babde743976dc252374b84443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts elements to the given vector The content at the given position is moved backwards in the vector to create space for the elements which shall be inserted - given there is enough allocated space If the allocation is too small to insert the bunch of data, a new block is allocated, while the old data is MOVED (std::move) to the new buffer as long as the insert position is not reached.  <a href="#abac3403babde743976dc252374b84443">More...</a><br /></td></tr>
<tr class="separator:abac3403babde743976dc252374b84443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099582dfde39c2dae9e21f0b45b8a433"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename  = typename std::enable_if &lt; !std::is_convertible&lt;VectorType, T&gt;::value &gt;::type&gt; </td></tr>
<tr class="memitem:a099582dfde39c2dae9e21f0b45b8a433"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a099582dfde39c2dae9e21f0b45b8a433">insert</a> (size_t index, const VectorType &amp;v)</td></tr>
<tr class="separator:a099582dfde39c2dae9e21f0b45b8a433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ece57d9756cf4d344e835ff5d68e534"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename ItemType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if&lt;std::is_convertible&lt;ItemType, T&gt;::value&gt;::type, typename  = void&gt; </td></tr>
<tr class="memitem:a8ece57d9756cf4d344e835ff5d68e534"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a8ece57d9756cf4d344e835ff5d68e534">insert</a> (InputIterator_pos position, const ItemType &amp;item)</td></tr>
<tr class="separator:a8ece57d9756cf4d344e835ff5d68e534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d3ed26c0b8df5aec9436d846fd2770"><td class="memTemplParams" colspan="2">template&lt;typename ItemType , typename  = typename std::enable_if&lt;std::is_convertible&lt;ItemType, T&gt;::value&gt;::type, typename  = void&gt; </td></tr>
<tr class="memitem:a99d3ed26c0b8df5aec9436d846fd2770"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a99d3ed26c0b8df5aec9436d846fd2770">insert</a> (size_t index, const ItemType &amp;item)</td></tr>
<tr class="separator:a99d3ed26c0b8df5aec9436d846fd2770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cbaa518f14dc2bb3e8802038112356"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename ItemType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if&lt;std::is_convertible&lt;ItemType, T&gt;::value&gt;::type, typename  = void&gt; </td></tr>
<tr class="memitem:a09cbaa518f14dc2bb3e8802038112356"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a09cbaa518f14dc2bb3e8802038112356">insert</a> (InputIterator_pos position, <a class="el" href="a00108.html#a94c5527991dba00b103732a1bb04b669">size_type</a> n, const ItemType &amp;item)</td></tr>
<tr class="separator:a09cbaa518f14dc2bb3e8802038112356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac7a8acb5635644bd524fe8a998d49d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a6ac7a8acb5635644bd524fe8a998d49d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a6ac7a8acb5635644bd524fe8a998d49d">insert</a> (size_t index, InputIterator_first <a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a>, InputIterator_last <a class="el" href="a00108.html#a15884c7e3cc99ef4afa936e23695973e">last</a>)</td></tr>
<tr class="separator:a6ac7a8acb5635644bd524fe8a998d49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d521d4a53533348c511acc713be387"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa5d521d4a53533348c511acc713be387"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#aa5d521d4a53533348c511acc713be387">insert</a> (InputIterator_pos position, std::initializer_list&lt; <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &gt; il)</td></tr>
<tr class="separator:aa5d521d4a53533348c511acc713be387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c65320df4f6177667104698593e4c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa51c65320df4f6177667104698593e4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#aa51c65320df4f6177667104698593e4c">insert</a> (InputIterator_pos position, InputIterator_first <a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a>, InputIterator_last <a class="el" href="a00108.html#a15884c7e3cc99ef4afa936e23695973e">last</a>)</td></tr>
<tr class="separator:aa51c65320df4f6177667104698593e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a972e6a1dabef7ccc380b02971e0360"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a9a972e6a1dabef7ccc380b02971e0360"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a9a972e6a1dabef7ccc380b02971e0360">emplace</a> (<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> position, Args &amp;&amp;...ts)</td></tr>
<tr class="memdesc:a9a972e6a1dabef7ccc380b02971e0360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and insert element The container is extended by inserting a new element at position.  <a href="#a9a972e6a1dabef7ccc380b02971e0360">More...</a><br /></td></tr>
<tr class="separator:a9a972e6a1dabef7ccc380b02971e0360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba79ceab76510c4cc791efba894d9079"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:aba79ceab76510c4cc791efba894d9079"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#aba79ceab76510c4cc791efba894d9079">emplace_back</a> (Args &amp;&amp;...ts)</td></tr>
<tr class="memdesc:aba79ceab76510c4cc791efba894d9079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and insert element at the end Inserts a new element at the end of the vector, right after its current last element.  <a href="#aba79ceab76510c4cc791efba894d9079">More...</a><br /></td></tr>
<tr class="separator:aba79ceab76510c4cc791efba894d9079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00094f2434c2ec1a96e498226ace8dd"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:aa00094f2434c2ec1a96e498226ace8dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#aa00094f2434c2ec1a96e498226ace8dd">replace</a> (<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> start, <a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html#af22dea3ab50d48f077a4d8f07d1f47f1">end</a>, InputIterator_first <a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a>, InputIterator_last <a class="el" href="a00108.html#a15884c7e3cc99ef4afa936e23695973e">last</a>)</td></tr>
<tr class="memdesc:aa00094f2434c2ec1a96e498226ace8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing the elements from "start" to "end" with the element given in the range from "first" to "last".  <a href="#aa00094f2434c2ec1a96e498226ace8dd">More...</a><br /></td></tr>
<tr class="separator:aa00094f2434c2ec1a96e498226ace8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0719b5702eee1fa87758b4c599ee9a0"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ad0719b5702eee1fa87758b4c599ee9a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#ad0719b5702eee1fa87758b4c599ee9a0">replace</a> (InputIterator_pos position, InputIterator_first <a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a>, InputIterator_last <a class="el" href="a00108.html#a15884c7e3cc99ef4afa936e23695973e">last</a>)</td></tr>
<tr class="memdesc:ad0719b5702eee1fa87758b4c599ee9a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing vector elements with element given in the range from "first" to "last".  <a href="#ad0719b5702eee1fa87758b4c599ee9a0">More...</a><br /></td></tr>
<tr class="separator:ad0719b5702eee1fa87758b4c599ee9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9779de86c362ffbf7efb553ab50683d"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename ContainerType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ac9779de86c362ffbf7efb553ab50683d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#ac9779de86c362ffbf7efb553ab50683d">replace</a> (InputIterator_pos position, const ContainerType &amp;v)</td></tr>
<tr class="memdesc:ac9779de86c362ffbf7efb553ab50683d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing vector elements with the elements of another input container.  <a href="#ac9779de86c362ffbf7efb553ab50683d">More...</a><br /></td></tr>
<tr class="separator:ac9779de86c362ffbf7efb553ab50683d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9a9aaa67ad159ef685dd4c15db9af8"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_start , typename InputIterator_end , typename ContainerType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_start&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_end&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afb9a9aaa67ad159ef685dd4c15db9af8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#afb9a9aaa67ad159ef685dd4c15db9af8">replace</a> (InputIterator_start start, InputIterator_end <a class="el" href="a00108.html#af22dea3ab50d48f077a4d8f07d1f47f1">end</a>, const ContainerType &amp;v)</td></tr>
<tr class="memdesc:afb9a9aaa67ad159ef685dd4c15db9af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing the elements from "start" to "end" with the elements in the input container.  <a href="#afb9a9aaa67ad159ef685dd4c15db9af8">More...</a><br /></td></tr>
<tr class="separator:afb9a9aaa67ad159ef685dd4c15db9af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b448fffa65956c1bbd9db06065efbcf"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:a3b448fffa65956c1bbd9db06065efbcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a3b448fffa65956c1bbd9db06065efbcf">replace</a> (size_t index, const ContainerType &amp;v)</td></tr>
<tr class="memdesc:a3b448fffa65956c1bbd9db06065efbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing the elements beginning at index with all items held by the container v.  <a href="#a3b448fffa65956c1bbd9db06065efbcf">More...</a><br /></td></tr>
<tr class="separator:a3b448fffa65956c1bbd9db06065efbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcadb6e41a5024775376e72f5f1b2678"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_first , typename InputIterator_last , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_first&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_last&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:adcadb6e41a5024775376e72f5f1b2678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#adcadb6e41a5024775376e72f5f1b2678">replace</a> (size_t index, InputIterator_first <a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a>, InputIterator_last <a class="el" href="a00108.html#a15884c7e3cc99ef4afa936e23695973e">last</a>)</td></tr>
<tr class="memdesc:adcadb6e41a5024775376e72f5f1b2678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace elements in a vector This method allows replacing the elements starting at index with the given range from "first" to "last".  <a href="#adcadb6e41a5024775376e72f5f1b2678">More...</a><br /></td></tr>
<tr class="separator:adcadb6e41a5024775376e72f5f1b2678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d01978f30ca104820ecce52577124c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a2d01978f30ca104820ecce52577124c4">erase</a> (<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a>, <a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html#a15884c7e3cc99ef4afa936e23695973e">last</a>)</td></tr>
<tr class="memdesc:a2d01978f30ca104820ecce52577124c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase elements Erases from the vector either a single element (position) or a range of elements ([first,last)).  <a href="#a2d01978f30ca104820ecce52577124c4">More...</a><br /></td></tr>
<tr class="separator:a2d01978f30ca104820ecce52577124c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c174b118b69dc6bf136b88215ddbfa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a2c174b118b69dc6bf136b88215ddbfa3">erase</a> (size_t index, size_t numElements=1)</td></tr>
<tr class="separator:a2c174b118b69dc6bf136b88215ddbfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8e8c38be2f00a496d078b2a6189377"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a8a8e8c38be2f00a496d078b2a6189377">erase</a> (<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> position, size_t numElements=1)</td></tr>
<tr class="separator:a8a8e8c38be2f00a496d078b2a6189377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d7ff84a5e6effb92cd6a0f00af0235"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a91d7ff84a5e6effb92cd6a0f00af0235"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a91d7ff84a5e6effb92cd6a0f00af0235">takeItem</a> (InputIterator_pos position)</td></tr>
<tr class="memdesc:a91d7ff84a5e6effb92cd6a0f00af0235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a range of items out of a vector (relocates the other elements to fill the gap) The element which was taken out is copied and returned, while the original element in the original vector is erased using <a class="el" href="a00108.html#a2d01978f30ca104820ecce52577124c4" title="Erase elements Erases from the vector either a single element (position) or a range of elements ([fir...">erase()</a> - which calls the destructor.  <a href="#a91d7ff84a5e6effb92cd6a0f00af0235">More...</a><br /></td></tr>
<tr class="separator:a91d7ff84a5e6effb92cd6a0f00af0235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b9471b275b382f068a8eee826db00f"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ae3b9471b275b382f068a8eee826db00f">takeItem</a> (size_t index)</td></tr>
<tr class="separator:ae3b9471b275b382f068a8eee826db00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb66b76edbbbafabd0a6cc0839c86a83"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:abb66b76edbbbafabd0a6cc0839c86a83"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#abb66b76edbbbafabd0a6cc0839c86a83">takeItems</a> (InputIterator_pos position, size_t numElements)</td></tr>
<tr class="memdesc:abb66b76edbbbafabd0a6cc0839c86a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a range of items out of a vector (relocates the other elements to fill the gap) The elements which were take out are MOVED to another vector storage and returned, while they are erased (with <a class="el" href="a00108.html#a2d01978f30ca104820ecce52577124c4" title="Erase elements Erases from the vector either a single element (position) or a range of elements ([fir...">erase()</a>) in the original vector - which calls the destructor.  <a href="#abb66b76edbbbafabd0a6cc0839c86a83">More...</a><br /></td></tr>
<tr class="separator:abb66b76edbbbafabd0a6cc0839c86a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702d8f97831d2c031e9413510881f6b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a702d8f97831d2c031e9413510881f6b4">takeItems</a> (size_t index, size_t numElements)</td></tr>
<tr class="separator:a702d8f97831d2c031e9413510881f6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79058b5384160dfcbf17f403a0a35efc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a79058b5384160dfcbf17f403a0a35efc">indexOf</a> (const <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &amp;item, size_t occurance=1) const </td></tr>
<tr class="memdesc:a79058b5384160dfcbf17f403a0a35efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a specific item in the vector and returns the index.  <a href="#a79058b5384160dfcbf17f403a0a35efc">More...</a><br /></td></tr>
<tr class="separator:a79058b5384160dfcbf17f403a0a35efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4291835695bb4cfe7c850210496bd0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#aeb4291835695bb4cfe7c850210496bd0">contains</a> (const <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &amp;item) const </td></tr>
<tr class="memdesc:aeb4291835695bb4cfe7c850210496bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a specific item in the vector and returns true or false.  <a href="#aeb4291835695bb4cfe7c850210496bd0">More...</a><br /></td></tr>
<tr class="separator:aeb4291835695bb4cfe7c850210496bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64296e90d410f55a820ed7b7c4f68bcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a64296e90d410f55a820ed7b7c4f68bcb">pop_back</a> ()</td></tr>
<tr class="memdesc:a64296e90d410f55a820ed7b7c4f68bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the last element in the vector, effectively reducing the container size by one.  <a href="#a64296e90d410f55a820ed7b7c4f68bcb">More...</a><br /></td></tr>
<tr class="separator:a64296e90d410f55a820ed7b7c4f68bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4721e4713d96ef69d4e1dd5e0192f47a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a4721e4713d96ef69d4e1dd5e0192f47a">operator[]</a> (size_t index)</td></tr>
<tr class="memdesc:a4721e4713d96ef69d4e1dd5e0192f47a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at position index in the vector container.  <a href="#a4721e4713d96ef69d4e1dd5e0192f47a">More...</a><br /></td></tr>
<tr class="separator:a4721e4713d96ef69d4e1dd5e0192f47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d0189122c4699e72f31b117bfa4d9e"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a68d0189122c4699e72f31b117bfa4d9e">operator[]</a> (size_t index) const </td></tr>
<tr class="memdesc:a68d0189122c4699e72f31b117bfa4d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the element at position index in the vector container.  <a href="#a68d0189122c4699e72f31b117bfa4d9e">More...</a><br /></td></tr>
<tr class="separator:a68d0189122c4699e72f31b117bfa4d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b07fd1643df83eae61eed42a053016"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a43b07fd1643df83eae61eed42a053016">at</a> (size_t index)</td></tr>
<tr class="memdesc:a43b07fd1643df83eae61eed42a053016"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function automatically checks whether index is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size).  <a href="#a43b07fd1643df83eae61eed42a053016">More...</a><br /></td></tr>
<tr class="separator:a43b07fd1643df83eae61eed42a053016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44a39385f349384309bab89c3a031f"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a9b44a39385f349384309bab89c3a031f">at</a> (size_t index) const </td></tr>
<tr class="memdesc:a9b44a39385f349384309bab89c3a031f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function automatically checks whether index is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size).  <a href="#a9b44a39385f349384309bab89c3a031f">More...</a><br /></td></tr>
<tr class="separator:a9b44a39385f349384309bab89c3a031f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4a4d505cf88fbad9cbc75885dcc515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a3c4a4d505cf88fbad9cbc75885dcc515">operator=</a> (<a class="el" href="a00108.html">Vector</a>&lt; T &gt; v)</td></tr>
<tr class="memdesc:a3c4a4d505cf88fbad9cbc75885dcc515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign another royale compliant vector.  <a href="#a3c4a4d505cf88fbad9cbc75885dcc515">More...</a><br /></td></tr>
<tr class="separator:a3c4a4d505cf88fbad9cbc75885dcc515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a7c5966f867acffb3ee9d942758908"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#ad6a7c5966f867acffb3ee9d942758908">operator=</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ad6a7c5966f867acffb3ee9d942758908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the contents of an STL compliant vector container by replacing container's current contents if necessary and modifying its size accordingly.  <a href="#ad6a7c5966f867acffb3ee9d942758908">More...</a><br /></td></tr>
<tr class="separator:ad6a7c5966f867acffb3ee9d942758908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220abd9565189aae49fc449f0fa2ee73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a220abd9565189aae49fc449f0fa2ee73">operator==</a> (const std::vector&lt; T &gt; &amp;v) const </td></tr>
<tr class="memdesc:a220abd9565189aae49fc449f0fa2ee73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with an STL compliant vector.  <a href="#a220abd9565189aae49fc449f0fa2ee73">More...</a><br /></td></tr>
<tr class="separator:a220abd9565189aae49fc449f0fa2ee73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d4191326fbe77e022e9fad469e6d1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a71d4191326fbe77e022e9fad469e6d1e">operator==</a> (const <a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;v) const </td></tr>
<tr class="memdesc:a71d4191326fbe77e022e9fad469e6d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality with a royale compliant vector.  <a href="#a71d4191326fbe77e022e9fad469e6d1e">More...</a><br /></td></tr>
<tr class="separator:a71d4191326fbe77e022e9fad469e6d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f71c374f40d768bc975e7aada249dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a41f71c374f40d768bc975e7aada249dd">operator!=</a> (const std::vector&lt; T &gt; &amp;v) const </td></tr>
<tr class="memdesc:a41f71c374f40d768bc975e7aada249dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with an STL compliant vector.  <a href="#a41f71c374f40d768bc975e7aada249dd">More...</a><br /></td></tr>
<tr class="separator:a41f71c374f40d768bc975e7aada249dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ebe10418ee8d246952511d3c15c531a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a4ebe10418ee8d246952511d3c15c531a">operator!=</a> (const <a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;v) const </td></tr>
<tr class="memdesc:a4ebe10418ee8d246952511d3c15c531a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks unequality with a royale compliant vector.  <a href="#a4ebe10418ee8d246952511d3c15c531a">More...</a><br /></td></tr>
<tr class="separator:a4ebe10418ee8d246952511d3c15c531a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0654a312b257565b4316e31828d03449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a0654a312b257565b4316e31828d03449">clear</a> ()</td></tr>
<tr class="memdesc:a0654a312b257565b4316e31828d03449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the vector (which are destroyed), leaving the container with a size of 0.  <a href="#a0654a312b257565b4316e31828d03449">More...</a><br /></td></tr>
<tr class="separator:a0654a312b257565b4316e31828d03449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc38c00d347551fe1ccd60459561a30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a5cc38c00d347551fe1ccd60459561a30">resize</a> (size_t newSize)</td></tr>
<tr class="memdesc:a5cc38c00d347551fe1ccd60459561a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the vector to the given allocation size and initializes the elements (it may shrink)  <a href="#a5cc38c00d347551fe1ccd60459561a30">More...</a><br /></td></tr>
<tr class="separator:a5cc38c00d347551fe1ccd60459561a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04aba67806bc5797abd769f83852ec9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#aa04aba67806bc5797abd769f83852ec9">resize</a> (size_t newSize, T initVal)</td></tr>
<tr class="memdesc:aa04aba67806bc5797abd769f83852ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the vector to the given allocation size and initializes the elements (it may shrink)  <a href="#aa04aba67806bc5797abd769f83852ec9">More...</a><br /></td></tr>
<tr class="separator:aa04aba67806bc5797abd769f83852ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa202553f2fd8c7b4968838d605b15c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#afa202553f2fd8c7b4968838d605b15c3">reserve</a> (size_t <a class="el" href="a00108.html#a0ca30cb729aa167dbaef001172b05f7c">size</a>)</td></tr>
<tr class="memdesc:afa202553f2fd8c7b4968838d605b15c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the vector to a higher allocation size and allocates the buffers.  <a href="#afa202553f2fd8c7b4968838d605b15c3">More...</a><br /></td></tr>
<tr class="separator:afa202553f2fd8c7b4968838d605b15c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66b9ed5d416b805718ad244ef1f966c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#af66b9ed5d416b805718ad244ef1f966c">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:af66b9ed5d416b805718ad244ef1f966c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the vector's allocation to it's size Changes the size of the allocated buffer to the vector's size this may result in freeing unneeded memory allocation.  <a href="#af66b9ed5d416b805718ad244ef1f966c">More...</a><br /></td></tr>
<tr class="separator:af66b9ed5d416b805718ad244ef1f966c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b04e76ec22e187d5e1faeddd41357c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a93b04e76ec22e187d5e1faeddd41357c">toStdVector</a> ()</td></tr>
<tr class="memdesc:a93b04e76ec22e187d5e1faeddd41357c"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::vector which might be used outside the library by the application for further processing.  <a href="#a93b04e76ec22e187d5e1faeddd41357c">More...</a><br /></td></tr>
<tr class="separator:a93b04e76ec22e187d5e1faeddd41357c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d1fdfdf6bb3cfd30b00a1b69912e13"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a11d1fdfdf6bb3cfd30b00a1b69912e13">toStdVector</a> () const </td></tr>
<tr class="separator:a11d1fdfdf6bb3cfd30b00a1b69912e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303cb75aebd2ca9fb7c061c355c691dd"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a303cb75aebd2ca9fb7c061c355c691dd"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; X, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a303cb75aebd2ca9fb7c061c355c691dd">toStdMap</a> ()</td></tr>
<tr class="memdesc:a303cb75aebd2ca9fb7c061c355c691dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::map which might be used outside the library by the application for further processing.  <a href="#a303cb75aebd2ca9fb7c061c355c691dd">More...</a><br /></td></tr>
<tr class="separator:a303cb75aebd2ca9fb7c061c355c691dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f5090cb60d83d4ade4e42a8df6cb0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a02f5090cb60d83d4ade4e42a8df6cb0e">swap</a> (<a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&amp;vector)</td></tr>
<tr class="memdesc:a02f5090cb60d83d4ade4e42a8df6cb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a data swap (convenience function to call classswap) Swaps the given vector data with the current one.  <a href="#a02f5090cb60d83d4ade4e42a8df6cb0e">More...</a><br /></td></tr>
<tr class="separator:a02f5090cb60d83d4ade4e42a8df6cb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c52893ab4a020bbf379cbe8bf3e8a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a85c52893ab4a020bbf379cbe8bf3e8a5">max_size</a> () const </td></tr>
<tr class="memdesc:a85c52893ab4a020bbf379cbe8bf3e8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the max_size of the string.  <a href="#a85c52893ab4a020bbf379cbe8bf3e8a5">More...</a><br /></td></tr>
<tr class="separator:a85c52893ab4a020bbf379cbe8bf3e8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af455152abea7a9316fd4f5e9d5ab388c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename &gt; </td></tr>
<tr class="memitem:af455152abea7a9316fd4f5e9d5ab388c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#af455152abea7a9316fd4f5e9d5ab388c">insert</a> (InputIterator_pos position, std::initializer_list&lt; typename <a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &gt; il)</td></tr>
<tr class="separator:af455152abea7a9316fd4f5e9d5ab388c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fae731391a0e757ccffedbda9c3f954"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a1fae731391a0e757ccffedbda9c3f954"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a1fae731391a0e757ccffedbda9c3f954">assign</a> (std::initializer_list&lt; typename <a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &gt; il)</td></tr>
<tr class="separator:a1fae731391a0e757ccffedbda9c3f954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add32240fe590889e81d80143c6732760"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_start , typename InputIterator_end , typename ContainerType , typename , typename , typename &gt; </td></tr>
<tr class="memitem:add32240fe590889e81d80143c6732760"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#add32240fe590889e81d80143c6732760">replace</a> (InputIterator_start start, InputIterator_end <a class="el" href="a00108.html#af22dea3ab50d48f077a4d8f07d1f47f1">end</a>, const ContainerType &amp;v)</td></tr>
<tr class="separator:add32240fe590889e81d80143c6732760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b2741b9443d7c89b26de6b78615e4e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator_pos , typename ContainerType , typename , typename &gt; </td></tr>
<tr class="memitem:ac2b2741b9443d7c89b26de6b78615e4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#ac2b2741b9443d7c89b26de6b78615e4e">replace</a> (InputIterator_pos position, const ContainerType &amp;v)</td></tr>
<tr class="separator:ac2b2741b9443d7c89b26de6b78615e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9054f4bde7de2c3d7b2618c11aa20f"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType , typename &gt; </td></tr>
<tr class="memitem:a7f9054f4bde7de2c3d7b2618c11aa20f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a7f9054f4bde7de2c3d7b2618c11aa20f">replace</a> (size_t index, const ContainerType &amp;v)</td></tr>
<tr class="separator:a7f9054f4bde7de2c3d7b2618c11aa20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a153434ad7ad0df07ace7eec3bb31893b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="a00108.html">Vector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a153434ad7ad0df07ace7eec3bb31893b">fromStdVector</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a153434ad7ad0df07ace7eec3bb31893b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given std::vector (STL) to the vector type used by the royale API.  <a href="#a153434ad7ad0df07ace7eec3bb31893b">More...</a><br /></td></tr>
<tr class="separator:a153434ad7ad0df07ace7eec3bb31893b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d172e72be02b44ec2d96b8e63d6b4d6"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a4d172e72be02b44ec2d96b8e63d6b4d6">toStdVector</a> (const <a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a4d172e72be02b44ec2d96b8e63d6b4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::vector which might be used if the royale compliant <a class="el" href="a00108.html">Vector</a> is a const.  <a href="#a4d172e72be02b44ec2d96b8e63d6b4d6">More...</a><br /></td></tr>
<tr class="separator:a4d172e72be02b44ec2d96b8e63d6b4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53eca7a25cbfadb49597474e7c0b8435"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a53eca7a25cbfadb49597474e7c0b8435"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; (std::is_same&lt; typename U::value_type, char &gt;::value||std::is_same&lt; typename U::value_type, wchar_t &gt;::value), <a class="el" href="a00108.html">Vector</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a53eca7a25cbfadb49597474e7c0b8435">fromString</a> (const U &amp;string)</td></tr>
<tr class="memdesc:a53eca7a25cbfadb49597474e7c0b8435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given String (based on char or wchar_t) to a vector.  <a href="#a53eca7a25cbfadb49597474e7c0b8435">More...</a><br /></td></tr>
<tr class="separator:a53eca7a25cbfadb49597474e7c0b8435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1689e8d71f22beac5465368e4e18b83"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:aa1689e8d71f22beac5465368e4e18b83"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a00108.html">Vector</a>&lt; <a class="el" href="a00067.html">Pair</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#aa1689e8d71f22beac5465368e4e18b83">fromStdMap</a> (const std::map&lt; X, Y &gt; &amp;stdMap)</td></tr>
<tr class="memdesc:aa1689e8d71f22beac5465368e4e18b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion from std::map which might be used inside the library for further processing.  <a href="#aa1689e8d71f22beac5465368e4e18b83">More...</a><br /></td></tr>
<tr class="separator:aa1689e8d71f22beac5465368e4e18b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4cbf16044a8be32bbe60e405d1ed49"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:acc4cbf16044a8be32bbe60e405d1ed49"><td class="memTemplItemLeft" align="right" valign="top">static std::map&lt; X, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#acc4cbf16044a8be32bbe60e405d1ed49">toStdMap</a> (const <a class="el" href="a00108.html">Vector</a>&lt; <a class="el" href="a00067.html">Pair</a>&lt; X, Y &gt; &gt; &amp;v)</td></tr>
<tr class="memdesc:acc4cbf16044a8be32bbe60e405d1ed49"><td class="mdescLeft">&#160;</td><td class="mdescRight">User convenience function to allow conversion to std::map which might be used if the element is of type const.  <a href="#acc4cbf16044a8be32bbe60e405d1ed49">More...</a><br /></td></tr>
<tr class="separator:acc4cbf16044a8be32bbe60e405d1ed49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a47d215a994cabd7e3d60812f4ce3b545"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html#a47d215a994cabd7e3d60812f4ce3b545">npos</a> = ( (size_t) ~0)</td></tr>
<tr class="separator:a47d215a994cabd7e3d60812f4ce3b545"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5edb5cefc81e6bf330c5a6a9c17917e4"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a5edb5cefc81e6bf330c5a6a9c17917e4"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a5edb5cefc81e6bf330c5a6a9c17917e4">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="a00108.html">Vector</a>&lt; U &gt; &amp;v)</td></tr>
<tr class="separator:a5edb5cefc81e6bf330c5a6a9c17917e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0262a7aad7c76d8c1c780bb0359c1706"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a0262a7aad7c76d8c1c780bb0359c1706"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00108.html#a0262a7aad7c76d8c1c780bb0359c1706">classswap</a> (<a class="el" href="a00108.html">Vector</a>&lt; U &gt; &amp;<a class="el" href="a00108.html#a58ca153edea68164687c63a921680612">first</a>, <a class="el" href="a00108.html">Vector</a>&lt; U &gt; &amp;second)</td></tr>
<tr class="separator:a0262a7aad7c76d8c1c780bb0359c1706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ace9c16f6656afa6bb848e8b3b6962fbb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00074.html">royale::iterator::royale_const_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5f7046ec665a417b4916a8d61d5c1e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T* <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ac5f7046ec665a417b4916a8d61d5c1e6">const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General <a class="el" href="a00108.html">Vector</a> definitions. </p>

</div>
</div>
<a class="anchor" id="a89c382fd56871e64a7b4a73c4b0bfb66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const T&amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a89c382fd56871e64a7b4a73c4b0bfb66">const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae551b7505e41b02337ef7faf214c001b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00075.html">royale::iterator::royale_const_reverse_iterator</a>&lt; <a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afe89de40b9f9dd1d98934b00fb3e6413"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00084.html">royale::iterator::royale_iterator</a>&lt;std::random_access_iterator_tag, T&gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator definitions. </p>

</div>
</div>
<a class="anchor" id="a9629956720d18a047f71e79a234826e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ptrdiff_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a9629956720d18a047f71e79a234826e8">pdifference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a03da8b51714ed717924a5707ad41d53b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T* <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a03da8b51714ed717924a5707ad41d53b">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ac3aef4b8475c957a9adcd934f306be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a>&amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a0ac3aef4b8475c957a9adcd934f306be">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a345b6aabe433b423c419b87699e38554"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00093.html">royale::iterator::royale_reverse_iterator</a>&lt; <a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a345b6aabe433b423c419b87699e38554">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a94c5527991dba00b103732a1bb04b669"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a94c5527991dba00b103732a1bb04b669">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9880be8c3d5a637d76f7cb2c3e8bd09c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac80f0477577f681b5b89b3f9609340e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>General constructor, which does not allocate memory and sets everything to it's default. </p>
<p>Template implementation. </p>

</div>
</div>
<a class="anchor" id="a96c88cbc155e88cf3d0502b74a02f9ab"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor which already performs an allocation of memory during execution Constructs a given number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Number of elements to construct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a76ebeb3f02f924f70125bb40a5eabf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor which already performs an allocation of memory during execution Constructs the given number of elements pre-initialized with the value of item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements to construct </td></tr>
    <tr><td class="paramname">item</td><td>The pre initialization value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a62308fb469ae0f131bd84e8a414d4670"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-Constructor for royale compliant vector which allows creation of a royale compliant vector from another royale compliant vector - (NOTE: performs a deep copy!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The royale vector which's memory shall be copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42ac272a9576eb1550b489380294330c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-Constructor for royale compliant vector which allows creation of a royale compliant vector by moving memory (NOTE: performs a shallow copy!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The royale vector which's memory shall be moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a779e7fda288a902cf2f3224115fd7624"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-Constructor for STL compliant vector (std::vector) It allows creation of a royale compliant vector from a STL compliant vector - (NOTE: performs a deep copy!) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The STL vector to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a834e2045a234c8e81690a89d46899f9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vector with an input iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the First element returned by the iterator </td></tr>
    <tr><td class="paramname">last</td><td>the Last element returned by the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8dd0b94a4d7f6ceaf6e9b0843e3ffa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::<a class="el" href="a00108.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer list initialization to initialize a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3f6e58246c226d67ad4337f2291e81b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::~<a class="el" href="a00108.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Clears the vectors allocated memory by performing deletion </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4c6ed41542a4812fb665396f32da153c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns new contents to the vector, replacing its current contents, and modifying its size accordingly. </p>
<p>Any elements held in the container before the call are destroyed or replaced by newly constructed elements(no assignments of elements take place). This causes an automatic reallocation of the allocated storage space if - and only if - the new vector size surpasses the current vector capacity. </p>

</div>
</div>
<a class="anchor" id="a6d8e7d996327911ee247dd1cbc0f7b4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ba995f3390a557d70545e042b30cbb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_first , typename InputIterator_last , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1fae731391a0e757ccffedbda9c3f954"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; typename <a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a43b07fd1643df83eae61eed42a053016"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function automatically checks whether index is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size). </p>
<p>This is in contrast with member operator[], that does not check against bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the vectors storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a9b44a39385f349384309bab89c3a031f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function automatically checks whether index is within the bounds of valid elements in the vector, throwing an out_of_range exception if it is not (i.e., if index is greater or equal than its size). </p>
<p>This is in contrast with member operator[], that does not check against bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the vectors storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a7e7c16f12392d8d91b61442aec162b24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the vector. </p>
<p>This member function returns a direct reference to the last element in the vector Calling this function on an empty vector will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the last element in the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the vector is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc26ee0d9b58722fa9b80741c9dcdc7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaed74b6d461869876362c2e340854d39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the first position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the begin of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a91d555bc13d534f7c4692ff239a48296"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afdf5f7e6860d6f6a720e40df40253622"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the amount of allocated slots which are maintained by the vector These allocated slots might be used or unused (refer to <a class="el" href="a00108.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) equiva...">size()</a> for checking the <a class="el" href="a00108.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) equiva...">size()</a> itself) </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of allocated slots for the element type which is bound to the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a8bfcc70141404d47f9b631f1a6a3b2a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an constant iterator to the first position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the begin of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9ec2c31ec64d5fedd99f60ee7b409e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6347ec6af3f53ae823a84bcb737d060a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an constant iterator to the last position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the end of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ad83c18d35ce39f1e63496a25e3113808"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0654a312b257565b4316e31828d03449"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the vector (which are destroyed), leaving the container with a size of 0. </p>
<p>A reallocation is not performed and the vector's capacity is destroyed (everything is freed). </p>

</div>
</div>
<a class="anchor" id="aeb4291835695bb4cfe7c850210496bd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up a specific item in the vector and returns true or false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if the vector contains an equal item or false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ade43a55376e0c1a32060a0dc01085e2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual size of the vector (this is the used amount of slots in the allocated area) equivalent to <a class="el" href="a00108.html#a0ca30cb729aa167dbaef001172b05f7c" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) equiva...">size()</a> </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of the actual used memory slots within the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a652309c4c1b72e74046f3e1abf524900"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the first position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator pointing to the reverse begin of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a786fc472484affb3920006e9a59a4410"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a95499bd0fae7196e7ae257f10eb7ef1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a constant reverse iterator to the last position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator A constant iterator pointing to the reverse end of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c39d75f3f2a832a6ac7d4158512d75e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad18917eb9ec72f0e745c332a8de2c4b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a direct pointer to the memory array used internally by the vector to store its owned elements. </p>
<p>Because elements in the vector are guaranteed to be stored in contiguous storage locations in the same order as represented by the vector, the pointer retrieved can be offset to access any element in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>T* A pointer to the first element in the array used internally by the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="af8daf6e8b4b66202dddaf7def6702be5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a direct pointer to the memory array used internally by the vector to store its owned elements. </p>
<p>Because elements in the vector are guaranteed to be stored in contiguous storage locations in the same order as represented by the vector, the pointer retrieved can be offset to access any element in the array.</p>
<dl class="section return"><dt>Returns</dt><dd>T* A pointer to the first element in the array used internally by the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a972e6a1dabef7ccc380b02971e0360"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and insert element The container is extended by inserting a new element at position. </p>
<p>This new element is constructed in place using args as the arguments for its construction. This effectively increases the container size by one. An automatic reallocation of the allocated storage space happens if -and only if- the new vector size surpasses the current vector capacity.</p>
<p>Because vectors use an array as their underlying storage, inserting elements in positions other than the vector end causes the container to shift all the elements that were after position by one to their new positions. This is generally an inefficient operation compared to the one performed by other kinds of sequence containers (such as list or forward_list). See emplace_back for a member function that extends the container directly at the end.</p>
<p>The element is constructed in-place by calling allocator_traits::construct with args forwarded.</p>
<p>A similar member function exists, insert, which either copies or moves existing objects into the container.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position where the arguments shall be inserted </td></tr>
    <tr><td class="paramname">ts</td><td>The arguments which shall be appended to the end </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="aba79ceab76510c4cc791efba894d9079"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>ts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and insert element at the end Inserts a new element at the end of the vector, right after its current last element. </p>
<p>This new element is constructed in place using args as the arguments for its constructor.</p>
<p>This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage space if - and only if - the new vector size surpasses the current vector capacity. The element is constructed in - place by calling placement new with args forwarded. A similar member function exists, push_back, which either copies or moves an existing object into the container. see also <a class="el" href="a00108.html#abac3403babde743976dc252374b84443" title="Inserts elements to the given vector The content at the given position is moved backwards in the vect...">insert()</a> and <a class="el" href="a00108.html#a9a972e6a1dabef7ccc380b02971e0360" title="Construct and insert element The container is extended by inserting a new element at position...">emplace()</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts</td><td>The arguments which shall be appended to the end </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a348f55e8aa9b70d115a25f9627e4c64a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the vector is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if the vector is empty - otherwise false </dd></dl>

</div>
</div>
<a class="anchor" id="af22dea3ab50d48f077a4d8f07d1f47f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the last position Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the end of the vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a96dcae6903c3a5f94c92e61e70d6622b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a57e286375ae6cb38351097004bb90389"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::endsWith </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the vector ends with the given value. </p>
<dl class="section return"><dt>Returns</dt><dd>bool True if the vector ends with the given value </dd></dl>

</div>
</div>
<a class="anchor" id="aca3bd656ce959ff5d7e088565f6443fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::endsWith </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d01978f30ca104820ecce52577124c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase elements Erases from the vector either a single element (position) or a range of elements ([first,last)). </p>
<p>This effectively reduces the container size by the number of elements removed, which are destroyed.</p>
<p>Because vectors use an array as their underlying storage, erasing elements in positions other than the vector end causes the container to relocate all the elements after the segment erased to their new positions. This is generally an inefficient operation compared to the one performed for the same operation by other kinds of sequence containers (such as list or forward_list).</p>
<p>A faster operation is remove() </p><dl class="section return"><dt>Returns</dt><dd>iterator The iterator position to the first element after the deleted range </dd></dl>

</div>
</div>
<a class="anchor" id="a2c174b118b69dc6bf136b88215ddbfa3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8a8e8c38be2f00a496d078b2a6189377"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a58ca153edea68164687c63a921680612"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the vector (see also <a class="el" href="a00108.html#a72eb5ad97c226385781f6e43bb1c8dda" title="Returns a reference to the first element in the vector. ">front()</a>). </p>
<p>This member function returns a direct reference to the first element in the vector Calling this function on an empty vector will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the first element in the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the vector is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4505dfa742895712d670913ddbafa3a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1689e8d71f22beac5465368e4e18b83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; <a class="el" href="a00067.html">Pair</a>&lt; X, Y &gt; &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::fromStdMap </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; X, Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>stdMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User convenience function to allow conversion from std::map which might be used inside the library for further processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stdMap</td><td>The STL compliant map which shall be converted to the API style vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;pair&gt; Returned is a vector of pairs - each pair is holding one entry of the converted std::map </dd></dl>

</div>
</div>
<a class="anchor" id="a153434ad7ad0df07ace7eec3bb31893b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::fromStdVector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given std::vector (STL) to the vector type used by the royale API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The STL vector which should be converted to the royale API vector format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The royale API compliant vector format </dd></dl>

</div>
</div>
<a class="anchor" id="a53eca7a25cbfadb49597474e7c0b8435"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt; (std::is_same&lt;typename U::value_type, char&gt;::value || std::is_same&lt;typename U::value_type, wchar_t&gt;::value), <a class="el" href="a00108.html">Vector</a>&lt;T&gt; &gt;::type <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::fromString </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given String (based on char or wchar_t) to a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to convert to a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The royale API compliant vector format </dd></dl>

</div>
</div>
<a class="anchor" id="a72eb5ad97c226385781f6e43bb1c8dda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the first element in the vector. </p>
<p>This member function returns a direct reference to the first element in the vector Calling this function on an empty vector will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the first element in the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the vector is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a708ec6197c4dbffc97d878960deb771e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af0505e57e5b6a8ca590a94418a6b5ed7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename... Dummy, typename IteratorType , typename  = typename std::enable_if&lt; (royale::iterator::is_same&lt;IteratorType, reverse_iterator&gt;::value) &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::indexFromIterator </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index position the given iterator is pointing to One may receive weird results by passing an iterator of another vector object! Take care that only indices from the current vector object are passed! </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The index position </dd></dl>

</div>
</div>
<a class="anchor" id="abaa95b64c64426aba8713b6529a3a743"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename... Dummy, typename IteratorType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;IteratorType, reverse_iterator&gt;::value || royale::iterator::is_same&lt;IteratorType, const_reverse_iterator&gt;::value) &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::indexFromIterator </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac19b08f9b0192cabcacde29d56940421"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType , typename  = typename std::enable_if&lt; (royale::iterator::is_same&lt;IteratorType, iterator&gt;::value) &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::indexFromIterator </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the index position the given iterator is pointing to One may receive weird results by passing an iterator of another vector object! Take care that only indices from the current vector object are passed! </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The index position </dd></dl>

</div>
</div>
<a class="anchor" id="af896b45aa142a8909af930892ec9d0f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType , typename  = typename std::enable_if &lt; (royale::iterator::is_same&lt;IteratorType, iterator&gt;::value || royale::iterator::is_same&lt;IteratorType, const_iterator&gt;::value) &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::indexFromIterator </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a79058b5384160dfcbf17f403a0a35efc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::indexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>occurance</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up a specific item in the vector and returns the index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to search for </td></tr>
    <tr><td class="paramname">occurance</td><td>Return the n'th occurance of the item (everything below 2 means first occurance) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position The position at which the Item was found or npos if it wasn't found </dd></dl>

</div>
</div>
<a class="anchor" id="abac3403babde743976dc252374b84443"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename VectorType , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts elements to the given vector The content at the given position is moved backwards in the vector to create space for the elements which shall be inserted - given there is enough allocated space If the allocation is too small to insert the bunch of data, a new block is allocated, while the old data is MOVED (std::move) to the new buffer as long as the insert position is not reached. </p>
<p>When the input position is reached, the input values are completely copied. At the end the original data, after the input position is moved to the new buffer and the internal data buffer is swapped with the created buffer. </p>

</div>
</div>
<a class="anchor" id="a099582dfde39c2dae9e21f0b45b8a433"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename VectorType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ece57d9756cf4d344e835ff5d68e534"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename ItemType , typename , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ItemType &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a99d3ed26c0b8df5aec9436d846fd2770"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename ItemType , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ItemType &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a09cbaa518f14dc2bb3e8802038112356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename ItemType , typename , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00108.html#a94c5527991dba00b103732a1bb04b669">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ItemType &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6ac7a8acb5635644bd524fe8a998d49d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_first , typename InputIterator_last , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa5d521d4a53533348c511acc713be387"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa51c65320df4f6177667104698593e4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af455152abea7a9316fd4f5e9d5ab388c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt;T&gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; typename <a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a9880be8c3d5a637d76f7cb2c3e8bd09c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>il</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0abb1e8d3d6b7c7c63b5ee37e3886f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::iteratorFromIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an forward iterator for the given index. </p>

</div>
</div>
<a class="anchor" id="a337e3cda4c58b172999e37bc79423dad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::iteratorFromIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a15884c7e3cc99ef4afa936e23695973e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the last element in the vector (see also <a class="el" href="a00108.html#a7e7c16f12392d8d91b61442aec162b24" title="Returns a reference to the last element in the vector. ">back()</a>). </p>
<p>This member function returns a direct reference to the last element in the vector Calling this function on an empty vector will result in a std::out_of_range exception.</p>
<dl class="section return"><dt>Returns</dt><dd>T&amp; A reference to the last element in the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>Exception if the vector is empty </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab46b2c6178c46085a309ec9bf767e72c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a85c52893ab4a020bbf379cbe8bf3e8a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the max_size of the string. </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The maximum length of the string </dd></dl>

</div>
</div>
<a class="anchor" id="a41f71c374f40d768bc975e7aada249dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with an STL compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An STL compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a4ebe10418ee8d246952511d3c15c531a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks unequality with a royale compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An royale compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns false if they are equal and true is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a3c4a4d505cf88fbad9cbc75885dcc515"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign another royale compliant vector. </p>
<p>Assigns new contents to the container, replacing its current contents, and modifying its size accordingly. This method copies all elements held by v into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>A vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="ad6a7c5966f867acffb3ee9d942758908"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the contents of an STL compliant vector container by replacing container's current contents if necessary and modifying its size accordingly. </p>
<p>This method copies all elements held by v into the container</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An STL compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;T&gt;&amp; Returns *this </dd></dl>

</div>
</div>
<a class="anchor" id="a220abd9565189aae49fc449f0fa2ee73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with an STL compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An STL compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a71d4191326fbe77e022e9fad469e6d1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality with a royale compliant vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>An royale compliant vector of the same storage type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Returns true if they are equal and false is they are not </dd></dl>

</div>
</div>
<a class="anchor" id="a4721e4713d96ef69d4e1dd5e0192f47a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the element at position index in the vector container. </p>
<p>A similar member function, <a class="el" href="a00108.html#a43b07fd1643df83eae61eed42a053016" title="The function automatically checks whether index is within the bounds of valid elements in the vector...">at()</a>, has the same behavior as this operator function, except that <a class="el" href="a00108.html#a43b07fd1643df83eae61eed42a053016" title="The function automatically checks whether index is within the bounds of valid elements in the vector...">at()</a> is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the vectors storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a68d0189122c4699e72f31b117bfa4d9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T &amp; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the element at position index in the vector container. </p>
<p>A similar member function, <a class="el" href="a00108.html#a43b07fd1643df83eae61eed42a053016" title="The function automatically checks whether index is within the bounds of valid elements in the vector...">at()</a>, has the same behavior as this operator function, except that <a class="el" href="a00108.html#a43b07fd1643df83eae61eed42a053016" title="The function automatically checks whether index is within the bounds of valid elements in the vector...">at()</a> is bound-checked and signals if the requested position is out of range by throwing an out_of_range exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to access within the vectors storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; The Reference to the elements at the specified position in the vector </dd></dl>

</div>
</div>
<a class="anchor" id="a64296e90d410f55a820ed7b7c4f68bcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the last element in the vector, effectively reducing the container size by one. </p>
<p>The last element is destroyed by calling it's destructor; the size is reduced by one BUT there is no reallocation performed to resize the vector to it's contents or to reduce the the vectors capacity by one. The allocated space remains the same. </p>

</div>
</div>
<a class="anchor" id="a403bf1a12bfa57caaca6fb6ac264ac8c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new element at the end of the vector, after its current last element. </p>
<p>The content of v is copied to the new element (NOTE: a deep copy is performed!). This effectively increases the container size by one, which causes an automatic reallocation of the allocated storage space if -and only if- the new vector size surpasses the current vector capacity. </p>

</div>
</div>
<a class="anchor" id="a70dc4131f24750c21979d206f9522f86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2936225109c819e21c56585e1fa39f0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a345b6aabe433b423c419b87699e38554">reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the last position (reverse begin) Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the reverse begin of a vector (!= <a class="el" href="a00108.html#af22dea3ab50d48f077a4d8f07d1f47f1" title="Returns an iterator to the last position Calling this function on an empty vector will result in unde...">end()</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="ad438967718aac460d9fff19fbc89220e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e0bae7c2605499d1ced1f5140319b84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a345b6aabe433b423c419b87699e38554">reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the last position (reverse end) Calling this function on an empty vector will result in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator An iterator pointing to the reverse end of a vector (!= <a class="el" href="a00108.html#aaed74b6d461869876362c2e340854d39" title="Returns an iterator to the first position Calling this function on an empty vector will result in und...">begin()</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a50ab440f5e3508d5c20631dcbc643eee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa00094f2434c2ec1a96e498226ace8dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_first , typename InputIterator_last , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00108.html#ace9c16f6656afa6bb848e8b3b6962fbb">const_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing the elements from "start" to "end" with the element given in the range from "first" to "last". </p>
<p>It only replaces as much items (starting at first) as forseen by the range from "start" to "end". If the number of elements given by "first" and "last" exceeds the range from "start" to "end" the exceeding elements are "dropped" and not used for replacement. Given that the caller wants all elements from "first" to "last" to be replaced/appended there are other signatures of <a class="el" href="a00108.html#aa00094f2434c2ec1a96e498226ace8dd" title="Replace elements in a vector This method allows replacing the elements from &quot;start&quot; to &quot;end&quot; with the...">replace()</a> to provide that</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting iterator where the replacement shall start </td></tr>
    <tr><td class="paramname">end</td><td>The end iterator of replacement (this "hard end" will NOT be exceeded) </td></tr>
    <tr><td class="paramname">first</td><td>The iterator to the first element taken for replacement </td></tr>
    <tr><td class="paramname">last</td><td>The iterator to the last element taken for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="ad0719b5702eee1fa87758b4c599ee9a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename InputIterator_first , typename InputIterator_last , typename , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing vector elements with element given in the range from "first" to "last". </p>
<p>It only replaces as much items as forseen by the range from "first" to "last". If the number of elements given by "first" and "last" exceeds the allocation size a reallocation will take place and the elements are appended to the vector. Given that the caller only wants a range of elements to be replaced, even if the the input range might be greater he/she shall use the signature of <a class="el" href="a00108.html#aa00094f2434c2ec1a96e498226ace8dd" title="Replace elements in a vector This method allows replacing the elements from &quot;start&quot; to &quot;end&quot; with the...">replace()</a> which provides four iterators as input and accepts an input range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The iterator where the replacement shall start </td></tr>
    <tr><td class="paramname">first</td><td>The iterator to the first element taken for replacement </td></tr>
    <tr><td class="paramname">last</td><td>The iterator to the last element taken for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="ac9779de86c362ffbf7efb553ab50683d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename ContainerType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_pos&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing vector elements with the elements of another input container. </p>
<p>It only replaces as much items, as there are in the input vector. If the number of elements in the input vector exceeds the allocation size a reallocation will take place and the elements are appended to the object. Given that the caller only wants a range of elements to be replaced, even if the the input range might be greater he/she shall use the signature of <a class="el" href="a00108.html#aa00094f2434c2ec1a96e498226ace8dd" title="Replace elements in a vector This method allows replacing the elements from &quot;start&quot; to &quot;end&quot; with the...">replace()</a> which provides four iterators as input and accepts an input range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The starting iterator where the replacement shall start </td></tr>
    <tr><td class="paramname">v</td><td>The container which shall be used for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="afb9a9aaa67ad159ef685dd4c15db9af8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_start , typename InputIterator_end , typename ContainerType , typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_start&gt;::value&gt;::type, typename  = typename std::enable_if&lt;royale::iterator::is_iterator&lt;InputIterator_end&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_start&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_end&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing the elements from "start" to "end" with the elements in the input container. </p>
<p>It only replaces as much items (starting at first) as forseen by the range from "start" to "end". If the number of elements given by "first" and "last" exceeds the range from "start" to "end" the exceeding elements are "dropped" and not used for replacement. Given that the caller wants all elements from "first" to "last" to be replaced/appended there are other signatures of <a class="el" href="a00108.html#aa00094f2434c2ec1a96e498226ace8dd" title="Replace elements in a vector This method allows replacing the elements from &quot;start&quot; to &quot;end&quot; with the...">replace()</a> to provide that</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The starting iterator where the replacement shall start </td></tr>
    <tr><td class="paramname">end</td><td>The end iterator of replacement (this "hard end" will NOT be exceeded) </td></tr>
    <tr><td class="paramname">v</td><td>The container which shall be used for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="a3b448fffa65956c1bbd9db06065efbcf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing the elements beginning at index with all items held by the container v. </p>
<p>If the number of elements exceeds the allocation size of the vector a reallocation is performanced and the items are moved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index position where the replacement shall be started </td></tr>
    <tr><td class="paramname">v</td><td>The container which shall be used for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="adcadb6e41a5024775376e72f5f1b2678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_first , typename InputIterator_last , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_first&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_last&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace elements in a vector This method allows replacing the elements starting at index with the given range from "first" to "last". </p>
<p>It only replaces as much items (starting at first) as forseen by the range from "first" to "last". If the number of elements given by "first" and "last" exceeds the allocation size a realoocation is performed and the elements are moved to the new allocation space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index position where the replacement shall be started </td></tr>
    <tr><td class="paramname">first</td><td>The iterator to the first element taken for replacement </td></tr>
    <tr><td class="paramname">last</td><td>The iterator to the last element taken for replacement </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>iterator to the first replaced item </dd></dl>

</div>
</div>
<a class="anchor" id="add32240fe590889e81d80143c6732760"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_start , typename InputIterator_end , typename ContainerType , typename , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt;T&gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_start&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator_end&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2b2741b9443d7c89b26de6b78615e4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename ContainerType , typename , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt;T&gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f9054f4bde7de2c3d7b2618c11aa20f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename ContainerType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt;T&gt;::<a class="el" href="a00108.html#afe89de40b9f9dd1d98934b00fb3e6413">iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::replace </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa202553f2fd8c7b4968838d605b15c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends the vector to a higher allocation size and allocates the buffers. </p>
<p>Reserves any amount of free allocation slots (allocates the memory already) to be later used for the element-types bound to the given royale vector.</p>
<p>If the given size to reserve is smaller than the already reserved space, then the function return immediately; otherwise the necessary memory allocation is performed and the size is extended to "size"</p><ul>
<li><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size (number of element-types) of elements that should be allocated. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a class="anchor" id="a5cc38c00d347551fe1ccd60459561a30"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the vector to the given allocation size and initializes the elements (it may shrink) </p>
<p>Creates any amount of elements (allocates the memory already) and moves the existing elements to these slots; afterwards the old space is dumped.</p>
<p>If the given newSize is smaller than the already used slots, the vector will shrink. This means that all elements which are not covered within this capacity (the last ones) will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The amount of slots to remain in the vector (might shrink or enlarge the vector) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa04aba67806bc5797abd769f83852ec9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>initVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the vector to the given allocation size and initializes the elements (it may shrink) </p>
<p>Creates any amount of elements (allocates the memory already) and moves the existing elements to these slots; afterwards the old space is dumped.</p>
<p>If the given newSize is smaller than the already used slots, the vector will shrink. This means that all elements which are not covered within this capacity (the last ones) will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newSize</td><td>The amount of slots to remain in the vector (might shrink or enlarge the vector) </td></tr>
    <tr><td class="paramname">initVal</td><td>The initializer value by which the vector shall be initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0a9d1d221fe756735b20d16d37d1de1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#a345b6aabe433b423c419b87699e38554">reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::reverseIteratorFromIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an reverse iterator for the given index. </p>

</div>
</div>
<a class="anchor" id="a7534112d7b4d9741993390fc710ee6fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt;::<a class="el" href="a00108.html#ae551b7505e41b02337ef7faf214c001b">const_reverse_iterator</a> <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::reverseIteratorFromIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af66b9ed5d416b805718ad244ef1f966c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks the vector's allocation to it's size Changes the size of the allocated buffer to the vector's size this may result in freeing unneeded memory allocation. </p>

</div>
</div>
<a class="anchor" id="a0ca30cb729aa167dbaef001172b05f7c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the actual size of the vector (this is the used amount of slots in the allocated area) equivalent to <a class="el" href="a00108.html#ade43a55376e0c1a32060a0dc01085e2f" title="Returns the actual size of the vector (this is the used amount of slots in the allocated area) equiva...">count()</a> </p>
<dl class="section return"><dt>Returns</dt><dd>size_t The amount of the actual used memory slots within the vector </dd></dl>

</div>
</div>
<a class="anchor" id="afdfda92c3264c8d8ee66e85369053b05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::startsWith </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the vector starts with the given value. </p>
<dl class="section return"><dt>Returns</dt><dd>bool True if the vector starts with the given value </dd></dl>

</div>
</div>
<a class="anchor" id="a8fef9824d56851a10cde7cfd57d74323"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::startsWith </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a02f5090cb60d83d4ade4e42a8df6cb0e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows a data swap (convenience function to call classswap) Swaps the given vector data with the current one. </p>

</div>
</div>
<a class="anchor" id="a91d7ff84a5e6effb92cd6a0f00af0235"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::takeItem </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a range of items out of a vector (relocates the other elements to fill the gap) The element which was taken out is copied and returned, while the original element in the original vector is erased using <a class="el" href="a00108.html#a2d01978f30ca104820ecce52577124c4" title="Erase elements Erases from the vector either a single element (position) or a range of elements ([fir...">erase()</a> - which calls the destructor. </p>

</div>
</div>
<a class="anchor" id="ae3b9471b275b382f068a8eee826db00f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::takeItem </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb66b76edbbbafabd0a6cc0839c86a83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator_pos , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::takeItems </td>
          <td>(</td>
          <td class="paramtype">InputIterator_pos&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a range of items out of a vector (relocates the other elements to fill the gap) The elements which were take out are MOVED to another vector storage and returned, while they are erased (with <a class="el" href="a00108.html#a2d01978f30ca104820ecce52577124c4" title="Erase elements Erases from the vector either a single element (position) or a range of elements ([fir...">erase()</a>) in the original vector - which calls the destructor. </p>

</div>
</div>
<a class="anchor" id="a702d8f97831d2c031e9413510881f6b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00108.html">Vector</a>&lt; T &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::takeItems </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a303cb75aebd2ca9fb7c061c355c691dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; X, Y &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::toStdMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::map which might be used outside the library by the application for further processing. </p>
<dl class="section return"><dt>Returns</dt><dd>std::map containing the items of the Vector&lt;pairs&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="acc4cbf16044a8be32bbe60e405d1ed49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; X, Y &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::toStdMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00108.html">Vector</a>&lt; <a class="el" href="a00067.html">Pair</a>&lt; X, Y &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::map which might be used if the element is of type const. </p>
<dl class="section return"><dt>Returns</dt><dd>std::map containing the items of the Vector&lt;pairs&gt; </dd></dl>

</div>
</div>
<a class="anchor" id="a93b04e76ec22e187d5e1faeddd41357c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::toStdVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::vector which might be used outside the library by the application for further processing. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector containing the items of the </dd></dl>

</div>
</div>
<a class="anchor" id="a11d1fdfdf6bb3cfd30b00a1b69912e13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; T &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::toStdVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d172e72be02b44ec2d96b8e63d6b4d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::toStdVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00108.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>User convenience function to allow conversion to std::vector which might be used if the royale compliant <a class="el" href="a00108.html">Vector</a> is a const. </p>
<dl class="section return"><dt>Returns</dt><dd>std::vector containing the items of the </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a0262a7aad7c76d8c1c780bb0359c1706"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void classswap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00108.html">Vector</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00108.html">Vector</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5edb5cefc81e6bf330c5a6a9c17917e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00108.html">Vector</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a47d215a994cabd7e3d60812f4ce3b545"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="a00108.html">royale::Vector</a>&lt; T &gt;::npos = ( (size_t) ~0)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a00205_source.html">Vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 19 2018 10:18:50 for Royale by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
