### User/Cloud/App Intents in the Behavior System

There are three types of intents. Each represents a user's intention for the robot to perform some action, such as a fist bump. 

* **User intents** are a CLAD union of structs, where each struct represents a different user request and its data. User intents are not exposed outside of the behavior system, but can be requested either by voice or through the companion app. In other words, any cloud or app intent is translated into a user intent before being handled by the behavior system. 
* **Cloud intents** are JSON blobs received from the cloud process containing the intent type along with any parameters. The behavior system is not aware of cloud intents beyond how to translate them into user intents.
* **App Intents** are CLAD messages received from the Switchboard (which receives them from the companion app) containing the intent type along with any parameters. The behavior system is not aware of app intents beyond how to translate them into user intents. (Note: at the time of writing, app intents arrive via the AppToEngineHandler, but this should soon switch over to the Switchboard.)


#### Creating a new intent

In [`userIntent.clad`](/clad/src/clad/types/behaviorComponent/userIntent.clad), create a new CLAD `structure` containing the data associated with your user intent, or use `UserIntent_Void` if there are no params. Add an entry to [`user_intent_map.json`](/resources/config/engine/behaviorComponent/user_intent_map.json) that defines the mapping from cloud and app intents to user intents.

The names of the user intent parameters should, when possible, match the names of the cloud/app intent parameters. Since user intents are CLAD, the parameter names must be valid C++. However, the parameters associated with cloud intents are based on cloud service requirements, and their names may not be valid C++ (e.g., a parameter may be called `time.duration-s`). In this case, you may define a substitution of a cloud variable name to a CLAD field name using the `cloud_substitutions` JSON field.

Additionally, in the JSON we receive from the cloud, all parameters are strings. For example, the integer 10 is received as `{"paramName": "10"}`. To help parse cloud intents, if the user intent parameter is a numeric type, you should specify that in the `cloud_numerics` list.

#### Handling intents

When a cloud or app intent arrives, it gets translated into a user intent by the `UserIntentComponent`, which also marks that intent as _pending_. Only one user intent can be pending at any time, so receipt of a new cloud or app intent will replace the last user intent with a new one. Once a user intent is pending, it must be cleared (handled) within a small number (2-4) of engine ticks, or a warning is printed and it is cleared automatically.

When writing a behavior, you have a few options to handle an intent. Use of the JSON behavior parameter `respondToUserIntents` will block activation of that behavior until one of the specified user intents is pending, similar to how `wantsToBeActivatedConditions` works. If the user intent is set as pending, then upon behavior activation, that intent will be automatically cleared. Your behavior class may also request to block activation until a user intent is pending by calling `AddWaitForUserIntent`.  

The activation conditions in `respondToUserIntents` or `AddWaitForUserIntent` will compare the pending user intent to the `UserIntentTag` that you provide, which is the autogenerated tag for the `UserIntent` union. It's also possible to match a pending intent against its parameters, and if you need something even more complicated, you may write a lambda to check the `UserIntent` struct directly.

Since all pending user intents must be cleared shortly after they are pending, it sometimes becomes necessary to clear the intent but save the `UserIntent` for use by a delegate behavior. If this describes your problem, check out `ClearUserIntentWithPreservation`. 

Note: Don't include the CLAD-generated files `userIntent.h`/`.cpp` in your behavior unless it's absolutely necessary. Instead, the file [`userIntents.h`](/engine/aiComponent/behaviorComponent/userIntents.h) provides most methods you will need for handling user intents.

#### Unmatched and unclaimed intents

Sometimes, an incoming cloud intent does not have a matching user intent. This most frequently happens when the cloud cannot understand the voice command and issues an `intent_system_unsupported`, which is purposefully not listed in [`user_intent_map.json`](/resources/config/engine/behaviorComponent/user_intent_map.json). It could also occur if the version of [`user_intent_map.json`](/resources/config/engine/behaviorComponent/user_intent_map.json) is not the same as that of the cloud, i.e., if the robot is out of date. If there is no match, the `unmatched_intent` user intent is set as pending. Currently, when the `unmatched_intent` user intent is pending, a "huh?!" animation plays, and the intent is cleared.

If a user intent goes unclaimed for more engine ticks than we allow (2-4), it means the behavior tree is not configured to handle the intent based on its current state. Usually this means we forgot to do something, so a warning is printed. To help catch these omissions, there is a behavior `BehaviorReactToUnclaimedIntent` that will play an animation if an intent goes unclaimed. This behavior is also useful when a known user intent is received, but it does not make sense in the present context. For example, if a user intent corresponding to the voice command "go to your charger" is pending when the robot is already on its charger, we could either add an explicit check for "go to your charger," or simply skip the handling of that intent when on the charger. In that case, the unclaimed intent animation would play, indicating that the robot cannot respond to that intent in its current state.

#### Unit tests

When you add a new intent and believe that it is properly hooked up,  we force you to write some unit tests for it (sorry not sorry). 

Since user/cloud/app intents are in active development, it should be possible to add handlers in behaviors and entries in [`user_intent_map.json`](/resources/config/engine/behaviorComponent/user_intent_map.json) that don't encompass all possible uses of the intent. Eventually, the entries in [`user_intent_map.json`](/resources/config/engine/behaviorComponent/user_intent_map.json) should be considered as complete. For now, we have a separate file that lists those intents that we believe to be fully handled.

In [`completedUserIntents.json`](/resources/test/aiTests/completedUserIntents.json), add a JSON entry for the user intent along with a label, which can be used by any unit test to grab the completed intent by name. 

If the intent is handled as part of the HighLevelAI behavior, you must also add an entry to the `LabeledExceptions exceptionsList` in [`testBehaviorHighLevelAI.cpp`](/test/engine/behaviorComponent/testBehaviorHighLevelAI.cpp). In this entry, you should include the intent label from [`completedUserIntents.json`](/resources/test/aiTests/completedUserIntents.json) and a list of states of HighLevelAI that should _not_ handle the intent. The test checks that your assumptions match. 

If the intent is handled elsewhere, a unit test will force you to write a test in [`testUserIntentTransitions.cpp`](/test/engine/behaviorComponent/testUserIntentTransitions.cpp). 

#### Trigger words
We handle trigger words in a similar manner to user intents. When the trigger word is detected, the `UserIntentComponent` marks it as pending, and it must be cleared (handled) by some behavior within some number of ticks. Otherwise, a warning is printed and the trigger word is cleared automatically. However, the trigger word is _not_ a user intent (as it was previously under cozmo / early victor days).



