// Autogenerated C++ message buffer code.
// Source: util/questEngine/questEngineMessages.clad
// Full command line: ../../../tools/message-buffers/emitters/CPP_emitter.py -C . -o .. ./util/questEngine/questEngineMessages.clad

#ifndef __UTIL_QUEST_ENGINE_QUEST_ENGINE_MESSAGES_H__
#define __UTIL_QUEST_ENGINE_QUEST_ENGINE_MESSAGES_H__

#include "CLAD/SafeMessageBuffer.h"
#include <array>
#include <cassert>
#include <cstdint>
#include <string>
#include <vector>

namespace Anki {

namespace Util {

namespace QuestEngine {

// MESSAGE NoticePair
struct NoticePair
{
  bool force;
  uint8_t priority;
  double noticeTime;
  std::string guid;
  std::string target;
  std::string titleKey;
  std::string descriptionKey;
  std::string buttonKey;
  std::string navigationAction;
  
  /**** Constructors ****/
  NoticePair() = default;
  NoticePair(const NoticePair& other) = default;
  NoticePair(NoticePair& other) = default;
  NoticePair(NoticePair&& other) noexcept = default;
  NoticePair& operator=(const NoticePair& other) = default;
  NoticePair& operator=(NoticePair&& other) noexcept = default;
  
  explicit NoticePair(bool force,
    uint8_t priority,
    double noticeTime,
    const std::string& guid,
    const std::string& target,
    const std::string& titleKey,
    const std::string& descriptionKey,
    const std::string& buttonKey,
    const std::string& navigationAction)
  : force(force)
  , priority(priority)
  , noticeTime(noticeTime)
  , guid(guid)
  , target(target)
  , titleKey(titleKey)
  , descriptionKey(descriptionKey)
  , buttonKey(buttonKey)
  , navigationAction(navigationAction)
  {}
  
  explicit NoticePair(const uint8_t* buff, size_t len);
  explicit NoticePair(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const NoticePair& other) const;
  bool operator!=(const NoticePair& other) const;
};

// MESSAGE EventPair
struct EventPair
{
  std::string eventName;
  uint32_t count;
  
  /**** Constructors ****/
  EventPair() = default;
  EventPair(const EventPair& other) = default;
  EventPair(EventPair& other) = default;
  EventPair(EventPair&& other) noexcept = default;
  EventPair& operator=(const EventPair& other) = default;
  EventPair& operator=(EventPair&& other) noexcept = default;
  
  explicit EventPair(const std::string& eventName,
    uint32_t count)
  : eventName(eventName)
  , count(count)
  {}
  
  explicit EventPair(const uint8_t* buff, size_t len);
  explicit EventPair(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const EventPair& other) const;
  bool operator!=(const EventPair& other) const;
};

// MESSAGE TriggerLog
struct TriggerLog
{
  std::string ruleId;
  std::vector<double> triggerTimes;
  
  /**** Constructors ****/
  TriggerLog() = default;
  TriggerLog(const TriggerLog& other) = default;
  TriggerLog(TriggerLog& other) = default;
  TriggerLog(TriggerLog&& other) noexcept = default;
  TriggerLog& operator=(const TriggerLog& other) = default;
  TriggerLog& operator=(TriggerLog&& other) noexcept = default;
  
  explicit TriggerLog(const std::string& ruleId,
    const std::vector<double>& triggerTimes)
  : ruleId(ruleId)
  , triggerTimes(triggerTimes)
  {}
  
  explicit TriggerLog(const uint8_t* buff, size_t len);
  explicit TriggerLog(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const TriggerLog& other) const;
  bool operator!=(const TriggerLog& other) const;
};

// MESSAGE QuestStore
struct QuestStore
{
  std::vector<Anki::Util::QuestEngine::EventPair> eventStats;
  std::vector<Anki::Util::QuestEngine::NoticePair> notices;
  std::vector<Anki::Util::QuestEngine::TriggerLog> ruleTriggers;
  
  /**** Constructors ****/
  QuestStore() = default;
  QuestStore(const QuestStore& other) = default;
  QuestStore(QuestStore& other) = default;
  QuestStore(QuestStore&& other) noexcept = default;
  QuestStore& operator=(const QuestStore& other) = default;
  QuestStore& operator=(QuestStore&& other) noexcept = default;
  
  explicit QuestStore(const std::vector<Anki::Util::QuestEngine::EventPair>& eventStats,
    const std::vector<Anki::Util::QuestEngine::NoticePair>& notices,
    const std::vector<Anki::Util::QuestEngine::TriggerLog>& ruleTriggers)
  : eventStats(eventStats)
  , notices(notices)
  , ruleTriggers(ruleTriggers)
  {}
  
  explicit QuestStore(const uint8_t* buff, size_t len);
  explicit QuestStore(const CLAD::SafeMessageBuffer& buffer);
  
  /**** Pack ****/
  size_t Pack(uint8_t* buff, size_t len) const;
  size_t Pack(CLAD::SafeMessageBuffer& buffer) const;
  
  /**** Unpack ****/
  size_t Unpack(const uint8_t* buff, const size_t len);
  size_t Unpack(const CLAD::SafeMessageBuffer& buffer);
  
  size_t Size() const;
  
  bool operator==(const QuestStore& other) const;
  bool operator!=(const QuestStore& other) const;
};

} // namespace QuestEngine

} // namespace Util

} // namespace Anki

#endif // __UTIL_QUEST_ENGINE_QUEST_ENGINE_MESSAGES_H__
