// UiMessageDefinitions message definition file
//  for the C-Like Abstract Data language
// Author: Greg Nagel
// Copyright: Anki Inc (c) 2015

#include "clad/types/actionTypes.clad"

namespace Anki {
namespace Cozmo {
namespace U2G {

message Ping {
    uint_32 counter
}

message ConnectToRobot {
    uint_8 robotID
}

// ConnectToUiDevice
message ConnectToUiDevice {
    uint_8 deviceID
}

// DisconnectFromUiDevice
message DisconnectFromUiDevice {
    uint_8 deviceID
}

// ForceAddRobot
// NOTE: This can be removed once physical robots can advertise (e.g. with BLE
message ForceAddRobot {
    uint_8 ipAddress[16],
    uint_8 robotID,
    uint_8 isSimulated
}

// StartEngine
// Tell game to start the engine with the configuration specified by the message members.
message StartEngine {
    uint_8 asHost,
    uint_8 vizHostIP[16] // if first char is '\0' disables viz
}

// DriveWheels
message DriveWheels {
    float_32 lwheel_speed_mmps,
    float_32 rwheel_speed_mmps
}

// TurnInPlace
//  Turn the specified number of radians, *relative to the robot's current heading*
message TurnInPlace {
    float_32 angle_rad, // postive turns left negative turns right
    uint_8 robotID
}

// FaceObject - Turns and tilts head to look at object in last known position
//   If facing the object requires less than a turnAngleTol turn, then no
//   turn is performed. If a turn greater than maxTurnAngle is required,
//   the action fails. For angles in between, the robot will first turn
//   to face the object, then tilt its head. To completely disallow turning,
//   set maxTurnAngle to zero. (All angles in radians and forced to be positive.)
//   Set headTrackWhenDone to non-zero to enable head tracking to the specified
//   object once the robot has successfully faced it.
message FaceObject {
    uint_32  objectID,
    float_32 turnAngleTol,
    float_32 maxTurnAngle,
    uint_8   robotID,
    uint_8   headTrackWhenDone
}

// MoveHead
message MoveHead {
    float_32 speed_rad_per_sec
}

// MoveLift
message MoveLift {
    float_32 speed_rad_per_sec
}

// SetLiftHeight
message SetLiftHeight {
    float_32 height_mm,
    float_32 max_speed_rad_per_sec,
    float_32 accel_rad_per_sec2,
    float_32 duration_sec
}

// SetHeadAngle
message SetHeadAngle {
    float_32 angle_rad,
    float_32 max_speed_rad_per_sec,
    float_32 accel_rad_per_sec2,
    float_32 duration_sec
}

// TrackToObject
//   Robot will automatically adjust head and body angle to look at this object ID, if it
//   is observed. Sending SetHeadAngle message (above) will disable this behavior.
//   Set headOnly to true to only use the head and not turn the body.
//   Use objectID = u32_MAX to disable tracking.
message TrackToObject {
    uint_32 objectID,
    uint_8  robotID,
    bool    headOnly
}

// StopAllMotors
message StopAllMotors {
}

// ImageRequest
message ImageRequest {
    uint_8 robotID,
    uint_8 mode // See ImageSendMode_t in cozmoTypes.h
}

// SetRobotImageSendMode
// NOTE: This can enable/disable streaming of images from the physical robot.
//       It is intended for dev use since the robot will likely always stream
//       its image in the product.
message SetRobotImageSendMode {
    uint_8 mode, // See ImageSendMode_t in cozmoTypes.h
    uint_8 resolution
}

// SaveImages
message SaveImages {
    uint_8 mode // See SaveMode_t in cozmoTypes.h
}

// SaveRobotState
message SaveRobotState {
    uint_8 mode // See SaveMode_t in cozmoTypes.h
}

// EnableDisplay
message EnableDisplay {
    uint_8 enable
}

// SetHeadlights
message SetHeadlights {
    uint_8 intensity
}

// GotoPose
message GotoPose {
    float_32 x_mm,
    float_32 y_mm,
    float_32 rad,
    uint_8 level,
    uint_8 useManualSpeed
}

// GotoObject
message GotoObject {
    int_32 objectID,
    float_32 distance_mm,
    uint_8 useManualSpeed
}

// PlaceObjectOnGround
message PlaceObjectOnGround {
    float_32 x_mm,
    float_32 y_mm,
    float_32 rad,
    uint_8 level,
    uint_8 useManualSpeed
}

// PlaceObjectOnGroundHere
message PlaceObjectOnGroundHere {
}

// ExecuteTestPlan
message ExecuteTestPlan {
}

// SelectNextObject
message SelectNextObject {
}

// PickAndPlaceObject
message PickAndPlaceObject {
    int_32 objectID, // negative value means "currently selected object"
    uint_8 usePreDockPose,
    uint_8 useManualSpeed
}

// RollObject
message RollObject {
  int_32 objectID, // negative value means "currently selected object"
  uint_8 usePreDockPose,
  uint_8 useManualSpeed
}

// TraverseObject
message TraverseObject {
    uint_8 usePreDockPose,
    uint_8 useManualSpeed
}

// SetRobotCarryingObject
// (Override robot's current belief about whether it's carrying a block)
// (Ideally, for dev/prototyping only)
message SetRobotCarryingObject {
    int_32 objectID, // use -1 to specify "none"
    uint_8 robotID
}

// ClearAllBlocks
//   Clears just blocks (active and passive)
message ClearAllBlocks {
    uint_8 robotID
}

// ClearAllObjects
//   Clears all objects the robot knows about (blocks, ramps, mats, etc)
message ClearAllObjects {
    uint_8 robotID
}

message SetObjectAdditionAndDeletion {
    uint_8 robotID,
    bool   enableAddition,
    bool   enableDeletion
}

// VisionWhileMoving
// For development, enable/disable robots' ability to use VisionMarkers while moving
// May be necessary to have this disabled while we have frame sync issues.
// NOTE: This will apply to all robots currently connected.
message VisionWhileMoving {
    uint_8 enable // True or false
}

// ExecuteBehavior
message ExecuteBehavior {
    string behaviorName
}

// AbortPath
message AbortPath {
}

// AbortAll
message AbortAll {
}

// CancelAction
//  Use actionType to cancel any queued actions of the specified type.
//  Use actionType = -1 to cancel all actions, regardless of type.
message CancelAction {
  RobotActionType actionType,  // See actionTypes.def
//  int_32 slotHandle,  // TODO: Add this later if it makes sense
  uint_8 robotID
}

// DrawPoseMarker
message DrawPoseMarker {
    float_32 x_mm,
    float_32 y_mm,
    float_32 rad,
    uint_8 level
}

// ErasePoseMarker
message ErasePoseMarker {
}

// SetWheelControllerGains
message SetWheelControllerGains {
  float_32 kpLeft,
  float_32 kiLeft,
  float_32 maxIntegralErrorLeft,
  float_32 kpRight,
  float_32 kiRight,
  float_32 maxIntegralErrorRight
}

// SetHeadControllerGains
message SetHeadControllerGains {
    float_32 kp,
    float_32 kd,
    float_32 ki,
    float_32 maxIntegralError
}

// SetLiftControllerGains
message SetLiftControllerGains {
    float_32 kp,
    float_32 kd,
    float_32 ki,
    float_32 maxIntegralError
}

// SetSteeringControllerGains
message SetSteeringControllerGains {
  float_32 k1,
  float_32 k2
}

// StartTestMode
message StartTestMode {
    int_32 p1,
    int_32 p2,
    int_32 p3,
    uint_8 mode
}

// IMURequest
message IMURequest {
    uint_32 length_ms
}

// PlayAnimation
message PlayAnimation {
    uint_8  robotID,
    uint_32 numLoops,
    string animationName
}

// ReplayLastAnimation
message ReplayLastAnimation {
    uint_8  robotID,
    uint_32 numLoops
}

// SetIdleAnimation
//  Set the animation that will be played (in a continuous loop) if no other
//  animation has been set using PlayAnimation above.
//  Use the empty string to disable the idle animation.
message SetIdleAnimation {
    uint_8 robotID,
    string animationName
}

// ReadAnimationFile
message ReadAnimationFile {
}

// StartFaceTracking
message StartFaceTracking {
//TODO: add     uint_8 selectionMode
    uint_8 timeout_sec
}

// StopFaceTracking
message StopFaceTracking {
}

// StartLookingForMarkers
message StartLookingForMarkers {
}

// StopLookingForMarkers
message StopLookingForMarkers {
}

// SetVisionSystemParams
message SetVisionSystemParams {
    int_32 autoexposureOn,
    float_32 exposureTime,
    int_32 integerCountsIncrement,
    float_32 minExposureTime,
    float_32 maxExposureTime,
    float_32 percentileToMakeHigh,
    int_32 limitFramerate,
    uint_8 highValue
}

// SetFaceDetectParams
message SetFaceDetectParams {
    float_32 scaleFactor,
    int_32 minNeighbors,
    int_32 minObjectHeight,
    int_32 minObjectWidth,
    int_32 maxObjectHeight,
    int_32 maxObjectWidth
}

// SetActiveObjectLEDs
message SetActiveObjectLEDs {
    uint_32  objectID,
    uint_32  onColor,
    uint_32  offColor,
    uint_32  onPeriod_ms,
    uint_32  offPeriod_ms,
    uint_32  transitionOnPeriod_ms,
    uint_32  transitionOffPeriod_ms,
    float_32 relativeToX,
    float_32 relativeToY,
    uint_8   whichLEDs,    // Bit pattern: see activeBlockTypes.h
    uint_8   makeRelative, // MakeRelativeMode: see activeBlockTypes.h
    uint_8   turnOffUnspecifiedLEDs, // whether to augment current pattern, or turn off everything but what's specified
    uint_8   robotID
}

// SetAllActiveObjectLEDs
message SetAllActiveObjectLEDs {
  uint_32  objectID,
  uint_32  onColor[4],
  uint_32  offColor[4],
  uint_32  onPeriod_ms[4],
  uint_32  offPeriod_ms[4],
  uint_32  transitionOnPeriod_ms[4],
  uint_32  transitionOffPeriod_ms[4],
  float_32 relativeToX,
  float_32 relativeToY,
  uint_8   makeRelative,  // if 0, ignores relativeX/relativeY
  uint_8   robotID
}

// SetBackpackLEDs
//  See ledTypes.h for the enumeration of the available backpack LEDs.
message SetBackpackLEDs {
  uint_32  onColor[5],
  uint_32  offColor[5],
  uint_32  onPeriod_ms[5],
  uint_32  offPeriod_ms[5],
  uint_32  transitionOnPeriod_ms[5],
  uint_32  transitionOffPeriod_ms[5],
  uint_8   robotID
}

message TapBlockOnGround {
  uint_8   numTaps
}

// VisualizeQuad
//  Draws the specified quadrilateral using the Visualization system.
//  The quadID will be created if new or replaced if it already exists (i.e., you
//  do not need to send an EraseQuad message before updating an existing quad).
message VisualizeQuad {
  uint_32 quadID,
  uint_32 color, // RGBA
  float_32 xUpperLeft,
  float_32 yUpperLeft,
  float_32 zUpperLeft,
  float_32 xLowerLeft,
  float_32 yLowerLeft,
  float_32 zLowerLeft,
  float_32 xUpperRight,
  float_32 yUpperRight,
  float_32 zUpperRight,
  float_32 xLowerRight,
  float_32 yLowerRight,
  float_32 zLowerRight
}

// EraseQuad
//  Erase the visualized quad with the specified ID
message EraseQuad {
  uint_32 quadID
}

structure RobotActionUnion {
  FaceObject         faceObject,
  GotoPose           goToPose,
  GotoObject         goToObject,
  PlayAnimation      playAnimation,
  PickAndPlaceObject pickAndPlaceObject,
  RollObject         rollObject,
  SetLiftHeight      setLiftHeight,
  SetHeadAngle       setHeadAngle,
  TurnInPlace        turnInPlace
}

// QueueSingleAction
message QueueSingleAction {
  uint_8  robotID,
  uint_32 inSlot,
  uint_8  numRetries,
  QueueActionPosition    position,
  RobotActionType        actionType,
  RobotActionUnion       action
}

// QueueCompoundAction
message QueueCompoundAction {
  uint_8  robotID,
  uint_32 inSlot,
  uint_8  numRetries,
  bool  parallel,  // false means sequential
  QueueActionPosition    position,
  RobotActionType        actionTypes[uint_8],
  RobotActionUnion       actions[uint_8]
}

// keep empty to generate an auto-union that includes all messages in this file
// if you do not want to include messages in this union, use the keyword "structure" instead of "message"
union Message { }

} // namespace U2G
} // namespace Cozmo
} // namespace Anki
